<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.gingkocyx.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言：前半部分为安装Linux系统的一些经验以及参考资料。后面为Linux实验报告内容 （2022.7.4 19:58 持续更新中……）">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux操作系统">
<meta property="og:url" content="https://www.gingkocyx.top/linux_os/linux-basis/index.html">
<meta property="og:site_name" content="gingkocyx">
<meta property="og:description" content="前言：前半部分为安装Linux系统的一些经验以及参考资料。后面为Linux实验报告内容 （2022.7.4 19:58 持续更新中……）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125182839787.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125190214435.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704112837341.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704215806297.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704221450001.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704222123222.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704223551560.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704223913279.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704225154082.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704231539897.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704232626395.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704234446377.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705001311498.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705001623697.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705003005314.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705003311832.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705003927838.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705004308888.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705005033407.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705005356264.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705005657308.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/file-permissions-rwx.jpg">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705094917623.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705100333458.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705102143197.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705104326318.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705104711885.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705110121374.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704143920143.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704144506902.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704145946183.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704143959369.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704145411562.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704145002614.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704150124662.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704152424046.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704151111934.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704152715510.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704150533477.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704161023915.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704161101850.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704161517579.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704163340575.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704163954960.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704190006605.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704190643558.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704191509583.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704191828619.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704201419046.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704201628781.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704212728390.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705111509601.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705112006318.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705150326911.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705151532737.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705143933085.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705153536868.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705160212068.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705160834402.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705170634657.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705170251733.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705170046349.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705163605416.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705164021373.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705194207762.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705202439216.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705202506838.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705202543774.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705194512120.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201728741.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201323025.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201448884.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201635239.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706001112093.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706000447630.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706084756910.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/2cf7aad4d84b464ea90328e011b6f4f4.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/R-3C.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706111311113.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122125648.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122034504.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122556344.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122832856.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706123601521.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706123804447.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706124104408.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706124202794.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706130223990.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133202184.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133312671.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706132756023.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133719748.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133852053.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/650075-5a40190134864d49.png">
<meta property="article:published_time" content="2022-07-04T11:45:46.000Z">
<meta property="article:modified_time" content="2022-07-06T05:40:45.535Z">
<meta property="article:author" content="Cheng">
<meta property="article:tag" content="linux os">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125182839787.png">

<link rel="canonical" href="https://www.gingkocyx.top/linux_os/linux-basis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux操作系统 | gingkocyx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gingkocyx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">every piece of life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.gingkocyx.top/linux_os/linux-basis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cheng">
      <meta itemprop="description" content="my first blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gingkocyx">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-04 19:45:46" itemprop="dateCreated datePublished" datetime="2022-07-04T19:45:46+08:00">2022-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-06 13:40:45" itemprop="dateModified" datetime="2022-07-06T13:40:45+08:00">2022-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2022-Summer/" itemprop="url" rel="index"><span itemprop="name">2022 Summer</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2022-Summer/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>55 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前言：前半部分为安装Linux系统的一些经验以及参考资料。后面为Linux实验报告内容</p>
<p>（2022.7.4 19:58 持续更新中……）</p>
<span id="more"></span>
<h1 id="安装CentOS7"><a href="#安装CentOS7" class="headerlink" title="安装CentOS7"></a>安装CentOS7</h1><p>写安装日志的时间为2022寒假。在电脑上安装OpenEuler与CentOS的过程大同小异。</p>
<h2 id="镜像刻录"><a href="#镜像刻录" class="headerlink" title="镜像刻录"></a>镜像刻录</h2><p>【参考资料】<a target="_blank" rel="noopener" href="https://blog.csdn.net/realzuile/article/details/82688654">centos7/win7 双系统安装教程</a></p>
<ul>
<li><p>准备好镜像和刻录工具</p>
<p><a target="_blank" rel="noopener" href="https://cn.ultraiso.net/xiazai.html">Ultraiso</a></p>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/centos/7.9.2009/isos/x86_64/">CentOS镜像</a></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125182839787.png" alt="image-20220125182839787" style="zoom: 80%;" /></p>
<p>等待刻录完成</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125190214435.png" alt="image-20220125190214435" style="zoom:67%;" /></p>
<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p>大致过程是插入U盘，重启电脑进入BIOS，使用USB启动，进入系统安装引导程序。</p>
<p>按照教程安装系统即可。</p>
<h3 id="引导项"><a href="#引导项" class="headerlink" title="引导项"></a>引导项</h3><p>最后需要把Windows引导项找回</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nmgrd/article/details/51754704">恢复centos7与windows7系统引导方法-亲测可用</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43002202/article/details/120951578">Windows11安装Ubuntu 20.04.3 LTS双系统（详细过程）</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/robator/article/details/110452439">centos下添加windows启动项</a></p>
<h1 id="2022Linux实验"><a href="#2022Linux实验" class="headerlink" title="2022Linux实验"></a>2022Linux实验</h1><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><h3 id="一、建立用户账号"><a href="#一、建立用户账号" class="headerlink" title="一、建立用户账号"></a>一、建立用户账号</h3><p>使用<code>useradd</code>命令即可，使用<code>passwd</code>命令设置密码。在root用户下使用<code>su</code>命令切换用户开始实验。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建用户，并自动建立用户的登入目录</span></span><br><span class="line">useradd -m c2200400109</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置密码</span></span><br><span class="line">passwd c2200400109 &lt;&lt; EOF</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">2200400109</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">2200400109</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">EOF</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换用户</span></span><br><span class="line">su c2200400109</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：<span class="built_in">exit</span>退出用户</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704112837341.png" alt="图1 创建用户" style="zoom:80%;" /></p>
<h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><p>如果直接对文件进行操作会出现”Permission denied”的报错，因为<strong>权限不够</strong>。</p>
<p>可以在root账号下，给予刚刚创建的用户权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /home/用户名	# 可读可写可执行</span><br></pre></td></tr></table></figure>
<p>进入创建的用户中，在”/home/用户名”路径下进行实验。</p>
<h3 id="二、文件管理操作"><a href="#二、文件管理操作" class="headerlink" title="二、文件管理操作"></a>二、文件管理操作</h3><p>对于文件的操作主要包含增、删、改、查。这些命令如果再细化，结合课上的内容还有这样几类：文件的创建命令，文件匹配排序命令，比较文件内容命令，复制、删除和移动文件的命令，文件内容统计命令。对于文件的查（阅读命令，如cat, more, less, head, tail）将在后面第四个标题中详细介绍。</p>
<h5 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a><code>touch</code>命令</h5><p><strong>功能</strong>：用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">改变档案的读取时间记录</td>
</tr>
<tr>
<td style="text-align:center">-m</td>
<td style="text-align:center">改变档案的修改时间记录</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">假如目的档案不存在，不会建立新的档案。与 —no-create 的效果一样</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:center">不使用，是为了与其他 unix 系统的相容性而保留</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">使用参考档的时间记录，与 —file 的效果一样</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:center">设定时间与日期，可以使用各种不同的格式</td>
</tr>
<tr>
<td style="text-align:center">-t</td>
<td style="text-align:center">设定档案的时间记录，格式与 date 指令相同</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：在/home/c2200400109目录下创建一个空白文件test08</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls -la	# 查看当前目录下的所有文件</span><br><span class="line">touch test08</span><br><span class="line">ls -la	# 查看创建后的目录下所有文件</span><br><span class="line">cat test08 # 查看test08文件内容</span><br></pre></td></tr></table></figure>
<p>结果：使用touch命令在文件不存在的前提下能够创建空白文件。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704215806297.png" alt="图2 创建空白文件test08" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：在已存在非空白文件test09的情况下使用touch命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;1&quot; &gt; test09	# 创建test09并写入字符1</span><br><span class="line">cat test09			# 查看test09内容</span><br><span class="line">touch test09		# touch</span><br><span class="line">cat test09			# 检验touch是否起作用</span><br></pre></td></tr></table></figure>
<p>结果：touch命令无法创建已存在的文件，或者对已存在的文件进行覆盖。（这点与echo命令不同）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704221450001.png" alt="图3 对已存在文件test09使用touch命令" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：修改已存在文件test03的时间属性。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l test03	# 查看test03的时间属性</span><br><span class="line">touch test03	# 修改test03的时间属性</span><br><span class="line">ls -l test03	# 查看修改后的test03时间属性</span><br></pre></td></tr></table></figure>
<p>结果：原来test03文件的时间属性为20:23，经过touch命令修改后，时间属性变为22:21。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704222123222.png" alt="图4 修改时间属性" style="zoom:80%;" /></p>
<h5 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a><code>rm</code>命令</h5><p><strong>功能</strong>：用于删除一个文件或者一个目录</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [命令参数] [文件/目录名]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-i</td>
<td style="text-align:center">删除前逐一询问确认</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:center">即使原档案属性设为唯读，亦直接删除，无需逐一确认</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">递归删除目标目录及其子目录以及包含的所有文件</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：删除/home/c2200400109目录下的test09文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls			# 查看当前目录下的文件</span><br><span class="line">rm test09	# 删除test09</span><br><span class="line">ls			# 检查是否删除成功</span><br></pre></td></tr></table></figure>
<p>结果：目录下已存在的文件test09被成功删除。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704223551560.png" alt="图5 删除test09文件" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：使用询问确认的方式删除test08文件。（命令参数：-i）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls			# 查看当前目录下的文件</span><br><span class="line">rm test08	# 删除test08</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">y			<span class="comment"># 确认删除</span></span></span><br><span class="line">ls			# 检查是否删除成功</span><br></pre></td></tr></table></figure>
<p>结果：经过询问后成功删除test08文件。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704223913279.png" alt="图6 删除test08文件" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：以递归的方式删除rmtest目录（包含rmtest01目录和文本文件rmtest.txt）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir rmtest		# 创建rmtest目录</span><br><span class="line">ls					# 检查rmtest目录是否创建成功</span><br><span class="line">cd rmtest			# 进入rmtest目录</span><br><span class="line">touch rmtest.txt	# 创建文本文件</span><br><span class="line">mkdir rmtest01		# 创建目录</span><br><span class="line">ls					# 检查目录和文本文件是否创建成功</span><br><span class="line">cd .. 				# 返回到/home/c2200400109</span><br><span class="line">rm -i -r rmtest		# 删除目录</span><br><span class="line">ls					# 检查目录是否已被删除</span><br></pre></td></tr></table></figure>
<p>结果：rmtest目录被删除，连同其中的目录rmtest01和文本文件rmtest.txt</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704225154082.png" alt="图7 删除rmtest目录" style="zoom:80%;" /></p>
<p>总结：如果是删除整个目录文件使用参数-r进行递归删除；删除有风险，建议每次删除加上命令参数-i。</p>
<h5 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a><code>cp</code>命令</h5><p><strong>功能：</strong>用于复制文件或目录，将源文件或目录赋值拷贝到目标文件或目录中。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [options] source... dirctory </span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:center">复制时保留链接（相当于Windows的快捷方式）</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:center">覆盖已经存在的目标文件而不给出提示</td>
</tr>
<tr>
<td style="text-align:center">-i</td>
<td style="text-align:center">在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答y时目标文件将被覆盖</td>
</tr>
<tr>
<td style="text-align:center">-p</td>
<td style="text-align:center">除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td style="text-align:center">不复制文件，只是生成链接文件</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：（文件复制）将/home/c2200400109目录下的test02文件复制到当前目录的test002文件中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls					# 查看当前目录下的文件</span><br><span class="line">cat test02			# 查看test02文件内容</span><br><span class="line">cp test02 test002	# 文件复制</span><br><span class="line">ls					# 查看复制后目录中的文件</span><br><span class="line">cat test002			# 查看test002文件内容</span><br></pre></td></tr></table></figure>
<p>结果：test02成功复制到同目录下的test002文件中，且文件内容与test02一致。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704231539897.png" alt="图8 复制test02文件" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：（文件复制）将test01文件复制到findtest目录下且不改变文件名。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls					# 查看当前目录下的所有文件</span><br><span class="line">tail -5 test01		# 查看test01文件最后5行</span><br><span class="line">cp test01 findtest	# 复制test01文件到findtest目录</span><br><span class="line">cd findtest			# 进入findtest目录</span><br><span class="line">ls					# 查看findtest目录下的文件</span><br><span class="line">tail -5 test01		# 查看复制后的test01文件最后5行</span><br></pre></td></tr></table></figure>
<p>结果：test01文件成功复制到findtest目录且生成了同名文件，文件的内容不变。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704232626395.png" alt="图9 复制test01文件" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：（目录复制）将findtest目录递归复制到newfindtest目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -r findtest/ newfindtest</span><br><span class="line">cd newfindtest</span><br><span class="line">ls</span><br><span class="line">tail -5 test01</span><br></pre></td></tr></table></figure>
<p>结果：findtest连通里面的test01文件被复制到newfindtest目录下，且文件内容没有发生变化。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704234446377.png" alt="图10 复制目录" style="zoom:80%;" /></p>
<p>总结：有一点需要注意区分，将文件夹拷贝到另一个文件夹和将文件夹中所有的文件拷贝到另一个文件夹的区别。前者可以使用/*完成，均需要-r参数。</p>
<h5 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a><code>mv</code>命令</h5><p><strong>功能</strong>：为文件或目录改名、或将文件或目录移入其它位置</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [options] source dest</span><br><span class="line">mv [options] source... directory</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-b</td>
<td style="text-align:center">当目标文件或目录存在时则在执行覆盖前会为其创建一个备份</td>
</tr>
<tr>
<td style="text-align:center">-i</td>
<td style="text-align:center">若同名，则先询问是否覆盖旧文件决定是否覆盖和取消</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:center">若同名，不询问直接覆盖旧文件</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td style="text-align:center">不要覆盖任何已存在的文件或目录</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:center">当源文件比目标文件新或者目标文件不存在时，才执行移动操作</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：将test002重命名为test0002。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">mv test002 test0002</span><br><span class="line">ls</span><br><span class="line">cat test0002</span><br></pre></td></tr></table></figure>
<p>结果：可以看到test002文件没有出现在当前目录中，目录中多了test0002文件，且文件内容与之前的test002内容一致，则完成了移动（重命名）的操作。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705001311498.png" alt="图11 移动文件" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：将test0002文件移动到newfindtest目录中，覆盖原有的test01文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">mv -i test0002 newfindtest/test01</span><br><span class="line">cd newfindtest</span><br><span class="line">ls</span><br><span class="line">tail -5 test01</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705001623697.png" alt="图12 移动并覆盖文件" style="zoom:80%;" /></p>
<h3 id="三、目录管理操作"><a href="#三、目录管理操作" class="headerlink" title="三、目录管理操作"></a>三、目录管理操作</h3><p>目录管理主要包含查看目录的命令（ls），创建目录的命令（mkdir），删除目录的命令（rmdir）以及目录跳转的命令（cd）</p>
<h5 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a><code>ls</code>命令</h5><p><strong>功能</strong>：用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-alrtAFR] [name...]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">显示所有文件及目录 (“.”开头的隐藏文件也会列出)</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td style="text-align:center">除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">将文件以相反次序显示(原定依英文字母次序)</td>
</tr>
<tr>
<td style="text-align:center">-t</td>
<td style="text-align:center">将文件依建立时间之先后次序列出</td>
</tr>
<tr>
<td style="text-align:center">-A</td>
<td style="text-align:center">同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</td>
</tr>
<tr>
<td style="text-align:center">-F</td>
<td style="text-align:center">在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</td>
</tr>
<tr>
<td style="text-align:center">-R</td>
<td style="text-align:center">若目录下有文件，则以下之文件亦皆依序列出</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：列出根目录下的所有目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure>
<p>结果：显示bin, dev, lib, root等根目录下的目录，并且只显示目录，不显示隐藏文件。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705003005314.png" alt="图13 显示目录" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：列出/home/c2200400109目录下的所有以test开头的文件，排序顺序按照时间属性从早到晚。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ltr test*</span><br></pre></td></tr></table></figure>
<p>结果：依次列出test02, test04.txt, test05.cpp, test06.py, test07.asm, test01, test03，并显示文件权限，文件拥有者以及时间属性。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705003311832.png" alt="图14 列出属性" style="zoom:80%;" /></p>
<h5 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a><code>mkdir</code>命令</h5><p><strong>功能</strong>：用于创建目录</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] dirName</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>确保目录名称存在，不存在则创建</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：在/home/c2200400109工作目录下，创建一个名为dirtest的子目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line">mkdir dirtest</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<p>结果：子目录dirtest创建成功。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705003927838.png" alt="图15 创建子目录" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：在dirtest目录中，创建一个dirtest001的目录。测试在不使用-p命令下，能否在未被创建的目录dirtest2中创建dirtest001目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir	 dirtest2/dirtest001</span><br><span class="line">mkdir -p dirtest/dirtest001</span><br></pre></td></tr></table></figure>
<p>结果：在目录不存在且不适用-p参数时产生错误。使用-p命令可以顺利完成创建二级子目录的操作。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705004308888.png" alt="图16 -p参数使用对比测试" style="zoom:80%;" /></p>
<h5 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a><code>rmdir</code>命令</h5><p><strong>功能</strong>：用于删除空的目录。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [-p] dirName</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>当子目录被删除后使它也成为空目录的话，则顺便一并删除</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：删除在刚刚的/home/c2200400109/dirtest中的dirtest子目录（非空）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir dirtest</span><br></pre></td></tr></table></figure>
<p>结果：dirtest目录无法被删除，因为目录非空。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705005033407.png" alt="图17 删除非空目录尝试" style="zoom: 80%;" /></p>
<p><strong>输入测试2</strong>：删除在刚刚的/home/c2200400109/dirtest中的dirtest子目录（非空）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">rmdir -p dirtest001</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p>结果：dirtest001目录被成功删除。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705005356264.png" alt="图18 使用-p参数删除非空目录" style="zoom:80%;" /></p>
<h5 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a><code>cd</code>命令</h5><p><strong>功能</strong>：用于切换当前工作目录。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [dirName]</span><br></pre></td></tr></table></figure>
<p><strong>输入测试</strong>：跳到/usr/bin目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705005657308.png" alt="图19 目录跳转切换" style="zoom:80%;" /></p>
<h3 id="四、管理使用与权限设置"><a href="#四、管理使用与权限设置" class="headerlink" title="四、管理使用与权限设置"></a>四、管理使用与权限设置</h3><p>管理权限设置主要用到的命令有chmod（改变文件/目录的权限）, umask（设置新文件权限的掩码）, chgrp（改变用户组和文件主）,  chown（改变某个文件或目录的所有者和所属的组）</p>
<h5 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a><code>chmod</code>命令</h5><p><strong>功能</strong>：控制用户对文件的权限的命令</p>
<p><strong>说明</strong>：文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/file-permissions-rwx.jpg" alt="图20 权限示意图" style="zoom:50%;" /></p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod [选项] 文件和目录列表</span><br><span class="line">chmod [-cfvR] [--help] [--version] mode file...</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号模式</th>
<th>用户类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>user</td>
<td>文件所有者</td>
</tr>
<tr>
<td>g</td>
<td>group</td>
<td>文件所有者所在组</td>
</tr>
<tr>
<td>o</td>
<td>others</td>
<td>所有其他用户</td>
</tr>
<tr>
<td>a</td>
<td>all</td>
<td>所用用户, 相当于 <em>ugo</em></td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>Operator</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>为指定的用户类型增加权限</td>
</tr>
<tr>
<td><code>-</code></td>
<td>去除指定用户类型的权限</td>
</tr>
<tr>
<td><code>=</code></td>
<td>设置指定用户权限的设置，即将用户类型的所有权限重新设置</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>#</th>
<th>权限</th>
<th>rwx</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>7</td>
<td>读 + 写 + 执行</td>
<td>rwx</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>读 + 写</td>
<td>rw-</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>读 + 执行</td>
<td>r-x</td>
<td>101</td>
</tr>
<tr>
<td>4</td>
<td>只读</td>
<td>r—</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>写 + 执行</td>
<td>-wx</td>
<td>011</td>
</tr>
<tr>
<td>2</td>
<td>只写</td>
<td>-w-</td>
<td>010</td>
</tr>
<tr>
<td>1</td>
<td>只执行</td>
<td>—x</td>
<td>001</td>
</tr>
<tr>
<td>0</td>
<td>无</td>
<td>—-</td>
<td>000</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：使用符号模式，将/home/c2200400109目录下的test04.txt文件的所有者权限设置为可读可写可执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l test04.txt			# 查看test04.txt的权限</span><br><span class="line">chmod u = rwx test04.txt 	# 修改test04.txt的权限</span><br><span class="line">ls -l test04.txt			# 检查权限是否修改成功</span><br></pre></td></tr></table></figure>
<p>结果：原test04.txt文件的所有者权限为可读可写（rw），经过修改权限后，所有者权限变成可读可写可执行（rwx）。文件的所有者权限修改成功。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705094917623.png" alt="图21 符号模式改变权限" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：使用八进制数模式，将/home/c2200400109目录下的dirtest目录的权限设置为所有者权限为可读，同组用户权限为可写，其他用户权限为可执行，同时将dirtest的所有子目录和文件权限一其处理。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l dirtest			# 查看dirtest的权限</span><br><span class="line">chmod -R 421 dirtest    # 递归修改dirtest权限及其子目录和文件的权限</span><br><span class="line">ls -l dirtest			# 查看dirtest修改后的权限</span><br><span class="line">cd dirtest				# 查看子目录和文件的权限</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<p>结果：dirtest目录的权限原本是775（所有者权限为可读可写可执行，同组用户权限为可读可写可执行，其他用户权限为可读可执行）经过修改后所有者权限为可读，同组用户权限为可写，其他用户权限为可执行，并且子目录的权限也被修改。（同名子目录dirtest）不过由于自己创建的用户没有添加到root组，因此上述操作均是在root用户下执行，但是修改权限的文件都是新创建用户的。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705100333458.png" alt="图22 八进制数改变权限" style="zoom:80%;" /></p>
<h5 id="chgrp命令"><a href="#chgrp命令" class="headerlink" title="chgrp命令"></a><code>chgrp</code>命令</h5><p><strong>功能</strong>：用于变更文件或目录的所属群组。需要注意的是，<code>chgrp</code>命令允许普通用户改变文件所属的组，只要该用户是该组的一员。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组名 文件名</span><br><span class="line">chgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=&lt;参考文件或目录&gt;][--version][文件或目录...]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c 或 —changes</td>
<td>效果类似”-v”参数，但仅报告更改的部分</td>
</tr>
<tr>
<td>-f 或 —quiet 或 —silent</td>
<td>不显示错误信息</td>
</tr>
<tr>
<td>-h 或 —no-dereference</td>
<td>只对符号连接的文件作修改，而不改动其他任何相关文件</td>
</tr>
<tr>
<td>-R 或 —recursive</td>
<td>递归处理，将指定目录下的所有文件及子目录一并处理</td>
</tr>
<tr>
<td>-v 或 —verbose</td>
<td>显示指令执行过程</td>
</tr>
</tbody>
</table>
</div>
<p>在进行实验之前，首先要创建一个新用户组<code>newHiter</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd newHiter			# 如果不是在root权限下，需要使用sudo</span><br><span class="line">grep newHiter /etc/group 	# 查看是否创建用户组成功</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705102143197.png" alt="图23 创建用户组" style="zoom:80%;" /></p>
<p>在/etc/group文件中，知道了newHiter用户组的ID为1003。</p>
<p><strong>输入测试1</strong>：将/home/c2200400109目录下的findtest目录的用户组改为newHiter。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"><span class="built_in">chgrp</span> -R newHiter findtest</span><br><span class="line"><span class="built_in">ls</span> -l findtest</span><br></pre></td></tr></table></figure>
<p>结果：findtest目录的用户组由c2200400109变更为newHiter。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705104326318.png" alt="图24 变更用户组" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：将/home/c2200400109目录下的test05.cpp文件的用户组改为root。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l test05.cpp			# 查看test05.cpp文件的用户组</span><br><span class="line">chgrp root test05.cpp		# 变更用户组为root</span><br><span class="line">ls -l test05.cpp			# 检查用户组是否更改</span><br></pre></td></tr></table></figure>
<p>结果：test05.cpp文件的用户组由c2200400109变更为root。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705104711885.png" alt="图25 变更root用户组" style="zoom:80%;" /></p>
<p>总结：chgrp命令需要root权限，否则需要使用sudo提权。对于用户组更改的命令更适合管理员/权限较高者使用，以便用户管理。</p>
<h5 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a><code>chown</code>命令</h5><p><strong>功能</strong>：用于设置文件所有者和文件关联组。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID，组可以是组名或者组 ID，文件是以空格分开的要改变权限的文件列表，支持通配符。注意：需要root权限才能执行chown命令。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 用户或组 文件名</span><br><span class="line">chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>新的文件拥有者的使用者 ID</td>
</tr>
<tr>
<td>group</td>
<td>新的文件拥有者的使用者组(group)</td>
</tr>
<tr>
<td>-c</td>
<td>显示更改的部分的信息</td>
</tr>
<tr>
<td>-f</td>
<td>忽略错误信息</td>
</tr>
<tr>
<td>-h</td>
<td>修复符号链接</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的处理信息</td>
</tr>
<tr>
<td>-R</td>
<td>处理指定目录以及其子目录下的所有文件</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试</strong>：将/home/c2200400109目录下面的test06.py和test07.asm文件的用户改成root。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l test06.py test07.asm</span><br><span class="line">chown root test06.py test07.asm</span><br><span class="line">ls -l test06.py test07.asm</span><br></pre></td></tr></table></figure>
<p>结果：test06.py和test07.asm文件的拥有者从c2200400109变更为root。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705110121374.png" alt="图26 变更文件拥有者" style="zoom:80%;" /></p>
<h3 id="五、文件阅读与查找"><a href="#五、文件阅读与查找" class="headerlink" title="五、文件阅读与查找"></a>五、文件阅读与查找</h3><h4 id="1、文件阅读命令"><a href="#1、文件阅读命令" class="headerlink" title="1、文件阅读命令"></a>1、文件阅读命令</h4><p>为了对文件显示进行实验，需要事<strong>先创建文件并向文件写入内容</strong>。而且为了比较cat, more, less, head, tail命令的异同，文件需要有较多的内容。使用”&gt;”进行目标文件的写入。使用”&gt;&gt;”对内容进行追加。</p>
<p>用于实验的第一个文件为<code>test01</code>，内容为系统进程信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top ps -ef &gt; test01		# 将进程信息存入test01文件保存</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704143920143.png" alt="图27 保存test01文件" style="zoom:80%;" /></p>
<p>用于实验的第二个文件为<code>test02</code>，内容为三行”this is a test.”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建test02文件</span></span><br><span class="line">touch test02</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加三行内容</span></span><br><span class="line">echo &quot;this is a test.&quot; &gt;&gt; test02</span><br><span class="line">echo &quot;this is a test.&quot; &gt;&gt; test02</span><br><span class="line">echo &quot;this is a test.&quot; &gt;&gt; test02</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后期为了测试空白行，追加空白行和文本内容</span></span><br><span class="line">echo &gt;&gt; test02</span><br><span class="line">echo &quot;this is a test for blank line.&quot; &gt;&gt; test02</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704144506902.png" alt="图28 保存test02文件" style="zoom:80%;" /></p>
<p>用于测试空白行输出的追加内容。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704145946183.png" alt="图29 向test02追加内容" style="zoom:80%;" /></p>
<h5 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a><code>cat</code>命令</h5><p><strong>功能</strong>：由第一行开始显示文件内容，也可以完成文件的创建和合并。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat [filename]	# 从第一行开始，一次显示整个文件</span><br><span class="line">cat &gt; [filename] # 创建文件名为&quot;filename&quot;的文件</span><br><span class="line">cat [f1] [f2] ... [fn] &gt; [file] # 将多个文件合并为一个</span><br></pre></td></tr></table></figure>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [命令参数] [文件] </span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-A</td>
<td style="text-align:center">相当于 -vET的整合选项，可列出一些非空白的特殊字符</td>
</tr>
<tr>
<td style="text-align:center">-b</td>
<td style="text-align:center">列出行号，仅显示对非空白行进行编号并显示</td>
</tr>
<tr>
<td style="text-align:center">-E</td>
<td style="text-align:center">显示每一行结束的断行符号”$”</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td style="text-align:center">打印行号。与-b不同，空白行也显示行号</td>
</tr>
<tr>
<td style="text-align:center">-T</td>
<td style="text-align:center">将[TAB]按键以”^I”显示出来</td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td style="text-align:center">列出看不出来的特殊字符</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：test01文件内容显示（缺省命令参数）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test01	# 对test01文件cat</span><br></pre></td></tr></table></figure>
<p>结果：由于文件行数过多，输出的结果可能并不完整。（后续添加-n参数能够验证）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704143959369.png" alt="图30 对test01使用cat" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：test01文件内容带行号显示（命令参数：-n）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n test01	# 使用-n参数对test01文件cat</span><br></pre></td></tr></table></figure>
<p>结果：可以看到每一行都加上了行号，可以知道test01文件中一共有138行。输出从108行的末尾开始，由此可知cat命令在本测试样例中无法显示前108行的内容，且显示行数为30-40。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704145411562.png" alt="图31 cat显示行号" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：test02文件内容显示（缺省命令参数）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test02	# 对test02文件cat</span><br></pre></td></tr></table></figure>
<p>结果：可以看到test02文件里的完整内容。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704145002614.png" alt="图32 对test02使用cat" style="zoom:80%;" /></p>
<p>后期向test02文件又追加了空白行和一行文本信息。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704150124662.png" alt="图33 对追加内容后的test02文件使用cat" style="zoom:80%;" /></p>
<p><strong>输入测试4</strong>：test02测试-A命令参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -A test02	# 使用-A参数对test02文件cat</span><br></pre></td></tr></table></figure>
<p>结果：输出test02文件的全部内容，每一行结尾的结束符可见。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704152424046.png" alt="图34 cat测试-A参数" style="zoom:80%;" /></p>
<p><strong>输入测试5</strong>：test02对非空行进行编号并显示（命令参数：-b）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b test02	# 使用-b参数对test02文件cat</span><br></pre></td></tr></table></figure>
<p>结果：输出test02文件的全部内容（包括空白行），但是没有对空白行进行编号。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704151111934.png" alt="图35 cat测试-b参数" style="zoom:80%;" /></p>
<p><strong>输入测试6</strong>：test02文件内容每一行结尾显示”$”：（命令参数：-e）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -e test02	# 使用-e参数对test02文件cat</span><br></pre></td></tr></table></figure>
<p>结果：输出test02文件的全部内容，每一行结尾的结束符可见。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704152715510.png" alt="图36 cat测试-e参数" style="zoom:80%;" /></p>
<p><strong>输入测试7</strong>：test02文件内容带行号显示（命令参数：-n）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n test02	# 使用-n参数对test02文件cat</span><br></pre></td></tr></table></figure>
<p>结果：可以看到test02文件内容与行号。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704150533477.png" alt="图37 cat测试-n参数" style="zoom:80%;" /></p>
<p>总结：cat命令的显示顺序为从上到下。因此如果文件内容的行数过多（比如超过40行），使用cat命令无法在屏幕上看到完整的输出结果，仅能看到文件最末尾的40行内容的输出。</p>
<h5 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a><code>more</code>命令</h5><p><strong>功能</strong>：可翻页检视，一页一页地显示文件内容。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">more [选项参数] [文件名]</span><br><span class="line">more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">先显示内容再清除旧资料</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:center">提示使用者，禁用 ‘哔’ 声提示</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td style="text-align:center">以实际行数计算行数</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td style="text-align:center">取消遇见特殊字元 ^L（送纸字元）时会暂停的功能</td>
</tr>
<tr>
<td style="text-align:center">-num</td>
<td style="text-align:center">一次显示的行数</td>
</tr>
<tr>
<td style="text-align:center">-p</td>
<td style="text-align:center">不以卷动的方式显示每一页，而是先清除屏幕后再显示内容</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td style="text-align:center">当遇到有连续两行以上的空白行，就代换为一行的空白行</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:center">不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）</td>
</tr>
<tr>
<td style="text-align:center">+/pattern</td>
<td style="text-align:center">在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示</td>
</tr>
<tr>
<td style="text-align:center">+num</td>
<td style="text-align:center">从第 num 行开始显示</td>
</tr>
</tbody>
</table>
</div>
<p><strong>常用操作命令</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Enter</td>
<td style="text-align:center">向下num行。默认为1</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+F</td>
<td style="text-align:center">向下滚动一屏</td>
</tr>
<tr>
<td style="text-align:center">Space</td>
<td style="text-align:center">向下滚动一屏</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+B</td>
<td style="text-align:center">返回上一屏</td>
</tr>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">输出当前行的行号</td>
</tr>
<tr>
<td style="text-align:center">:f</td>
<td style="text-align:center">输出文件名和当前行的行号</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">调用vi编辑器</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">调用Shell并执行命令</td>
</tr>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">退出more</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：test01文件按页显示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more test01</span><br></pre></td></tr></table></figure>
<p>结果：文件从第一页开始显示，左下角显示阅读进度。可以使用空格键向下翻页，使用b键向上翻页</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704161023915.png" alt="图38 more命令显示" style="zoom:80%;" /></p>
<p>向下翻两页后，到达文件尾部99%的位置。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704161101850.png" alt="图39 more命令翻页" style="zoom:80%;" /></p>
<p>在浏览文件的过程中，可以用”=”查看当前页最后一行内容对应的行号。（比如第一页对应的最后一行的行号为35）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704161517579.png" alt="图40 more命令查看行号" style="zoom:80%;" /></p>
<p>除此之外，还可以用”v”调用vi编辑器对文件内容进行编辑。输入”:f”可以当前文件的文件名以及目前显示的行数。输入”/[子串]”能够在文件中对子串内容进行匹配查找。</p>
<p><strong>输入测试2</strong>：test01文件测试指定每页显示的行数（命令参数：-num(num = 10)）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -10 test01</span><br></pre></td></tr></table></figure>
<p>结果：test01文件内容每10行为1页显示。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704163340575.png" alt="图41 more命令指定每页行数" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：test02文件从第3行开始输出（命令参数：+num(num = 3)）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +3 test02</span><br></pre></td></tr></table></figure>
<p>结果：test02文件的前三行都是”this is a test.”，从第三行输出，则只输出一行”this is a test.”。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704163954960.png" alt="图42 more命令从指令行数开始" style="zoom:80%;" /></p>
<p>总结：与cat命令相比，more命令提供的功能更加强大，能够完整查看文件并且在查看文件的同时可以对文件进行编辑，也可以调用shell执行命令。在查看行数较多文件时应优先采用more命令。</p>
<h5 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a><code>less</code>命令</h5><p><strong>功能</strong>：与more类似，可以向前翻页</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [参数] 文件</span><br></pre></td></tr></table></figure>
<h5 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a><code>head</code>命令</h5><p><strong>功能</strong>：可用于查看文件的开头部分的内容，有一个常用的参数 -n 用于显示行数，默认为 10，即显示 10 行的内容。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [参数] [文件]  </span><br></pre></td></tr></table></figure>
<h5 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a><code>tail</code>命令</h5><p><strong>功能</strong>：可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [参数] [文件]  </span><br></pre></td></tr></table></figure>
<h4 id="2、文件查找命令"><a href="#2、文件查找命令" class="headerlink" title="2、文件查找命令"></a>2、文件查找命令</h4><h5 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a><code>find</code>命令</h5><p><strong>功能</strong>：用于在指令目录下查找文件。缺省参数则在当前目录下查找子目录与文件</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find [文件路径] [表达式]</span><br><span class="line">find [PATH] [option] [action]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -<span class="built_in">print</span> 为预设 expression。</span></span><br><span class="line">find   path   -option   [   -print ]   [ -exec   -ok   command ]   &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p><strong>选项与参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">与时间有关的参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-mtime n</td>
<td style="text-align:center">n为数字，在n天之前的”一天之内“被更改过内容的文件</td>
</tr>
<tr>
<td style="text-align:center">-mtime +n</td>
<td style="text-align:center">列出在n天之前（不含n天本身）被更改过内容的文件文件名</td>
</tr>
<tr>
<td style="text-align:center">-mtime -n</td>
<td style="text-align:center">列出在n天之内（含n天本身）被更改过内容的文件文件名</td>
</tr>
<tr>
<td style="text-align:center">-newer file</td>
<td style="text-align:center">file为一个存在的文件，列出比file还要新的文件文件名</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">与使用者或群组名称有关的参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-uid n</td>
<td style="text-align:center">n为数字，这个数字时使用者账号的ID（UID，记录在/etc/passwd与账号名称对应的数字）</td>
</tr>
<tr>
<td style="text-align:center">-gid n</td>
<td style="text-align:center">n为数字，群组名称的ID（GID，记录在/etc/group）</td>
</tr>
<tr>
<td style="text-align:center">-user name</td>
<td style="text-align:center">name为使用者账号名称</td>
</tr>
<tr>
<td style="text-align:center">-group name</td>
<td style="text-align:center">name为群组名称</td>
</tr>
<tr>
<td style="text-align:center">-nouser</td>
<td style="text-align:center">寻找文件的拥有者不存在/etc/passwd的人</td>
</tr>
<tr>
<td style="text-align:center">-nogroup</td>
<td style="text-align:center">寻找文件的拥有群组不存在于/etc/passwd的文件</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">与文件权限及名称有关的参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-name filename</td>
<td style="text-align:center">搜寻文件名称为filename的文件</td>
</tr>
<tr>
<td style="text-align:center">-size [+-] SIZE</td>
<td style="text-align:center">搜寻比SIZE还要大（+）或小（-）的文件，其中SIZE的规格：c：Byte，k：KB</td>
</tr>
<tr>
<td style="text-align:center">-type TYPE</td>
<td style="text-align:center">搜寻文件的类型为TYPE的，类型主要有：一般正规文件（f），设备文件（b），目录（d），链接文件（l），socket（s），及FIFO（p）等属性</td>
</tr>
<tr>
<td style="text-align:center">-perm mode</td>
<td style="text-align:center">搜寻文件权限刚好等于mode的文件（mode类似于chmod命令的属性值）</td>
</tr>
<tr>
<td style="text-align:center">-perm -mode</td>
<td style="text-align:center">搜寻文件权限必须要全部囊括mode权限的文件</td>
</tr>
<tr>
<td style="text-align:center">-perm /mode</td>
<td style="text-align:center">搜寻文件权限包含任一mode的权限的文件</td>
</tr>
</tbody>
</table>
</div>
<p>文件结构为：/home/c2200400109路径下，有文件夹：findtest，文件：test01, test02, test03, test04.txt, test05.cpp, test06.py, test07.asm。其中，test04.txt, test05.cpp, test06.py, test07.asm均为空文件（文件大小为0）。实验在/home/c2200400109路径下进行。</p>
<p><strong>输入测试1</strong>：列出文件目录下符合后缀要求的文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.txt&quot;	# 将当前目录及其子目录下所有文件后缀为.txt的文件列出来</span><br><span class="line">find . -name &quot;*.cpp&quot;	# 将当前目录及其子目录下所有文件后缀为.cpp的文件列出来</span><br><span class="line">find . -name &quot;*.py&quot;		# 将当前目录及其子目录下所有文件后缀为.py的文件列出来</span><br><span class="line">find . -name &quot;*.asm&quot;	# 将当前目录及其子目录下所有文件后缀为.asm的文件列出来</span><br></pre></td></tr></table></figure>
<p>结果：使用find命令能够输出查找到符合格式要求的文件路径，分别将test04.txt, test05.cpp, test06.py, test07.asm的路径列出。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704190006605.png" alt="图43 find查找对应后缀文件" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：列出当前目录及其子目录中的所有文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f</span><br></pre></td></tr></table></figure>
<p>结果：分行列出了路径/home/c2200400109下的所有文件，包括隐藏文件。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704190643558.png" alt="图44 分行列出文件" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：查找当前目录及其子目录中所有文件长度为 0 的普通文件，并列出它们的完整路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -size 0 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>结果：分行列出了所有空文件：test04.txt, text05.cpp, text06.py, text07.asm。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704191509583.png" alt="图45 查找并列出长度为0普通文件" style="zoom:80%;" /></p>
<p><strong>输入测试4</strong>：将当前目录及其子目录下所有比test01文件更新的文件列出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -newer test01</span><br></pre></td></tr></table></figure>
<p>结果：将创建时间晚于test01的所有文件及文件夹列出：test02, test03, test04.txt, test05.cpp, test06.py, test07.asm, findtest。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704191828619.png" alt="图46 列出新文件" style="zoom:80%;" /></p>
<h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a><code>grep</code>命令</h5><p><strong>功能</strong>：用于查找文件中符合条件的字符串。在文本文件中查找指定模式的单词或短评，并在标准输出上显示包括给定字符串模式的所有行。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 文件名</span><br><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">选项与参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a或—text</td>
<td style="text-align:center">不忽略二进制数据</td>
</tr>
<tr>
<td style="text-align:center">-A&lt;显示行数&gt;或—after-context=&lt;显示行数&gt;</td>
<td style="text-align:center">除了显示符合范本样式的那一列之外，并显示该行之后的内容</td>
</tr>
<tr>
<td style="text-align:center">-b或—byte-offset</td>
<td style="text-align:center">在显示符合样式的那一行之前，标示出该行第一个字符的编号</td>
</tr>
<tr>
<td style="text-align:center">-B&lt;显示行数&gt; 或 —before-context=&lt;显示行数&gt;</td>
<td style="text-align:center">除了显示符合样式的那一行之外，并显示该行之前的内容</td>
</tr>
<tr>
<td style="text-align:center">-c 或 —count</td>
<td style="text-align:center">计算符合样式的列数</td>
</tr>
<tr>
<td style="text-align:center">-C&lt;显示行数&gt; 或 —context=&lt;显示行数&gt;或-&lt;显示行数&gt;</td>
<td style="text-align:center">除了显示符合样式的那一行之外，并显示该行之前后的内容</td>
</tr>
<tr>
<td style="text-align:center">-d &lt;动作&gt; 或 —directories=&lt;动作&gt;</td>
<td style="text-align:center">当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作</td>
</tr>
<tr>
<td style="text-align:center">-e&lt;范本样式&gt; 或 —regexp=&lt;范本样式&gt;</td>
<td style="text-align:center">指定字符串做为查找文件内容的样式</td>
</tr>
<tr>
<td style="text-align:center">-E 或 —extended-regexp</td>
<td style="text-align:center">将样式为延伸的正则表达式来使用</td>
</tr>
<tr>
<td style="text-align:center">-f&lt;规则文件&gt; 或 —file=&lt;规则文件&gt;</td>
<td style="text-align:center">指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式</td>
</tr>
<tr>
<td style="text-align:center">-F 或 —fixed-regexp</td>
<td style="text-align:center">将样式视为固定字符串的列表</td>
</tr>
<tr>
<td style="text-align:center">-G 或 —basic-regexp</td>
<td style="text-align:center">将样式视为普通的表示法来使用</td>
</tr>
<tr>
<td style="text-align:center">-h 或 —no-filename</td>
<td style="text-align:center">在显示符合样式的那一行之前，不标示该行所属的文件名称</td>
</tr>
<tr>
<td style="text-align:center">-H 或 —with-filename</td>
<td style="text-align:center">在显示符合样式的那一行之前，表示该行所属的文件名称</td>
</tr>
<tr>
<td style="text-align:center">-i 或 —ignore-case</td>
<td style="text-align:center">忽略字符大小写的差别</td>
</tr>
<tr>
<td style="text-align:center">-l 或 —file-with-matches</td>
<td style="text-align:center">列出文件内容符合指定的样式的文件名称</td>
</tr>
<tr>
<td style="text-align:center">-L 或 —files-without-match</td>
<td style="text-align:center">列出文件内容不符合指定的样式的文件名称</td>
</tr>
<tr>
<td style="text-align:center">-n 或 —line-number</td>
<td style="text-align:center">在显示符合样式的那一行之前，标示出该行的列数编号</td>
</tr>
<tr>
<td style="text-align:center">-o 或 —only-matching</td>
<td style="text-align:center">只显示匹配PATTERN 部分</td>
</tr>
<tr>
<td style="text-align:center">-q 或 —quiet或—silent</td>
<td style="text-align:center">不显示任何信息</td>
</tr>
<tr>
<td style="text-align:center">-r 或 —recursive</td>
<td style="text-align:center">此参数的效果和指定”-d recurse”参数相同</td>
</tr>
<tr>
<td style="text-align:center">-s 或 —no-messages</td>
<td style="text-align:center">不显示错误信息</td>
</tr>
<tr>
<td style="text-align:center">-v 或 —invert-match</td>
<td style="text-align:center">显示不包含匹配文本的所有行</td>
</tr>
<tr>
<td style="text-align:center">-V 或 —version</td>
<td style="text-align:center">显示版本信息</td>
</tr>
<tr>
<td style="text-align:center">-w 或 —word-regexp</td>
<td style="text-align:center">只显示全字符合的列</td>
</tr>
<tr>
<td style="text-align:center">-x —line-regexp</td>
<td style="text-align:center">只显示全列符合的列</td>
</tr>
<tr>
<td style="text-align:center">-y</td>
<td style="text-align:center">此参数的效果和指定”-i”参数相同</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：在口令文件/etc/passwd中查找包含”root”的所有行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep root /etc/passwd	# 模式串为root，在passwd文件中查找</span><br></pre></td></tr></table></figure>
<p>结果：在passwd文件中找到包含root的行，并且标红高亮显示。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704201419046.png" alt="图47 列出包含root的行" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：在/home/c2200400109/test02中查找包含”test”的所有行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep test /home/c2200400109</span><br></pre></td></tr></table></figure>
<p>结果：在test02文件中找到了含有test的行并标红高亮显示</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704201628781.png" alt="图48 找到含test的行" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：在当前目录中，查找前缀有test字样的文件中包含test子串的文件，并打印出包含test的行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;test1234&quot; &gt;&gt; test03	# 向test03文件追加一行含test的子串</span><br><span class="line">echo &quot;test1111&quot; &gt;&gt; test01	# 向test01文件追加一行含test的子串</span><br><span class="line">grep test test*</span><br></pre></td></tr></table></figure>
<p>结果：在test01, test02, test03文件中均找到含有test的行</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220704212728390.png" alt="图49 查找含test的行" style="zoom:80%;" /></p>
<h3 id="六、系统用户和组的管理"><a href="#六、系统用户和组的管理" class="headerlink" title="六、系统用户和组的管理"></a>六、系统用户和组的管理</h3><h4 id="1、用户管理"><a href="#1、用户管理" class="headerlink" title="1、用户管理"></a>1、用户管理</h4><h5 id="useradd命令（配合passwd命令使用）"><a href="#useradd命令（配合passwd命令使用）" class="headerlink" title="useradd命令（配合passwd命令使用）"></a><code>useradd</code>命令（配合<code>passwd</code>命令使用）</h5><p><strong>功能</strong>：用来建立用户帐号。帐号建好之后，再用 passwd 设定帐号的密码。而可用 userdel 删除帐号。使用 useradd 指令所建立的帐号，实际上是保存在 /etc/passwd 文本文件中。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</span><br><span class="line">useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s &lt;shell&gt;]</span><br></pre></td></tr></table></figure>
<p><strong>格式</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c&lt;备注&gt;</td>
<td>加上备注文字。备注文字会保存在passwd的备注栏位中</td>
</tr>
<tr>
<td>-d&lt;登入目录&gt;</td>
<td>指定用户登入时的起始目录</td>
</tr>
<tr>
<td>-D</td>
<td>变更预设值</td>
</tr>
<tr>
<td>-e&lt;有效期限&gt;</td>
<td>指定帐号的有效期限</td>
</tr>
<tr>
<td>-f&lt;缓冲天数&gt;</td>
<td>指定在密码过期后多少天即关闭该帐号</td>
</tr>
<tr>
<td>-g&lt;群组&gt;</td>
<td>指定用户所属的群组</td>
</tr>
<tr>
<td>-G&lt;群组&gt;</td>
<td>指定用户所属的附加群组</td>
</tr>
<tr>
<td>-m</td>
<td>自动建立用户的登入目录</td>
</tr>
<tr>
<td>-M</td>
<td>不要自动建立用户的登入目录</td>
</tr>
<tr>
<td>-n</td>
<td>取消建立以用户名称为名的群组</td>
</tr>
<tr>
<td>-r</td>
<td>建立系统帐号</td>
</tr>
<tr>
<td>-s</td>
<td>指定用户登入后所使用的shell</td>
</tr>
<tr>
<td>-u</td>
<td>指定用户ID</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：创建用户hiter001，自动创建登录目录。并设置密码为123456。进入hiter001用户并确认身份。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd -m hiter001			# 创建用户hiter001</span><br><span class="line">passwd hiter001 &lt;&lt; EOF		# 设置密码</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">123456</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">123456</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">EOF</span></span><br><span class="line">su hiter001					# 切换用户</span><br><span class="line">whoami						# 确认身份</span><br></pre></td></tr></table></figure>
<p>结果：创建用户成功，并成功配置密码。切换用户后，确认了hiter001的身份。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705111509601.png" alt="图50 创建用户并设置密码" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：创建用户hiter002，自动创建登录目录。将当前工作目录切换到新创建的用户hiter002家目录，使用pwd命令打印出当前的工作目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useradd -m hiter002</span><br><span class="line">cd /home/hiter002</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>
<p>结果：创建用户hiter002成功，并且能够切换至家目录，打印出当前工作目录。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705112006318.png" alt="图51 创建用户并切换目录" style="zoom:80%;" /></p>
<h5 id="usermod命令"><a href="#usermod命令" class="headerlink" title="usermod命令"></a><code>usermod</code>命令</h5><p><strong>功能</strong>：用于修改用户账号的各项设定，例如主目录、私有组、shell等内容。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [-LU][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-l &lt;帐号名称&gt;][-s &lt;shell&gt;][-u &lt;uid&gt;][用户帐号]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c&lt;备注&gt;</td>
<td>修改用户帐号的备注文字</td>
</tr>
<tr>
<td>-d&lt;登入目录&gt;</td>
<td>修改用户登入时的目录</td>
</tr>
<tr>
<td>-e&lt;有效期限&gt;</td>
<td>修改帐号的有效期限</td>
</tr>
<tr>
<td>-f&lt;缓冲天数&gt;</td>
<td>修改在密码过期后多少天即关闭该帐号</td>
</tr>
<tr>
<td>-g&lt;群组&gt;</td>
<td>修改用户所属的群组</td>
</tr>
<tr>
<td>-G&lt;群组&gt;</td>
<td>修改用户所属的附加群组</td>
</tr>
<tr>
<td>-l&lt;帐号名称&gt;</td>
<td>修改用户帐号名称</td>
</tr>
<tr>
<td>-L</td>
<td>锁定用户密码，使密码无效</td>
</tr>
<tr>
<td>-s</td>
<td>修改用户登入后所使用的shell</td>
</tr>
<tr>
<td>-u</td>
<td>修改用户ID</td>
</tr>
<tr>
<td>-U</td>
<td>解除密码锁定</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：修改账号hiter002的名称为Hitwher。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep hiter002 /etc/passwd</span><br><span class="line">usermod -l Hitwher hiter002</span><br><span class="line">grep Hitwher /etc/passwd</span><br></pre></td></tr></table></figure>
<p>结果：用户的名称从hiter002变更为Hitwher，但是已经创建的用户文件（/home/hiter002）没有发生改变。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705150326911.png" alt="图52 改变用户名称" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：更改用户Hitwher的uid，将其改为1214。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep Hitwher /etc/passwd</span><br><span class="line">usermod -u 1214 Hitwher</span><br><span class="line">grep Hitwher /etc/passwd</span><br></pre></td></tr></table></figure>
<p>结果：使用usermod命令并配合-u参数将用户Hitwher的uid从1004变更为1214。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705151532737.png" alt="图53 改变用户的uid" style="zoom:80%;" /></p>
<h4 id="2、组管理"><a href="#2、组管理" class="headerlink" title="2、组管理"></a>2、组管理</h4><h5 id="groupadd命令"><a href="#groupadd命令" class="headerlink" title="groupadd命令"></a><code>groupadd</code>命令</h5><p><strong>功能</strong>：用于创建一个新的工作组，新工作组的信息将被添加到系统文件中。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd [参数] 组名</span><br><span class="line">groupadd [-g gid [-o]] [-r] [-f] group</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-g</td>
<td>指定新建工作组的 id</td>
</tr>
<tr>
<td>-r</td>
<td>创建系统工作组，系统工作组的组 ID 小于 500</td>
</tr>
<tr>
<td>-K</td>
<td>覆盖配置文件 /etc/login.defs</td>
</tr>
<tr>
<td>-o</td>
<td>允许添加组 ID 号不唯一的工作组</td>
</tr>
<tr>
<td>-f,—force</td>
<td>如果指定的组已经存在，此选项将失明了仅以成功状态退出</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试</strong>：创建一个新的组，并添加组ID(1111)。在/etc/group文件中检验添加是否成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd -g 1111 HITwh</span><br><span class="line">grep HITwh /etc/group</span><br></pre></td></tr></table></figure>
<p>结果：添加了ID为1111的用户组HITwh。使用grep可以在/etc/group找到这一行。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705143933085.png" alt="图54 创建新的组" style="zoom:80%;" /></p>
<h5 id="groupdel命令"><a href="#groupdel命令" class="headerlink" title="groupdel命令"></a><code>groupdel</code>命令</h5><p><strong>功能</strong>：用于删除群组。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">groupdel</span><span class="meta"> [群组名称]</span></span><br></pre></td></tr></table></figure>
<p>注意：待删除的群组不必为空。</p>
<p><strong>输入测试</strong>：删除用户组HITwh。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep HITwh /etc/group</span><br><span class="line">groupdel HITwh</span><br><span class="line">grep HITwh /etc/group</span><br></pre></td></tr></table></figure>
<p>结果：成功删除用户组HITwh，使用grep命令无法在/etc/group文件中找到关于HITwh用户组的信息。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705153536868.png" alt="图55 删除用户组" style="zoom:80%;" /></p>
<h3 id="七、网络配置与网络状态分析和检查"><a href="#七、网络配置与网络状态分析和检查" class="headerlink" title="七、网络配置与网络状态分析和检查"></a>七、网络配置与网络状态分析和检查</h3><h4 id="1、网络配置"><a href="#1、网络配置" class="headerlink" title="1、网络配置"></a>1、网络配置</h4><h5 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a><code>ifconfig</code>命令</h5><p><strong>功能</strong>：用于设置网络设备的状态，或是显示目前的设置。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>add&lt;地址&gt;</td>
<td>设置网络设备IPv6的IP地址</td>
</tr>
<tr>
<td>del&lt;地址&gt;</td>
<td>删除网络设备IPv6的IP地址</td>
</tr>
<tr>
<td>down</td>
<td>关闭指定的网络设备</td>
</tr>
<tr>
<td><hw<网络设备类型>&lt;硬件地址&gt;</td>
<td>设置网络设备的类型与硬件地址</td>
</tr>
<tr>
<td>io_addr<I/O地址></td>
<td>设置网络设备的I/O地址</td>
</tr>
<tr>
<td>irq<IRQ地址></td>
<td>设置网络设备的IRQ</td>
</tr>
<tr>
<td>media&lt;网络媒介类型&gt;</td>
<td>设置网络设备的媒介类型</td>
</tr>
<tr>
<td>mem_start&lt;内存地址&gt;</td>
<td>设置网络设备在主内存所占用的起始地址</td>
</tr>
<tr>
<td>metric&lt;数目&gt;</td>
<td>指定在计算数据包的转送次数时，所要加上的数目</td>
</tr>
<tr>
<td>mtu&lt;字节&gt;</td>
<td>设置网络设备的MTU</td>
</tr>
<tr>
<td>netmask&lt;子网掩码&gt;</td>
<td>设置网络设备的子网掩码</td>
</tr>
<tr>
<td>tunnel&lt;地址&gt;</td>
<td>建立IPv4与IPv6之间的隧道通信地址</td>
</tr>
<tr>
<td>up</td>
<td>启动指定的网络设备</td>
</tr>
<tr>
<td>-broadcast&lt;地址&gt;</td>
<td>将要送往指定地址的数据包当成广播数据包来处理</td>
</tr>
<tr>
<td>-pointopoint&lt;地址&gt;</td>
<td>与指定地址的网络设备建立直接连线，此模式具有保密功能</td>
</tr>
<tr>
<td>-promisc</td>
<td>关闭或启动指定网络设备的promiscuous模式</td>
</tr>
<tr>
<td>[IP地址]</td>
<td>指定网络设备的IP地址</td>
</tr>
<tr>
<td>[网络设备]</td>
<td>指定网络设备的名称</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：使用ifconfig命令查看网络配置信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>结果：显示了网络设备设备信息，分别是ens33和lo。显示了两台网络设备的ip和子网掩码。ens33是RedHat系列的网卡名称，其中的en标识ethernet（以太网），s表示热插拔网卡，USB一类的扩展槽索引号。数字是根据MAC地址和主板信息计算得出的唯一序列。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705160212068.png" alt="图56 ifconfig查看" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：关闭和启动指令的网络设备（以太网卡）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens33 down</span><br><span class="line">ifconfig ens33 up</span><br></pre></td></tr></table></figure>
<p>结果：第一条命令使用后，ens33设备被关闭；第二条命令使用后，ens33设备启动。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705160834402.png" alt="图57 关闭和开启网络设备" style="zoom:80%;" /></p>
<h5 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a><code>netstat</code>命令</h5><p><strong>功能</strong>：用于显示网络状态。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a或—all</td>
<td>显示所有连线中的Socket</td>
</tr>
<tr>
<td>-A&lt;网络类型&gt;或—&lt;网络类型&gt;</td>
<td>列出该网络类型连线中的相关地址</td>
</tr>
<tr>
<td>-c或—continuous</td>
<td>持续列出网络状态</td>
</tr>
<tr>
<td>-C或—cache</td>
<td>显示路由器配置的快取信息</td>
</tr>
<tr>
<td>-e或—extend</td>
<td>显示网络其他相关信息</td>
</tr>
<tr>
<td>-F或—fib</td>
<td>显示路由缓存</td>
</tr>
<tr>
<td>-g或—groups</td>
<td>显示多重广播功能群组组员名单</td>
</tr>
<tr>
<td>-i或—interfaces</td>
<td>显示网络界面信息表单</td>
</tr>
<tr>
<td>-l或—listening</td>
<td>显示监控中的服务器的Socket</td>
</tr>
<tr>
<td>-M或—masquerade</td>
<td>显示伪装的网络连线</td>
</tr>
<tr>
<td>-n或—numeric</td>
<td>直接使用IP地址，而不通过域名服务器</td>
</tr>
<tr>
<td>-N或—netlink或—symbolic</td>
<td>显示网络硬件外围设备的符号连接名称</td>
</tr>
<tr>
<td>-o或—timers</td>
<td>显示计时器</td>
</tr>
<tr>
<td>-p或—programs</td>
<td>显示正在使用Socket的程序识别码和程序名称</td>
</tr>
<tr>
<td>-r或—route</td>
<td>显示Routing Table</td>
</tr>
<tr>
<td>-s或—statistics</td>
<td>显示网络工作信息统计表</td>
</tr>
<tr>
<td>-t或—tcp</td>
<td>显示TCP传输协议的连线状况</td>
</tr>
<tr>
<td>-u或—udp</td>
<td>显示UDP传输协议的连线状况</td>
</tr>
<tr>
<td>-v或—verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-V或—version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-w或—raw</td>
<td>显示RAW传输协议的连线状况</td>
</tr>
<tr>
<td>-x或—unix</td>
<td>此参数的效果和指定”-A unix”参数相同</td>
</tr>
<tr>
<td>—ip或—inet</td>
<td>此参数的效果和指定”-A inet”参数相同</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：查看网络监听端口（命令参数：-lnp）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -lnp</span><br></pre></td></tr></table></figure>
<p>结果：输出网络端口的监听结果。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705170634657.png" alt="图58 查看网络监听端口" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：显示详细的TCP传输协议和UDP的连线状况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat --tcp</span><br><span class="line">netstat --udp</span><br></pre></td></tr></table></figure>
<p>结果：只打印表头，没有显示连线状况。分析原因：输入命令不完整，只显示端口，但没有进行套接字监听。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705170251733.png" alt="图59 查看tcp和udp连线状况" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：显示Routing Table（命令参数：-r）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure>
<p>结果：输出两行，包括目标ip、子网掩码、flags、MSS Window、设备信息。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705170046349.png" alt="图60 显示Routing Table" style="zoom:80%;" /></p>
<h4 id="2、网络状态分析"><a href="#2、网络状态分析" class="headerlink" title="2、网络状态分析"></a>2、网络状态分析</h4><h5 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a><code>ping</code>命令</h5><p><strong>功能</strong>：用于检测主机。使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<p><strong>格式</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]</span><br></pre></td></tr></table></figure>
<p><strong>命令参数</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项与参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>使用Socket的SO_DEBUG功能</td>
</tr>
<tr>
<td>-c &lt;完成次数&gt;</td>
<td>设置完成要求回应的次数</td>
</tr>
<tr>
<td>-f</td>
<td>极限检测</td>
</tr>
<tr>
<td>-i&lt;间隔秒数&gt;</td>
<td>指定收发信息的间隔时间</td>
</tr>
<tr>
<td>-I&lt;网络界面&gt;</td>
<td>使用指定的网络接口送出数据包</td>
</tr>
<tr>
<td>-l&lt;前置载入&gt;</td>
<td>设置在送出要求信息之前，先行发出的数据包</td>
</tr>
<tr>
<td>-n</td>
<td>只输出数值</td>
</tr>
<tr>
<td>-p&lt;范本样式&gt;</td>
<td>设置填满数据包的范本样式</td>
</tr>
<tr>
<td>-q</td>
<td>不显示指令执行过程，开头和结尾的相关信息除外</td>
</tr>
<tr>
<td>-r</td>
<td>忽略普通的Routing Table，直接将数据包送到远端主机上</td>
</tr>
<tr>
<td>-R</td>
<td>记录路由过程</td>
</tr>
<tr>
<td>-s&lt;数据包大小&gt;</td>
<td>设置数据包的大小</td>
</tr>
<tr>
<td>-t&lt;存活数值&gt;</td>
<td>设置存活数值TTL的大小</td>
</tr>
<tr>
<td>-v</td>
<td>详细显示指令的执行过程</td>
</tr>
<tr>
<td>-w&lt;最后期限&gt;</td>
<td>在最后期限秒后退出</td>
</tr>
<tr>
<td>-W&lt;一段时间&gt;</td>
<td>在等待一段时间秒后开始执行</td>
</tr>
</tbody>
</table>
</div>
<p><strong>输入测试1</strong>：检测是否能与校园网（www.hitwh.edu.cn）连通。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.hitwh.edu.cn</span><br></pre></td></tr></table></figure>
<p>结果：显示了相应内容，ping命令将域名转换为IP，显示ttl（生存时间），即数据包能在网络上存在多少时间。本地机器会发出一个数据包，数据包经过一定数量的路由器传送到目的主机，但是由于很多的原因，一些数据包不能正常传送到目的主机，那如果不给这些数据包一个生存时间的话，这些数据包会一直在网络上传送，导致网络开销的增大。当数据包传送到一个路由器之后，TTL就自动减1，如果减到0了还是没有传送到目的主机，那么就自动丢失。显示了响应时间time，数值小表示连通速度快。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705163605416.png" alt="图61 ping测试" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：测试是否与baidu.com连通，指定接收包的次数为5。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 5 baidu.com</span><br></pre></td></tr></table></figure>
<p>结果：5次后结束发送数据包。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705164021373.png" alt="图62 ping5次测试" style="zoom:80%;" /></p>
<h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><h4 id="1、创建一个shell脚本程序：输入圆半径值，输出圆面积的值"><a href="#1、创建一个shell脚本程序：输入圆半径值，输出圆面积的值" class="headerlink" title="1、创建一个shell脚本程序：输入圆半径值，输出圆面积的值"></a>1、创建一个shell脚本程序：输入圆半径值，输出圆面积的值</h4><p>程序源代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Program:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">User input a <span class="built_in">float</span> number as radius of a circle.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Program outputs the area of this circle.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">History:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2022/07/05	2200400109 gingkocyx	1st_release</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义圆周率PI</span></span><br><span class="line">PI=3.1415926535</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入圆的半径值</span></span><br><span class="line">echo &quot;input radius of a circle:&quot;</span><br><span class="line">read r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出圆的面积值</span></span><br><span class="line">echo &quot;The area of circle is:&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用系统自带的awk计算器完成浮点数的计算</span></span><br><span class="line">echo &quot;$r $r $PI&quot; | awk &#x27;&#123;print($1*$2*$3)&#125;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705194207762.png" alt="图1 程序1源代码文件截图" style="zoom:80%;" /></p>
<p>遇到的主要问题是浮点数计算。如果用乘号只能完成整数运算。由于软件包的冲突问题，未能成功安装bc计算器。最终使用Linux系统自带的awk计算器完成计算。</p>
<p><strong>运行结果分析</strong>：</p>
<p><strong>输入测试1</strong>：输入半径：r=1，输出：area=3.14159，符合预期。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705202439216.png" alt="图2 输入测试1" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：输入半径：r=2，输出：area=12.5664，符合预期。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705202506838.png" alt="图3 输入测试2" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：输入半径：r=11.1，输出：area=387.076，符合预期。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705202543774.png" alt="图4 输入测试3" style="zoom:80%;" /></p>
<p>以下为运行截图：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705194512120.png" alt="图5 运行截图" style="zoom:80%;" /></p>
<h3 id="2、编程求解n个数的和，要求n由键盘输入，使用循环语句完成"><a href="#2、编程求解n个数的和，要求n由键盘输入，使用循环语句完成" class="headerlink" title="2、编程求解n个数的和，要求n由键盘输入，使用循环语句完成"></a>2、编程求解n个数的和，要求n由键盘输入，使用循环语句完成</h3><p>程序源代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Program:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user input n, <span class="keyword">then</span> input n numbers.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">calculate <span class="built_in">sum</span> of n numbers.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">then</span> output <span class="built_in">sum</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收用户输入n</span></span><br><span class="line">read -p &quot;input n:&quot; n</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">循环变量i</span></span><br><span class="line">i=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sum</span>存放结果</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">循环语句</span></span><br><span class="line"><span class="meta prompt_">while(($</span><span class="language-bash">i &lt;= n))</span></span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">输入数字</span></span><br><span class="line">	read -p &quot;No.$i num:&quot; num</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">求和</span></span><br><span class="line">	sum=`expr $sum + $num`</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">循环变量自增</span></span><br><span class="line">	let &quot;i++&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出结果</span></span><br><span class="line">echo &quot;sum is :&quot;</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201728741.png" alt="图6 程序2源代码截图" style="zoom:80%;" /></p>
<p>使用while循环语句完成数字的输入和求和运算。</p>
<p><strong>运行结果分析</strong>：</p>
<p><strong>输入测试1</strong>：n=5，数字分别为：1, -1, 20, 30, 8。输出结果为：58。符合预期。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201323025.png" alt="图7 输入测试1" style="zoom:80%;" /></p>
<p><strong>输入测试2</strong>：n=10，数字分别为：1, 2, 3, 4, 5, 6, 7, 8, 9, 10。输出结果为：55。符合预期。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201448884.png" alt="图8 输入测试2" style="zoom:80%;" /></p>
<p><strong>输入测试3</strong>：n=4，数字分别为：1234567890, 9876543210, 999999999999, 1。输出结果为：1011111111100。符合预期。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220705201635239.png" alt="图9 输入测试3" style="zoom:80%;" /></p>
<h3 id="三、利用for循环将当前目录下的指定扩展名（由输入决定）文件转移到指定的目录下，并按照文件大小排序，并显示移动后指定目录的内容"><a href="#三、利用for循环将当前目录下的指定扩展名（由输入决定）文件转移到指定的目录下，并按照文件大小排序，并显示移动后指定目录的内容" class="headerlink" title="三、利用for循环将当前目录下的指定扩展名（由输入决定）文件转移到指定的目录下，并按照文件大小排序，并显示移动后指定目录的内容"></a>三、利用for循环将当前目录下的指定扩展名（由输入决定）文件转移到指定的目录下，并按照文件大小排序，并显示移动后指定目录的内容</h3><p><strong>程序源代码</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Program</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user input filetype and destionation(a directory)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">program <span class="keyword">then</span> move all files satisfy filetype into destionation</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取扩展名和转移的目标目录</span></span><br><span class="line">read -p &quot;input filetype:&quot; filetype</span><br><span class="line">read -p &quot;input destionation:&quot; desdir</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用<span class="keyword">for</span>循环移动文件</span></span><br><span class="line">for file in `find . -name &quot;*.filetype&quot;`</span><br><span class="line">do</span><br><span class="line">	mv $file $desdir</span><br><span class="line">done</span><br><span class="line">ls -Sl $desdir</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706001112093.png" alt="图10 程序3源代码截图" style="zoom:80%;" /></p>
<p><strong>程序运行结果</strong>：</p>
<p>在/home/c2200400109/test目录下有三个文本文件：a.txt, b.txt, c.txt。</p>
<p>执行task003.sh脚本后，提示输入文件后缀与待转移的目录。</p>
<p>输入文件类型为”.txt”，目标目录为同目录下的test子目录。</p>
<p>完成移动文件命令后，按照文件从大到小顺序排序并显示。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706000447630.png" alt="图11 测试运行结果" style="zoom:80%;" /></p>
<p><strong>遇到的主要问题及解决</strong>：</p>
<p>处理文件名后缀，采用输入后缀名，使用find命令对符合后缀要求的文件进行查找。找到相应文件后执行mv命令对文件进行移动操作。在实验过程中，由于忘记添加美元符号$导致不能使用变量的值，消耗了大量时间进行改错。</p>
<p>一开始还考虑了直接获取命令行参数的方式。这样输入命令时只需要添加类似”./*.txt”的参数即可获得后缀。但是经过测试验证，发现这种参数会把当前目录下所有符合后缀要求的每个文件都作为一个参数进行输入。即：1,2,…,n-1的参数都是文件参数，只有最后一个参数是移动的目标目录。这种方式带来的问题是处理输入参数个数以及区分、处理的过程比较麻烦，故最后放弃这种方案，采用bash内提示用户输入信息的方式处理。</p>
<h1 id="2022Linux大作业"><a href="#2022Linux大作业" class="headerlink" title="2022Linux大作业"></a>2022Linux大作业</h1><h2 id="1-分析ext4文件系统原理"><a href="#1-分析ext4文件系统原理" class="headerlink" title="1. 分析ext4文件系统原理"></a>1. 分析ext4文件系统原理</h2><h3 id="1-1-虚拟文件系统"><a href="#1-1-虚拟文件系统" class="headerlink" title="1.1 虚拟文件系统"></a>1.1 虚拟文件系统</h3><p>虚拟文件系统（<code>VFS</code>）是Linux内核的子系统，为用户空间程序提供了文件和文件系统相关的接口。系统中所有文件系统不但依赖VFS共存，而且也依靠VFS系统协同工作。通过虚拟文件系统，程序可以利用标准的Unix系统调用对不同的文件系统，甚至不同介质上的文件系统进行读写操作，如图1所示。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706084756910.png" alt="图1 VFS执行的动作" style="zoom:80%;" /></p>
<p>VFS执行的动作有：使用cp(1)命令从ext3文件系统格式的硬盘拷贝数据到ext2文件系统格式的可移动磁盘上。这样就把两种不同的文件系统，两种不同的介质，连接到同一个VFS上。这样的执行动作对ext4文件系统也同样适用。</p>
<p>VFS使得用户可以直接使用<code>open()</code>、<code>read()</code>和<code>write()</code>这样的系统调用而无须考虑具体文件系统和实际物理介质。这使得这些通用的系统调用可以跨越各种文件系统和不同介质执行。系统调用可以在这些不同的文件系统和介质之间执行——可使用标准的系统调用从一个文件系统拷贝或移动数据到另一个文件系统。与此相对比，DOS等老式的操作系统若想完成任何对非本地文件系统的访问都必须依靠特殊工具。Linux操作系统引入抽象层，通过虚拟接口访问文件系统，使得协作性和泛型存取成为可能。</p>
<p>新的文件系统和新类型的存储介质都能找到进入Linux之路，程序无需重写，甚至无须重新编译。在本章中，我们将讨论VFS，它把各种不同的文件系统抽象后采用统一的方式进行操作。VFS与块I/O相结合，提供抽象、接口以及交融，使得用户空间的程序调用统一的系统调用访问各种文件，不管文件系统是什么，也不管文件系统位于何种介质，采用的命名策略是统一的。</p>
<p>之所以可以使用这种通用接口对所有类型的文件系统进行操作，是因为内核在它的底层文件系统接口上建立了一个抽象层。该抽象层使Linux能够支持各种文件系统，即便是它们在功能和行为上存在很大差别。为了支持多文件系统，VFS提供了一个通用文件系统模型，该模型囊括了任何文件系统的常用功能集和行为。当然，该模型偏重于Unix风格的文件系统。但Linux仍然可以支持很多种差异很大的文件系统，从DOS系统的FAT到Windows系统的NTFS，再到各种Unix风格文件系统和Linux特有的文件系统。</p>
<p>VFS抽象层之所以能衔接各种各样的文件系统，是因为它定义了所有文件系统都支持的、基本的、概念上的接口和数据结构。同时实际文件系统也将自身的诸如“如何打开文件”，“目录是什么”等概念在形式上与VFS的定义保持一致。因为实际文件系统的代码在统一的接口和数据结构下隐藏了具体的实现细节，所以在VFS层和内核的其他部分看来，所有文件系统都是相同的，它们都支持像文件和目录这样的概念，同时也支持像创建文件和删除文件这样的操作。</p>
<p>内核通过抽象层能够方便、简单地支持各种类型的文件系统。实际文件系统通过编程提供VFS所期望的抽象接口和数据结构，这样，内核就可以毫不费力地和任何文件系统协同工作，并且这样提供给用户空间的接口，也可以和任何文件系统无缝地连接在一起，完成实际工作。其实在内核中，除了文件系统本身外，其他部分并不需要了解文件系统的内部细节。</p>
<p>VFS其实采用的是面向对象的设计思路，使用一组数据结构来代表通用文件对象。这些数据结构类似于对象。因为内核纯粹使用C代码实现，没有直接利用面向对象的语言，所以内核中的数据结构都使用C语言的结构体实现，而这些结构体包含数据的同时也包含操作这些数据的函数指针，其中的操作函数由具体文件系统实现。</p>
<p>VFS中有四个主要的对象类型，分别是：</p>
<ul>
<li>超级块对象，代表一个具体的已安装文件系统。</li>
<li>索引节点对象，代表一个具体文件。</li>
<li>目录项对象，代表一个目录项，是路径的一个组成部分。</li>
<li>文件对象，代表由进程打开的文件。</li>
</ul>
<p>因为VFS将目录作为一个文件来处理，所以不存在目录对象。每个主要对象中都包含一个操作对象，这些操作对象描述了内核针对主要对象可以使用的方法：</p>
<ul>
<li><code>super_operations</code>对象，其中包括内核针对特定文件系统所能调用的方法，比如 <code>write_inode()</code>和<code>sync_fs()</code>等方法。</li>
<li><code>inode_operations</code>对象，其中包括内核针对特定文件所能调用的方法，比如<code>create()</code>和<code>link</code>等方法。</li>
<li><code>dentry_operations</code>对象，其中包括内核针对特定目录所能调用的方法，比如<code>d_compare()</code>和<code>d_delete()</code>等方法。</li>
<li><code>file_operations</code>对象，其中包括进程针对已打开文件所能调用的方法，比如<code>read()</code>和 <code>write()</code>等方法。</li>
</ul>
<p>操作对象作为一个结构体指针来实现，此结构体中包含指向操作其父对象的函数指针。对于其中许多方法来说，可以继承使用VFS提供的通用函数，如果通用函数提供的基本功能无法满足需要，那么就必须使用实际文件系统的独有方法填充这些函数指针，使其指向文件系统实例。</p>
<h3 id="1-2-ext4文件系统布局"><a href="#1-2-ext4文件系统布局" class="headerlink" title="1.2 ext4文件系统布局"></a>1.2 ext4文件系统布局</h3><p>ext4 以“块”为单位分配存储空间。区块是介于 1KiB 和 64KiB 之间的一组扇区，扇区数必须是 2 的整数幂。块又被分组为更大的单元，称为块组。块大小在 mkfs 时间指定，通常为 4KiB。如果块大小大于页面大小（即 i386 上只有 4KiB 内存页的 64KiB 块），您可能会遇到挂载问题。默认情况下，一个文件系统可以包含2^ 32个块;如果启用了“64位”功能，则文件系统可以有2 ^ 64个块。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">32-bit mode</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Item</td>
<td style="text-align:center">1KiB</td>
<td style="text-align:center">2KiB</td>
<td style="text-align:center">4KiB</td>
<td style="text-align:center">64KiB</td>
</tr>
<tr>
<td style="text-align:center">Blocks</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
</tr>
<tr>
<td style="text-align:center">Inodes</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
</tr>
<tr>
<td style="text-align:center">File System Size</td>
<td style="text-align:center">4TiB</td>
<td style="text-align:center">8TiB</td>
<td style="text-align:center">16TiB</td>
<td style="text-align:center">256PiB</td>
</tr>
<tr>
<td style="text-align:center">Blocks Per Block Group</td>
<td style="text-align:center">8,192</td>
<td style="text-align:center">16,384</td>
<td style="text-align:center">32,768</td>
<td style="text-align:center">524,288</td>
</tr>
<tr>
<td style="text-align:center">Inodes Per Block Group</td>
<td style="text-align:center">8,192</td>
<td style="text-align:center">16,384</td>
<td style="text-align:center">32,768</td>
<td style="text-align:center">524,288</td>
</tr>
<tr>
<td style="text-align:center">Block Group Size</td>
<td style="text-align:center">8MiB</td>
<td style="text-align:center">32MiB</td>
<td style="text-align:center">128MiB</td>
<td style="text-align:center">32GiB</td>
</tr>
<tr>
<td style="text-align:center">Blocks Per File, Extents</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
</tr>
<tr>
<td style="text-align:center">Blocks Per File, Block Maps</td>
<td style="text-align:center">16,843,020</td>
<td style="text-align:center">134,480,396</td>
<td style="text-align:center">1,074,791,436</td>
<td style="text-align:center">4,398,314,962,956 (really 2^32 due to field size limitations)</td>
</tr>
<tr>
<td style="text-align:center">File Size, Extents</td>
<td style="text-align:center">4TiB</td>
<td style="text-align:center">8TiB</td>
<td style="text-align:center">16TiB</td>
<td style="text-align:center">256TiB</td>
</tr>
<tr>
<td style="text-align:center">File Size, Block Maps</td>
<td style="text-align:center">16GiB</td>
<td style="text-align:center">256GiB</td>
<td style="text-align:center">4TiB</td>
<td style="text-align:center">256TiB</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>64-bit mode</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Item</td>
<td>1KiB</td>
<td style="text-align:center">2KiB</td>
<td style="text-align:center">4KiB</td>
<td style="text-align:center">64KiB</td>
</tr>
<tr>
<td style="text-align:center">Blocks</td>
<td>2^64</td>
<td style="text-align:center">2^64</td>
<td style="text-align:center">2^64</td>
<td style="text-align:center">2^64</td>
</tr>
<tr>
<td style="text-align:center">Inodes</td>
<td>2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
</tr>
<tr>
<td style="text-align:center">File System Size</td>
<td>16ZiB</td>
<td style="text-align:center">32ZiB</td>
<td style="text-align:center">64ZiB</td>
<td style="text-align:center">1YiB</td>
</tr>
<tr>
<td style="text-align:center">Blocks Per Block Group</td>
<td>8,192</td>
<td style="text-align:center">16,384</td>
<td style="text-align:center">32,768</td>
<td style="text-align:center">524,288</td>
</tr>
<tr>
<td style="text-align:center">Inodes Per Block Group</td>
<td>8,192</td>
<td style="text-align:center">16,384</td>
<td style="text-align:center">32,768</td>
<td style="text-align:center">524,288</td>
</tr>
<tr>
<td style="text-align:center">Block Group Size</td>
<td>8MiB</td>
<td style="text-align:center">32MiB</td>
<td style="text-align:center">128MiB</td>
<td style="text-align:center">32GiB</td>
</tr>
<tr>
<td style="text-align:center">Blocks Per File, Extents</td>
<td>2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
<td style="text-align:center">2^32</td>
</tr>
<tr>
<td style="text-align:center">Blocks Per File, Block Maps</td>
<td>16,843,020</td>
<td style="text-align:center">134,480,396</td>
<td style="text-align:center">1,074,791,436</td>
<td style="text-align:center">4,398,314,962,956 (really 2^32 due to field size limitations)</td>
</tr>
<tr>
<td style="text-align:center">File Size, Extents</td>
<td>4TiB</td>
<td style="text-align:center">8TiB</td>
<td style="text-align:center">16TiB</td>
<td style="text-align:center">256TiB</td>
</tr>
<tr>
<td style="text-align:center">File Size, Block Maps</td>
<td>16GiB</td>
<td style="text-align:center">256GiB</td>
<td style="text-align:center">4TiB</td>
<td style="text-align:center">256TiB</td>
</tr>
</tbody>
</table>
</div>
<p>ext4文件系统被分成一系列块组。块分配器尽量保持每个文件的数据块都在同一个块组中，以减少磁盘碎片产生的性能瓶颈，从而减少寻道时间。每个块组一般包括超级块、块组描述符表、预留块组描述符表、数据位图、<code>inode</code>位图、<code>inode</code>表、数据块。ext4文件系统主要使用<code>块组0</code>中的<code>超级块</code>和<code>块组描述符表</code>，在特定的块组（如0, 3, 5, 7）才有超级块和块组描述符表的冗余备份。普通块组中不含冗余备份，那么块组就以数据块位图开始。以4KB的数据块为例，一个块组可以包含32768个数据块（128MB）。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/2cf7aad4d84b464ea90328e011b6f4f4.png" alt="图2 ext4文件系统布局" style="zoom:80%;" /></p>
<h4 id="1-2-1-超级块"><a href="#1-2-1-超级块" class="headerlink" title="1.2.1 超级块"></a>1.2.1 超级块</h4><p><strong>超级块（super block）</strong>：每个块组的起始位置都有一个超级块，这些超级块的内容都是相同的，记录文件系统的整体信息。超级块包括文件系统的信息，比如inode/block的大小、总量、使用量、剩余量，以及文件系统的格式，文件系统挂载时间，最近一次数据写入时间，最近一次校验磁盘的时间等。</p>
<p>通常情况下，只有主拷贝(第0块块组)的超级块信息被文件系统使用，其它拷贝只有在主拷贝被破坏的情况下才使用。</p>
<p>其结构体是<code>struct ext4_super_block</code>，位于<code>fs/ext4/ext4.h</code>文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_super_block</span> &#123;</span></span><br><span class="line"><span class="comment">/*00*/</span>	__le32	s_inodes_count;	<span class="comment">//inode数量</span></span><br><span class="line">	__le32	s_blocks_count_lo;<span class="comment">//块数量</span></span><br><span class="line">	__le32	s_r_blocks_count_lo;<span class="comment">//保留块的数量</span></span><br><span class="line">	__le32	s_free_blocks_count_lo;<span class="comment">//空闲块的数量</span></span><br><span class="line"><span class="comment">/*10*/</span>	__le32	s_free_inodes_count;<span class="comment">//空闲inode的数量</span></span><br><span class="line">	__le32	s_first_data_block;<span class="comment">//第一块数据块</span></span><br><span class="line">	__le32	s_log_block_size;<span class="comment">//块大小</span></span><br><span class="line">	__le32	s_log_cluster_size;	<span class="comment">/* Allocation cluster size */</span></span><br><span class="line"><span class="comment">/*20*/</span>	__le32	s_blocks_per_group;<span class="comment">//每个块组的块数量</span></span><br><span class="line">	__le32	s_clusters_per_group;	<span class="comment">/* # Clusters per group */</span></span><br><span class="line">	__le32	s_inodes_per_group;<span class="comment">//每个块组的索引数量</span></span><br><span class="line">	__le32	s_mtime;<span class="comment">//挂载时间</span></span><br><span class="line"><span class="comment">/*30*/</span>	__le32	s_wtime;<span class="comment">//最后一次写入时间</span></span><br><span class="line">	__le16	s_mnt_count;<span class="comment">//挂载次数</span></span><br><span class="line">	__le16	s_max_mnt_count;<span class="comment">//允许最大挂载数量</span></span><br><span class="line">	__le16	s_magic;<span class="comment">//魔数</span></span><br><span class="line">	__le16	s_state;<span class="comment">//文件系统状态</span></span><br><span class="line">	__le16	s_errors;		<span class="comment">/* 检测到错误时的动作 */</span></span><br><span class="line">	__le16	s_minor_rev_level;<span class="comment">//最小版本</span></span><br><span class="line"><span class="comment">/*40*/</span>	__le32	s_lastcheck;<span class="comment">//最近检查时间</span></span><br><span class="line">	__le32	s_checkinterval;<span class="comment">//最长检查时间，超过就回调检查</span></span><br><span class="line">	__le32	s_creator_os;		<span class="comment">/* 要创建文件系统的os */</span></span><br><span class="line">	__le32	s_rev_level;<span class="comment">//修订版本</span></span><br><span class="line"><span class="comment">/*50*/</span>	__le16	s_def_resuid;<span class="comment">//默认预留块的用户id</span></span><br><span class="line">	__le16	s_def_resgid;<span class="comment">//默认预留块的用户组id</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These fields are for EXT4_DYNAMIC_REV superblocks only.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note: the difference between the compatible feature set and</span></span><br><span class="line"><span class="comment">	 * the incompatible feature set is that if there is a bit set</span></span><br><span class="line"><span class="comment">	 * in the incompatible feature set that the kernel doesn&#x27;t</span></span><br><span class="line"><span class="comment">	 * know about, it should refuse to mount the filesystem.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * e2fsck&#x27;s requirements are more strict; if it doesn&#x27;t know</span></span><br><span class="line"><span class="comment">	 * about a feature in either the compatible or incompatible</span></span><br><span class="line"><span class="comment">	 * feature set, it must abort and not try to meddle with</span></span><br><span class="line"><span class="comment">	 * things it doesn&#x27;t understand...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__le32	s_first_ino;		<span class="comment">/* 第一个非保留的inode号码 */</span></span><br><span class="line">	__le16  s_inode_size;		<span class="comment">/* inode结构大小 */</span></span><br><span class="line">	__le16	s_block_group_nr;	<span class="comment">/* 该超级块所在的块组号 */</span></span><br><span class="line">	__le32	s_feature_compat;	<span class="comment">/* 兼容特性集 */</span></span><br><span class="line"><span class="comment">/*60*/</span>	__le32	s_feature_incompat;	<span class="comment">/* 非兼容特性集 */</span></span><br><span class="line">	__le32	s_feature_ro_compat;	<span class="comment">/* 只读兼容特性集 */</span></span><br><span class="line"><span class="comment">/*68*/</span>	__u8	s_uuid[<span class="number">16</span>];		<span class="comment">/* 128的卷uuid */</span></span><br><span class="line"><span class="comment">/*78*/</span>	<span class="type">char</span>	s_volume_name[<span class="number">16</span>];	<span class="comment">/* 卷名字 */</span></span><br><span class="line"><span class="comment">/*88*/</span>	<span class="type">char</span>	s_last_mounted[<span class="number">64</span>] __nonstring;	<span class="comment">/* 最近一次的挂载目录 */</span></span><br><span class="line"><span class="comment">/*C8*/</span>	__le32	s_algorithm_usage_bitmap; <span class="comment">/* 用于压缩 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Performance hints.  Directory preallocation should only</span></span><br><span class="line"><span class="comment">	 * happen if the EXT4_FEATURE_COMPAT_DIR_PREALLOC flag is on.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__u8	s_prealloc_blocks;	<span class="comment">/* 预分配的块数 */</span></span><br><span class="line">	__u8	s_prealloc_dir_blocks;	<span class="comment">/* 为目录预分配的块数 */</span></span><br><span class="line">	__le16	s_reserved_gdt_blocks;	<span class="comment">/* 因为数据增长为块组描述符保留的块数 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Journaling support valid if EXT4_FEATURE_COMPAT_HAS_JOURNAL set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="comment">/*D0*/</span>	__u8	s_journal_uuid[<span class="number">16</span>];	<span class="comment">/* 日志超级快的uuid */</span></span><br><span class="line"><span class="comment">/*E0*/</span>	__le32	s_journal_inum;		<span class="comment">/* 日志文件的索引号 */</span></span><br><span class="line">	__le32	s_journal_dev;		<span class="comment">/* 日志文件的设备号 */</span></span><br><span class="line">	__le32	s_last_orphan;		<span class="comment">/* 待删除的inode链表起始位置 */</span></span><br><span class="line">	__le32	s_hash_seed[<span class="number">4</span>];		<span class="comment">/* HTREE散列表种子 */</span></span><br><span class="line">	__u8	s_def_hash_version;	<span class="comment">/* 默认使用的哈希版本 */</span></span><br><span class="line">	__u8	s_jnl_backup_type;</span><br><span class="line">	__le16  s_desc_size;		<span class="comment">/* 块组描述符大小 */</span></span><br><span class="line"><span class="comment">/*100*/</span>	__le32	s_default_mount_opts;</span><br><span class="line">	__le32	s_first_meta_bg;	<span class="comment">/* 第一个块组 */</span></span><br><span class="line">	__le32	s_mkfs_time;		<span class="comment">/* 文件系统创建时间 */</span></span><br><span class="line">	__le32	s_jnl_blocks[<span class="number">17</span>];	<span class="comment">/* 日志inode的备份 */</span></span><br><span class="line">	<span class="comment">/* 64bit support valid if EXT4_FEATURE_COMPAT_64BIT */</span></span><br><span class="line"><span class="comment">/*150*/</span>	__le32	s_blocks_count_hi;	<span class="comment">/* 块数量高位 */</span></span><br><span class="line">	__le32	s_r_blocks_count_hi;	<span class="comment">/* 保留块的数量高位 */</span></span><br><span class="line">	__le32	s_free_blocks_count_hi;	<span class="comment">/* 空闲块的数量高位 */</span></span><br><span class="line">	__le16	s_min_extra_isize;	<span class="comment">/* inode最小大小，单位字节 */</span></span><br><span class="line">	__le16	s_want_extra_isize; 	<span class="comment">/* 新的inode需要保留大小，单位字节 */</span></span><br><span class="line">	__le32	s_flags;		<span class="comment">/* 各种标志位 */</span></span><br><span class="line">	__le16  s_raid_stride;		<span class="comment">/* RAID stride */</span></span><br><span class="line">	__le16  s_mmp_update_interval;  <span class="comment">/* 多挂载检查等待时间，单位秒 */</span></span><br><span class="line">	__le64  s_mmp_block;            <span class="comment">/* 多挂载保护块 */</span></span><br><span class="line">	__le32  s_raid_stripe_width;    <span class="comment">/* blocks on all data disks (N*stride)*/</span></span><br><span class="line">	__u8	s_log_groups_per_flex;  <span class="comment">/* Flexible 块组大小 */</span></span><br><span class="line">	__u8	s_checksum_type;	<span class="comment">/* 元数据校验算法类型 */</span></span><br><span class="line">	__u8	s_encryption_level;	<span class="comment">/* 加密的版本级别 */</span></span><br><span class="line">	__u8	s_reserved_pad;		<span class="comment">/* Padding to next 32bits */</span></span><br><span class="line">	__le64	s_kbytes_written;	<span class="comment">/* 写生命周期，单位千字节 */</span></span><br><span class="line">	__le32	s_snapshot_inum;	<span class="comment">/* 活动快照的Inode数 */</span></span><br><span class="line">	__le32	s_snapshot_id;		<span class="comment">/* 活动快照ID */</span></span><br><span class="line">	__le64	s_snapshot_r_blocks_count; <span class="comment">/* 供活动快照将来使用的保留块数量   */</span></span><br><span class="line">	__le32	s_snapshot_list;	<span class="comment">/* 磁盘上快照列表头的Inode号   */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_S_ERR_START offsetof(struct ext4_super_block, s_error_count)</span></span><br><span class="line">	__le32	s_error_count;		<span class="comment">/* fs错误个数 */</span></span><br><span class="line">	__le32	s_first_error_time;	<span class="comment">/* fs第一个错误发生时间 */</span></span><br><span class="line">	__le32	s_first_error_ino;	<span class="comment">/* 第一个错误涉及的Inode */</span></span><br><span class="line">	__le64	s_first_error_block;	<span class="comment">/* 第一个错误涉及的块 */</span></span><br><span class="line">	__u8	s_first_error_func[<span class="number">32</span>] __nonstring;	<span class="comment">/* 第一个错误发生的函数 */</span></span><br><span class="line">	__le32	s_first_error_line;	<span class="comment">/* 发生第一个错误的行号 */</span></span><br><span class="line">	__le32	s_last_error_time;	<span class="comment">/* 最近一次错误的时间 */</span></span><br><span class="line">	__le32	s_last_error_ino;	<span class="comment">/* 最近一次错误中涉及的inode */</span></span><br><span class="line">	__le32	s_last_error_line;	<span class="comment">/* 最近一次发生错误的行号 */</span></span><br><span class="line">	__le64	s_last_error_block;	<span class="comment">/* 最近一次错误涉及的块 */</span></span><br><span class="line">	__u8	s_last_error_func[<span class="number">32</span>] __nonstring;	<span class="comment">/*  最近一次错误发生的函数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_S_ERR_END offsetof(struct ext4_super_block, s_mount_opts)</span></span><br><span class="line">	__u8	s_mount_opts[<span class="number">64</span>];</span><br><span class="line">	__le32	s_usr_quota_inum;	<span class="comment">/* 用于跟踪用户配额的inode */</span></span><br><span class="line">	__le32	s_grp_quota_inum;	<span class="comment">/* 用于跟踪组配额的inode */</span></span><br><span class="line">	__le32	s_overhead_clusters;	<span class="comment">/* 文件系统的开销块/集群 */</span></span><br><span class="line">	__le32	s_backup_bgs[<span class="number">2</span>];	<span class="comment">/* groups with sparse_super2 SBs */</span></span><br><span class="line">	__u8	s_encrypt_algos[<span class="number">4</span>];	<span class="comment">/* 使用加密算法种类  */</span></span><br><span class="line">	__u8	s_encrypt_pw_salt[<span class="number">16</span>];	<span class="comment">/* 用于string2key算法的Salt  */</span></span><br><span class="line">	__le32	s_lpf_ino;		<span class="comment">/* 索引节点的位置 */</span></span><br><span class="line">	__le32	s_prj_quota_inum;	<span class="comment">/* 用于跟踪项目配额的inode */</span></span><br><span class="line">	__le32	s_checksum_seed;	<span class="comment">/* crc32c(uuid) if csum_seed set */</span></span><br><span class="line">	__u8	s_wtime_hi;	<span class="comment">//写入时间</span></span><br><span class="line">	__u8	s_mtime_hi;	<span class="comment">//修改时间</span></span><br><span class="line">	__u8	s_mkfs_time_hi;<span class="comment">//简历文件系统时间</span></span><br><span class="line">	__u8	s_lastcheck_hi;<span class="comment">//最近一次检查</span></span><br><span class="line">	__u8	s_first_error_time_hi;<span class="comment">//第一次错误发生时间</span></span><br><span class="line">	__u8	s_last_error_time_hi;<span class="comment">//最近一次错误发生时间</span></span><br><span class="line">	__u8	s_pad[<span class="number">2</span>];</span><br><span class="line">	__le32	s_reserved[<span class="number">96</span>];		<span class="comment">/* Padding to the end of the block */</span></span><br><span class="line">	__le32	s_checksum;		<span class="comment">/* crc32c(superblock) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于超级块的操作。超级块对象中最重要的一个域是<code>s_op</code>，它指向超级块的操作函数表。</p>
<p>超级块操作函数表由<code>super_operations</code>结构体表示，定义在文件<code>&lt;linux/fs.h&gt;</code>中，其形式如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * ( *<span class="title">alloc_inode</span> ) (<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span></span><br><span class="line">    <span class="type">void</span> ( *destroy_inode ) (<span class="keyword">struct</span> inode * );</span><br><span class="line">    <span class="type">void</span> (*dirty_inode) (<span class="keyword">struct</span> inode * ) ;</span><br><span class="line">    <span class="type">int</span> (*write_inode) (<span class="keyword">struct</span> inode * , <span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span> (*drop_inode) (<span class="keyword">struct</span> inode * ) ;</span><br><span class="line">    <span class="type">void</span> (*delete_inode) (<span class="keyword">struct</span> inode * ) ;</span><br><span class="line">    <span class="type">void</span> (*put_super) (<span class="keyword">struct</span> super_block * );</span><br><span class="line">    <span class="type">void</span> ( *write_super) ( <span class="keyword">struct</span> super_block * );</span><br><span class="line">    <span class="type">int</span> (sync_fs ) (<span class="keyword">struct</span> super_block *sb,<span class="type">int</span> wait);</span><br><span class="line">    <span class="type">int</span> (*freeze_fs) ( <span class="keyword">struct</span> super_block * );</span><br><span class="line">    <span class="type">int</span> (unfreeze_fs) (<span class="keyword">struct</span> super_block *);</span><br><span class="line">    <span class="type">int</span> (statfs) (<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstatfs *);</span><br><span class="line">    <span class="type">int</span> (*remount_fs) (<span class="keyword">struct</span> super_block *, <span class="type">int</span> * , <span class="type">char</span> *);</span><br><span class="line">    <span class="type">void</span> (*clear_inode) (<span class="keyword">struct</span> inode *) ;</span><br><span class="line">    <span class="type">void</span> (*umount_begin) (<span class="keyword">struct</span> super_.block *);</span><br><span class="line">    <span class="type">int</span> (show_options ) (<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> vfsmount *);</span><br><span class="line">    <span class="type">int</span> (show_stats ) (<span class="keyword">struct</span> seq_file *, <span class="keyword">struct</span> vfsmount *) ;</span><br><span class="line">    <span class="type">ssize_t</span> ( *quota_read)(<span class="keyword">struct</span> super_block *, <span class="type">int</span>,<span class="type">char</span> *, <span class="type">size_t</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*quota_write)(<span class="keyword">struct</span> super_block *,<span class="type">int</span>，<span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>,<span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">int</span> (*bdev_try_to_free _page)(<span class="keyword">struct</span> super_block*,<span class="keyword">struct</span> page*,<span class="type">gfp_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体中的每一项都是一个指向超级块操作函数的指针，超级块操作函数执行文件系统和索引节点的低层操作。</p>
<h4 id="1-2-2-块组描述符表"><a href="#1-2-2-块组描述符表" class="headerlink" title="1.2.2 块组描述符表"></a>1.2.2 块组描述符表</h4><p><strong>块组描述符表（GDT）</strong>：块组描述符表由很多的块组描述符组成。ext4的每个块组描述符为128M。整个文件系统分区有多少个块组，就有多少个块组描述符。块组描述符描述了一个块组的信息，比如一个块组中inode位图的起始位置、inode表的起始位置等。块组描述符表用于记录块组的基本信息，block bitmap所在的块号， inode bitmap所在的块号，空闲的块数目，空闲Inode数目，目录项个数等。dumpe2fs [磁盘路径]可以显示ext2、ext3、ext4文件系统的超级块和块组信息。</p>
<p>由于GDT对于定位文件系统的元数据非常重要，因此和超级块一样，也对其进行了备份。</p>
<p>其结构体是<code>struct ext4_group_desc</code>，位于<code>fs/ext4/ext4.h</code>文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_group_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__le32	bg_block_bitmap_lo;	<span class="comment">/* 数据块位图 */</span></span><br><span class="line">	__le32	bg_inode_bitmap_lo;	<span class="comment">/* Inodes位图 */</span></span><br><span class="line">	__le32	bg_inode_table_lo;	<span class="comment">/* 块组中第一个Inodes表的数据块号 */</span></span><br><span class="line">	__le16	bg_free_blocks_count_lo;<span class="comment">/* 空闲数据块数量 */</span></span><br><span class="line">	__le16	bg_free_inodes_count_lo;<span class="comment">/* 空闲数据块数量 */</span></span><br><span class="line">	__le16	bg_used_dirs_count_lo;	<span class="comment">/* D块组中目录个数 */</span></span><br><span class="line">	__le16	bg_flags;		<span class="comment">/* EXT4_BG_flags (INODE_UNINIT, etc) */</span></span><br><span class="line">	__le32  bg_exclude_bitmap_lo;   <span class="comment">/* 排除快照的位图 */</span></span><br><span class="line">	__le16  bg_block_bitmap_csum_lo;<span class="comment">/* crc32c(s_uuid+grp_num+bbitmap) LE 数据块位图校验 */</span></span><br><span class="line">	__le16  bg_inode_bitmap_csum_lo;<span class="comment">/* crc32c(s_uuid+grp_num+ibitmap) LE Inodes位图校验 */</span></span><br><span class="line">	__le16  bg_itable_unused_lo;	<span class="comment">/* 未使用inodes数量 */</span></span><br><span class="line">	__le16  bg_checksum;		<span class="comment">/* crc16(sb_uuid+group+desc)校验 */</span></span><br><span class="line">	__le32	bg_block_bitmap_hi;	<span class="comment">/* 数据块位图 MSB */</span></span><br><span class="line">	__le32	bg_inode_bitmap_hi;	<span class="comment">/* Inodes位图 MSB */</span></span><br><span class="line">	__le32	bg_inode_table_hi;	<span class="comment">/* Inodes表块 MSB */</span></span><br><span class="line">	__le16	bg_free_blocks_count_hi;<span class="comment">/* 空闲块计数MSB */</span></span><br><span class="line">	__le16	bg_free_inodes_count_hi;<span class="comment">/* 空心啊节点数MSB */</span></span><br><span class="line">	__le16	bg_used_dirs_count_hi;	<span class="comment">/* 已经使用的目录数量MSB */</span></span><br><span class="line">	__le16  bg_itable_unused_hi;    <span class="comment">/* 未使用节点数MSB */</span></span><br><span class="line">	__le32  bg_exclude_bitmap_hi;   <span class="comment">/* 不包括位图块 MSB */</span></span><br><span class="line">	__le16  bg_block_bitmap_csum_hi;<span class="comment">/* crc32c(s_uuid+grp_num+bbitmap) BE */</span></span><br><span class="line">	__le16  bg_inode_bitmap_csum_hi;<span class="comment">/* crc32c(s_uuid+grp_num+ibitmap) BE */</span></span><br><span class="line">	__u32   bg_reserved;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-块位图和inode位图"><a href="#1-2-3-块位图和inode位图" class="headerlink" title="1.2.3 块位图和inode位图"></a>1.2.3 块位图和inode位图</h4><p><strong>块位图（block bitmap）</strong>：标记block是否被使用。每个比特代表块组中哪些块可用，哪些块已经被占有。块位图本身要占有一个块。如果块大小设置为1K字节，则一个块组的大小为1K×1K×8bit = 8M字节。</p>
<p>如果某个块对应的位未置位，那么代表该块未分配，可以用于存储数据；否则，代表该块已经用于存储数据或者该块不能够使用(譬如该块物理上不存在)。由于块位图仅占一个块，因此这也就决定了块组的大小。如果一个数据块大小是4KB的话，那一个位图块可以表示410248个数据块的使用情况，这也是单个块组具有的最大数据块个数。这样可以算出一个块组大小是128MB。</p>
<p><strong>inode位图（inode bitmap)</strong> ：标记inode是否被使用。inode位图也占用一个块。它的每一位代表一个inode是否空闲。</p>
<p>每个inode对应文件系统中唯一的一个号，如果inode位图中相应位置位，那么代表该inode已经分配出去；否则可以使用。由于其仅占用一个块，因此这也限制了一个块组中所能够使用的最大inode数量。</p>
<h4 id="1-2-4-inode表"><a href="#1-2-4-inode表" class="headerlink" title="1.2.4 inode表"></a>1.2.4 inode表</h4><p><strong>inode表（inode table）</strong>：每个文件都有一个inode，inode保存了文件的描述信息、文件的类型、文件的大小、文件的创建访问时间等。一个inode占128字节。如果文件系统块大小为1K字节，一个块可容纳8个inode。 inode表可以占用多个块。为了找到与一个文件相关的信息，必须遍历目录文件找到与文件相关的目录项，然后加载inode找到该文件的元数据。</p>
<p>inode表占用一个或多个块（为了有效的利用空间，多个inode存储在一个块中），其大小取决于文件系统创建时的参数，由于inode位图的限制，决定了其最大所占用的空间。以上这几个构成元素所处的磁盘块成为文件系统的元数据块，剩余的部分则用来存储真正的文件内容，称为数据块，而数据块其实也包含数据和目录。其结构体是<code>struct ext4_inode</code>，位于<code>fs/ext4/ext4.h</code>文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode</span> &#123;</span></span><br><span class="line">	__le16	i_mode;		<span class="comment">/* 文件类型和访问权限 */</span></span><br><span class="line">	__le16	i_uid;		<span class="comment">/* 文件所有者ID */</span></span><br><span class="line">	__le32	i_size_lo;	<span class="comment">/* 文件大小，单位字节 */</span></span><br><span class="line">	__le32	i_atime;	<span class="comment">/* 访问时间 */</span></span><br><span class="line">	__le32	i_ctime;	<span class="comment">/* 索引修改时间 */</span></span><br><span class="line">	__le32	i_mtime;	<span class="comment">/* 文件内容修改时间 */</span></span><br><span class="line">	__le32	i_dtime;	<span class="comment">/* 删除时间 */</span></span><br><span class="line">	__le16	i_gid;		<span class="comment">/* 用户组ID */</span></span><br><span class="line">	__le16	i_links_count;	<span class="comment">/* 连接数量 */</span></span><br><span class="line">	__le32	i_blocks_lo;	<span class="comment">/* 块数量 */</span></span><br><span class="line">	__le32	i_flags;	<span class="comment">/* 文件类型 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le32  l_i_version;</span><br><span class="line">		&#125; linux1;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32  h_i_translator;</span><br><span class="line">		&#125; hurd1;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32  m_i_reserved1;</span><br><span class="line">		&#125; masix1;</span><br><span class="line">	&#125; osd1;				<span class="comment">/* 特定的os信息1 */</span></span><br><span class="line">	__le32	i_block[EXT4_N_BLOCKS];<span class="comment">/* 文件内容块号码 */</span></span><br><span class="line">	__le32	i_generation;	<span class="comment">/* 文件版本 */</span></span><br><span class="line">	__le32	i_file_acl_lo;	<span class="comment">/* File ACL */</span></span><br><span class="line">	__le32	i_size_high;	<span class="comment">//文件大小的高位</span></span><br><span class="line">	__le32	i_obso_faddr;	<span class="comment">/* Obsoleted fragment address */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le16	l_i_blocks_high; <span class="comment">/* 数据块数高16位 */</span></span><br><span class="line">			__le16	l_i_file_acl_high;<span class="comment">//高16位的文件ACL</span></span><br><span class="line">			__le16	l_i_uid_high;	<span class="comment">/* 所有者id的高16位 */</span></span><br><span class="line">			__le16	l_i_gid_high;	<span class="comment">/* 组ID的高16位 */</span></span><br><span class="line">			__le16	l_i_checksum_lo;<span class="comment">/* crc32c(uuid+inum+inode) LE */</span></span><br><span class="line">			__le16	l_i_reserved;</span><br><span class="line">		&#125; linux2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le16	h_i_reserved1;	<span class="comment">/* Obsoleted fragment number/size which are removed in ext4 */</span></span><br><span class="line">			__u16	h_i_mode_high;</span><br><span class="line">			__u16	h_i_uid_high;</span><br><span class="line">			__u16	h_i_gid_high;</span><br><span class="line">			__u32	h_i_author;</span><br><span class="line">		&#125; hurd2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__le16	h_i_reserved1;	<span class="comment">/* Obsoleted fragment number/size which are removed in ext4 */</span></span><br><span class="line">			__le16	m_i_file_acl_high;</span><br><span class="line">			__u32	m_i_reserved2[<span class="number">2</span>];</span><br><span class="line">		&#125; masix2;</span><br><span class="line">	&#125; osd2;				<span class="comment">/* 特定的os信息2 */</span></span><br><span class="line">	__le16	i_extra_isize;<span class="comment">//extra大小</span></span><br><span class="line">	__le16	i_checksum_hi;	<span class="comment">/* crc32c(uuid+inum+inode) BE */</span></span><br><span class="line">	__le32  i_ctime_extra;  <span class="comment">/* extra修改inode时间(nsec &lt;&lt; 2 | epoch) */</span></span><br><span class="line">	__le32  i_mtime_extra;  <span class="comment">/* extra修改文件时间(nsec &lt;&lt; 2 | epoch) */</span></span><br><span class="line">	__le32  i_atime_extra;  <span class="comment">/* extra访问时间(nsec &lt;&lt; 2 | epoch) */</span></span><br><span class="line">	__le32  i_crtime;       <span class="comment">/* 文件创建时间(nsec &lt;&lt; 2 | epoch) */</span></span><br><span class="line">	__le32  i_crtime_extra; <span class="comment">/* extra 文件创建时间 (nsec &lt;&lt; 2 | epoch) */</span></span><br><span class="line">	__le32  i_version_hi;	<span class="comment">/* 64位版本号高32位 */</span></span><br><span class="line">	__le32	i_projid;	<span class="comment">/* 项目ID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-5-目录项对象"><a href="#1-2-5-目录项对象" class="headerlink" title="1.2.5 目录项对象"></a>1.2.5 目录项对象</h4><p>VFS把目录当作文件对待，所以在路径<code>/bin/vi</code>中，<code>bin</code>和<code>vi</code>都属于文件——bin是特殊的目录文件而vi是一个普通文件，路径中的每个组成部分都由一个索引节点对象表示。虽然它们可以统一由索引节点表示，但是VFS经常需要执行目录相关的操作，比如路径名查找等。路径名查找需要解析路径中的每一个组成部分，不但要确保它有效，而且还需要再进一步寻找路径中的下一个部分。</p>
<p>为了方便查找操作，VFS引入了目录项的概念。每个<code>dentry</code>代表路径中的一个特定部分。对前一个例子来说，/、bin和vi都属于目录项对象。前两个是目录，最后一个是普通文件。在路径中（包括普通文件在内)，每一个部分都是目录项对象。解析一个路径并遍历其分量绝非简单的演练，它是耗时的、常规的字符串比较过程，执行耗时、代码繁琐。目录项对象的引入使得这个过程更加简单。</p>
<p>目录项也可包括安装点。在路径<code>/mnt/cdrom/foo</code>中，构成元素/、mnt、cdrom和foo都属于目录项对象。VFS在执行目录操作时（如果需要的话）会现场创建目录项对象。</p>
<p>目录项对象由<code>dentry</code>结构体表示，定义在文件<code>&lt;linux/dcache.h&gt;</code>中。下面给出该结构体和其中各项的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> d _count;				<span class="comment">/* 使用记数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d_flags ; 			<span class="comment">/* 目录项标识 */</span></span><br><span class="line">    <span class="type">spinlock_t</span> d_lock ; 			<span class="comment">/* 单目录项锁 */</span></span><br><span class="line">    <span class="type">int</span> d_mounted;					<span class="comment">/* 是登录点的目录项吗? */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span> ;</span>			<span class="comment">/* 相关联的索引节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_hash</span>;</span>		<span class="comment">/* 散列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> <span class="title">d</span> <span class="title">parent</span> ;</span>		<span class="comment">/* 父目录的目录项对象 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span> ;</span>			<span class="comment">/* 目录项名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list__head</span> <span class="title">d_lru</span>;</span> 		<span class="comment">/* 未使用的链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>	<span class="comment">/* 目录项内部形成的链表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">d_rcu</span>;</span>		<span class="comment">/* RCU加锁 */</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>		<span class="comment">/* 子目录链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_</span> <span class="title">head</span> <span class="title">d_alias</span>;</span>		<span class="comment">/* 索引节点别名链表 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> d_time ;			<span class="comment">/* 重置时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d__op</span>;</span><span class="comment">/* 目录项操作指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> <span class="title">d_sb</span>;</span>		<span class="comment">/* 文件的超级块 */</span></span><br><span class="line">    <span class="type">void</span> d_fsdata;					<span class="comment">/* 文件系统特有数据 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_iname [DNAMB_INLINE__LEN_MIN] ; <span class="comment">/*短文件名*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于ext4文件系统，在目录项中用一位存储了文件类型（通常存储在inode中）的拷贝，这对性能提升有益。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_dir_entry_2</span> &#123;</span></span><br><span class="line">    __le32 inode;				<span class="comment">/*Inode号*/</span></span><br><span class="line">    __le16 rec_len;				<span class="comment">/*目录项长度*/</span></span><br><span class="line">    __u8 name_len;				<span class="comment">/*名字长度*/</span></span><br><span class="line">    __u8 file_type;				<span class="comment">/*文件类型*/</span></span><br><span class="line">    <span class="type">char</span> name[EXT4_NAME__LEN];	<span class="comment">/*文件名*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-6-数据块"><a href="#1-2-6-数据块" class="headerlink" title="1.2.6 数据块"></a>1.2.6 数据块</h4><p><strong>数据块（data block）</strong>：保存文件的内容。常规文件的数据保存在数据块中，如果是目录文件，那么该目录下所有的文件名和下级目录名都保存在数据块中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Constants relative to the data blocks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_NDIR_BLOCKS		12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_IND_BLOCK			EXT4_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_DIND_BLOCK			(EXT4_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_TIND_BLOCK			(EXT4_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	EXT4_N_BLOCKS			(EXT4_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure>
<p>当格式化磁盘成为ext4文件系统的时候，<code>mkfs</code>将在块组描述符表后面分配预留GDT表数据块（“Reserve GDT blocks”）以用于将来扩展文件系统。紧接在预留GDT表数据块后的是数据块位图与<code>inode</code>表位图，这两个位图分别表示本块组内的数据块与<code>inode</code>表的使用，<code>inode</code>表数据块之后就是存储文件的数据块了。在这些各种各样的块中，超级块、GDT、块位图、<code>inode</code>位图都是整个文件系统的元数据，当然<code>inode</code>表也是文件系统的元数据，但是<code>inode</code>表是与文件一一对应的。在实际格式化文件系统的时候，除了已经使用的十来个<code>inode</code>表外，其他<code>inode</code>表中实际上是没有任何数据的，直到创建了相应的文件才会分配<code>inode</code>表，文件系统才会在<code>inode</code>表中写入与文件相关的<code>inode</code>信息。</p>
<p>上面的数据结构都是硬件设备定好的，ext4只是把这些数据结构一个个读出来再分析哪些是目录哪些是文件哪些是文件内容。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/R-3C.png" alt="图3 ext4工作过程" style="zoom:80%;" /></p>
<p>在ext4文件系统挂载的第一步是读取前512字节的MBR数据结构，确定是ext4格式的，并且分析有几个分区。然后根据分区的信息（分区类型，起始地址，长度）去到块组0中读取超级块，读取超级块后紧接着就是块组描述符表，通过块组描述符表就可以知道数据块位图，inode位图，inode表所在的数据块，位图是用来确定数据块和inode的使用情况，inode表记录着数据，前面的10个inode都有着特殊作用，其中inode2是根目录，里面记录着根目录的各种信息，从此就散发出来一连串的inode，他们可以代表着一个文件或者目录，通过他们这些inode可以找到对应的数据块。</p>
<h2 id="2-分析Linux进程调度源码"><a href="#2-分析Linux进程调度源码" class="headerlink" title="2. 分析Linux进程调度源码"></a>2. 分析Linux进程调度源码</h2><p>分析linux(4.X版本以上)进程调度源码，尝试解释进程调度CFS调度算法原理，给出主要数据结构和函数的相关解释（给出代码出处——路径和文件名）</p>
<h3 id="2-1-进程调度原则"><a href="#2-1-进程调度原则" class="headerlink" title="2.1 进程调度原则"></a>2.1 进程调度原则</h3><p>调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。进程调度程序可看做在可运行态进程之间分配有限的处理器时间资源的内核子系统。调度程序是像Linux这样的多任务操作系统的基础。只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。</p>
<p>最大限度地利用处理器时间的原则是，只要有可以执行的进程，那么就总会有进程正在执行。但是只要系统中可运行的进程的数目比处理器的个数多，就注定某一给定时刻会有一些进程不能执行。这些进程在等待运行。在一组处于可运行状态的进程中选择一个来执行，是调度程序所需完成的基本工作。</p>
<h3 id="2-2-CFS调度算法"><a href="#2-2-CFS调度算法" class="headerlink" title="2.2 CFS调度算法"></a>2.2 CFS调度算法</h3><p>CFS调度算法相关代码位于文件<code>kernel/sched_fair.c</code>中。其中有四个重要的组成部分:</p>
<ul>
<li>时间记账</li>
<li>进程选择</li>
<li>调度器入口</li>
<li>睡眠和唤醒</li>
</ul>
<h4 id="2-2-1-时间记账"><a href="#2-2-1-时间记账" class="headerlink" title="2.2.1 时间记账"></a>2.2.1 时间记账</h4><p>所有的调度器都必须对进程运行时间做记账。分配一个时间片给每一个进程。当每次系统时钟节拍发生时，时间片都会被减少一个节拍周期。当一个进程的时间片被减少到0时，它就会被另一个尚未减到0的时间片可运行进程抢占。</p>
<h5 id="1-调度器实体结构"><a href="#1-调度器实体结构" class="headerlink" title="1.调度器实体结构"></a>1.调度器实体结构</h5><p>CFS不再有时间片的概念，但是它也必须维护每个进程运行的时间记账，因为它需要确保每个进程只在公平分配给它的处理器时间内运行。</p>
<p>CFS使用调度器实体结构（定义在文件<code>&lt;linux/sched.h&gt;</code>的<code>struct_sched_entity</code> 中）来追踪进程运行记账:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 用于调度均衡的变量，红黑树 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>		<span class="title">load</span>;</span> <span class="comment">// 权重</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			runnable_weight; <span class="comment">// 可运行进程的权重</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">run_node</span>;</span> <span class="comment">// rbtree节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">group_node</span>;</span> <span class="comment">// 所在进程组</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			on_rq; <span class="comment">// 标记是否处于红黑树运行队列中</span></span><br><span class="line">	u64				exec_start; <span class="comment">// 进程开始执行的时间</span></span><br><span class="line">	u64				sum_exec_runtime; <span class="comment">// 进程总运行时间</span></span><br><span class="line">	u64				vruntime; <span class="comment">// 虚拟运行时间</span></span><br><span class="line">	u64				prev_sum_exec_runtime; <span class="comment">// 进程在切换CPU时的sum_exec_runtime，简单说就是上个调度周期中运行的总时间</span></span><br><span class="line">	u64				nr_migrations;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_statistics</span>		<span class="title">statistics</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符struct task_struct 内。</p>
<h5 id="2-虚拟实时"><a href="#2-虚拟实时" class="headerlink" title="2.虚拟实时"></a>2.虚拟实时</h5><p>vruntime变量存放进程的虚拟运行时间，该运行时间（花在运行上的时间和）的计算是经过了所有可运行进程总数的标准化(或者说是被加权的)。虚拟时间是以ns 为单位的，所以vruntime和定时器节拍不再相关。虚拟运行时间可以帮助逼近CFS模型所追求的“理想多任务处理器”。因为优先级相同的所有进程的虚拟运行时都是相同的——所有任务都将接收到相等的处理器份额。但是因为处理器无法实现完美的多任务，它必须依次运行每个任务。因此CFS使用vruntime变量来记录一个程序到底运行了多长时间以及它还应该再运行多久。</p>
<p>定义在<code>kernel/sched_fair.c</code>文件中的<code>update_curr()</code>函数实现了该记账功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Update the current task&#x27;s runtime statistics.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_curr</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> =</span> cfs_rq-&gt;curr;</span><br><span class="line">	u64 now = rq_clock_task(rq_of(cfs_rq));</span><br><span class="line">	u64 delta_exec;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!curr))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">// 获得从最后一次修改负载后当前任务所占用的运行总时间</span></span><br><span class="line">	delta_exec = now - curr-&gt;exec_start;</span><br><span class="line">	<span class="keyword">if</span> (unlikely((s64)delta_exec &lt;= <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span>;		</span><br><span class="line">	<span class="comment">// 更新执行开始时间</span></span><br><span class="line">	curr-&gt;exec_start = now;</span><br><span class="line">	schedstat_set(curr-&gt;statistics.exec_max,</span><br><span class="line">		      max(delta_exec, curr-&gt;statistics.exec_max));</span><br><span class="line">	curr-&gt;sum_exec_runtime += delta_exec;</span><br><span class="line">	schedstat_add(cfs_rq-&gt;exec_clock, delta_exec);</span><br><span class="line">	<span class="comment">// 计算虚拟时间，具体的转换算法写在clac_delta_fair函数中</span></span><br><span class="line">	curr-&gt;vruntime += calc_delta_fair(delta_exec, curr);</span><br><span class="line">	update_min_vruntime(cfs_rq);</span><br><span class="line">	<span class="keyword">if</span> (entity_is_task(curr)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curtask</span> =</span> task_of(curr);</span><br><span class="line">		trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);</span><br><span class="line">		cgroup_account_cputime(curtask, delta_exec);</span><br><span class="line">		account_group_exec_runtime(curtask, delta_exec);</span><br><span class="line">	&#125;</span><br><span class="line">	account_cfs_rq_runtime(cfs_rq, delta_exec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_curr()</code>是由系统定时器周期性调用的，无论是在进程处于可运行态，还是被堵塞处于不可运行态。根据这种方式，<code>vruntime</code>可以准确地测量给定进程的运行时间，而且可知道谁应该是下一个被运行的进程。</p>
<h4 id="2-2-2-进程选择"><a href="#2-2-2-进程选择" class="headerlink" title="2.2.2 进程选择"></a>2.2.2 进程选择</h4><p>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程。在Linux中，红黑树（rbtree）是一个自平衡二叉搜索树，以树节点形式存储的数据。这些数据都会对应一个键值。我们可以通过这些键值来快速检索节点上的数据（重要的是，通过键值检索到对应节点的速度与整个树的节点规模成指数比关系)。</p>
<h5 id="1-挑选下一个任务"><a href="#1-挑选下一个任务" class="headerlink" title="1.挑选下一个任务"></a>1.挑选下一个任务</h5><p>CFS调度器选取待运行的下一个进程，是所有进程中 vruntime最小的那个，它对应的便是在树中最左侧的叶子节点。即：从根节点沿着左分支的子节点向下找，一直找到叶子节点你便找到了其vruntime值最小的那个进程。CFS的进程选择算法简单总结为：“运行rbtree树中最左边叶子节点所代表的那个进程”。</p>
<p>实现这一过程的函数是<code>_pick next_entity()</code>，它定义在文件<code>kernel/sched_fair.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sched_entity *</span><br><span class="line"><span class="title function_">pick_next_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">left</span> =</span> __pick_first_entity(cfs_rq);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If curr is set we have to see if its left of the leftmost entity</span></span><br><span class="line"><span class="comment">	 * still in the tree, provided there was anything in the tree at all.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!left || (curr &amp;&amp; entity_before(curr, left)))</span><br><span class="line">		left = curr;</span><br><span class="line">	se = left; <span class="comment">/* ideally we run the leftmost entity */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 特殊情况</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (cfs_rq-&gt;skip == se) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">second</span>;</span></span><br><span class="line">		<span class="keyword">if</span> (se == curr) &#123;</span><br><span class="line">			second = __pick_first_entity(cfs_rq);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			second = __pick_next_entity(se);</span><br><span class="line">			<span class="keyword">if</span> (!second || (curr &amp;&amp; entity_before(curr, second)))</span><br><span class="line">				second = curr;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">if</span> (second &amp;&amp; wakeup_preempt_entity(second, left) &lt; <span class="number">1</span>)</span><br><span class="line">			se = second;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cfs_rq-&gt;last &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;last, left) &lt; <span class="number">1</span>)</span><br><span class="line">		se = cfs_rq-&gt;last;</span><br><span class="line">	<span class="keyword">if</span> (cfs_rq-&gt;next &amp;&amp; wakeup_preempt_entity(cfs_rq-&gt;next, left) &lt; <span class="number">1</span>)</span><br><span class="line">		se = cfs_rq-&gt;next;</span><br><span class="line">	clear_buddies(cfs_rq, se);</span><br><span class="line">	<span class="keyword">return</span> se;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>_pick_next_entity()</code>函数本身并不会遍历树找到最左叶子节点，因为该值已经缓存在<code>rb_leftmost</code>字段中。虽然红黑树让我们可以很有效地找到最左叶子节点（О(树高) 等于树节点总数的 O(log n)，这是平衡树的优势），但是更容易的做法是把最左叶子节点缓存起来。这个函数的返回值便是CFS 调度选择的下一个运行进程。如果该函数返回值是NULL，那么表示没有最左叶子节点，也就是说树中没有任何节点了。这种情况下，表示没有可运行进程，CFS调度器便选择idle任务运行。</p>
<h5 id="2-向树中加入进程"><a href="#2-向树中加入进程" class="headerlink" title="2.向树中加入进程"></a>2.向树中加入进程</h5><p>CFS在进程变为可运行状态（被唤醒）或者是通过<code>fork()</code>调用第一次创建进程时，将进程加入rbtree中，以及缓存最左叶子节点。</p>
<p>由<code>enqueue_entity()</code>函数实现。</p>
<p>更新运行时间和各类统计数据，然后调用<code>__enqueue_entity()</code>来把数据真正插入红黑树中。其中<code>__enqueue_entity()</code>的while循环遍历树以寻找匹配键值的过程。找到后对要插入位置的父节点执行<code>rb_link_node()</code>来将节点插入其中，然后更新红黑树的自平衡相关属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">enqueue_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">	<span class="type">bool</span> renorm = !(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATED);</span><br><span class="line">	<span class="type">bool</span> curr = cfs_rq-&gt;curr == se;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 如果要加入的进程就是当前正在运行的进程，重新规范化vruntime</span></span><br><span class="line"><span class="comment">	 * 然后更新当前任务的运行时统计数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (renorm &amp;&amp; curr)</span><br><span class="line">		se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Otherwise, renormalise after, such that we&#x27;re placed at the current</span></span><br><span class="line"><span class="comment">	 * moment in time, instead of some random moment in the past. Being</span></span><br><span class="line"><span class="comment">	 * placed in the past could significantly boost this task to the</span></span><br><span class="line"><span class="comment">	 * fairness detriment of existing tasks.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (renorm &amp;&amp; !curr)</span><br><span class="line">		se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 更新对应调度器实体的各种记录值</span></span><br><span class="line"><span class="comment">	 */</span>	 </span><br><span class="line">	update_load_avg(cfs_rq, se, UPDATE_TG | DO_ATTACH);</span><br><span class="line">	update_cfs_group(se);</span><br><span class="line">	enqueue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	account_entity_enqueue(cfs_rq, se);</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ENQUEUE_WAKEUP)</span><br><span class="line">		place_entity(cfs_rq, se, <span class="number">0</span>);</span><br><span class="line">	check_schedstat_required();</span><br><span class="line">	update_stats_enqueue(cfs_rq, se, flags);</span><br><span class="line">	check_spread(cfs_rq, se);</span><br><span class="line">	<span class="keyword">if</span> (!curr)</span><br><span class="line">		__enqueue_entity(cfs_rq, se); <span class="comment">// 真正的插入过程</span></span><br><span class="line">	se-&gt;on_rq = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (cfs_rq-&gt;nr_running == <span class="number">1</span>) &#123;</span><br><span class="line">		list_add_leaf_cfs_rq(cfs_rq);</span><br><span class="line">		check_enqueue_throttle(cfs_rq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 插入红黑树 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __enqueue_entity(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">link</span> =</span> &amp;cfs_rq-&gt;tasks_timeline.rb_root.rb_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">bool</span> leftmost = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在红黑树中搜索合适的位置</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">while</span> (*link) &#123;</span><br><span class="line">		parent = *link;</span><br><span class="line">		entry = rb_entry(parent, <span class="keyword">struct</span> sched_entity, run_node);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 具有相同键值的节点会被放在一起</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (entity_before(se, entry)) &#123;</span><br><span class="line">			link = &amp;parent-&gt;rb_left;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			link = &amp;parent-&gt;rb_right;</span><br><span class="line">			leftmost = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rb_link_node(&amp;se-&gt;run_node, parent, link);</span><br><span class="line">	rb_insert_color_cached(&amp;se-&gt;run_node,</span><br><span class="line">			       &amp;cfs_rq-&gt;tasks_timeline, leftmost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-从树中删除进程"><a href="#3-从树中删除进程" class="headerlink" title="3.从树中删除进程"></a>3.从树中删除进程</h5><p>CFS是如何从红黑树中删除进程的动作发生在进程堵塞（变为不可运行态）或者终止时（结束运行）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dequeue_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *se, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 更新“当前进程”的运行统计数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_curr(cfs_rq);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When dequeuing a sched_entity, we must:</span></span><br><span class="line"><span class="comment">	 *   - Update loads to have both entity and cfs_rq synced with now.</span></span><br><span class="line"><span class="comment">	 *   - Substract its load from the cfs_rq-&gt;runnable_avg.</span></span><br><span class="line"><span class="comment">	 *   - Substract its previous weight from cfs_rq-&gt;load.weight.</span></span><br><span class="line"><span class="comment">	 *   - For group entity, update its weight to reflect the new share</span></span><br><span class="line"><span class="comment">	 *     of its group cfs_rq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	update_load_avg(cfs_rq, se, UPDATE_TG);</span><br><span class="line">	dequeue_runnable_load_avg(cfs_rq, se);</span><br><span class="line">	update_stats_dequeue(cfs_rq, se, flags);</span><br><span class="line">	clear_buddies(cfs_rq, se);</span><br><span class="line">	<span class="keyword">if</span> (se != cfs_rq-&gt;curr)</span><br><span class="line">		__dequeue_entity(cfs_rq, se);</span><br><span class="line">	se-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line">	account_entity_dequeue(cfs_rq, se);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 重新规范化vruntime</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; DEQUEUE_SLEEP))</span><br><span class="line">		se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line">	<span class="comment">/* return excess runtime on last dequeue */</span></span><br><span class="line">	return_cfs_rq_runtime(cfs_rq);</span><br><span class="line">	update_cfs_group(se);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now advance min_vruntime if @se was the entity holding it back,</span></span><br><span class="line"><span class="comment">	 * except when: DEQUEUE_SAVE &amp;&amp; !DEQUEUE_MOVE, in this case we&#x27;ll be</span></span><br><span class="line"><span class="comment">	 * put back on, and if we advance min_vruntime, we&#x27;ll be placed back</span></span><br><span class="line"><span class="comment">	 * further than we started -- ie. we&#x27;ll be penalized.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; (DEQUEUE_SAVE | DEQUEUE_MOVE)) == DEQUEUE_SAVE)</span><br><span class="line">		update_min_vruntime(cfs_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-调度器入口"><a href="#2-2-3-调度器入口" class="headerlink" title="2.2.3 调度器入口"></a>2.2.3 调度器入口</h4><p>进程调度的主要入口点是函数<code>schedule()</code>，它定义在文件<code>kernel/sched.c</code>中。它是内核其他部分用于调用进程调度器的入口：选择哪个进程可以运行，何时将其投入运行。</p>
<p>Schedule()通常都需要和一个具体的调度类相关联，会找到一个最高优先级的调度类。后者需要有自己的可运行队列，然后问后者谁才是下一个该运行的进程。知道了这个背景，就不会吃惊schedule()函数为何实现得如此简单。该函数中调用pick_next_task()（文件kernel/sched.c中）。</p>
<p>pick_next_task()会以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选择最高优先级的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 优化：如果当前所有要调度的进程都是普通进程，那么就直接采用普通进程的调度类（CFS）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (likely((prev-&gt;sched_class == &amp;idle_sched_class ||</span><br><span class="line">		    prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">		   rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line">		p = fair_sched_class.pick_next_task(rq, prev, rf);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!p))</span><br><span class="line">			p = idle_sched_class.pick_next_task(rq, prev, rf);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 遍历调度类</span></span><br><span class="line">again:</span><br><span class="line">	for_each_class(class) &#123;</span><br><span class="line">		p = class-&gt;pick_next_task(rq, prev, rf);</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* The idle class should always have a runnable task: */</span></span><br><span class="line">	BUG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的核心是for循环，它以优先级为序，从最高的优先级类开始，遍历了每一个调度类。每一个调度类都实现了pick_next_task()函数，它会返回指向下一个可运行进程的指针，或者没有时返回NULL。我们会从第一个返回非NULL值的类中选择下一个可运行进程。CFS中pick_next_task()实现会调用pick_next_entity()，而该函数会调用前文涉及的__pick_next_entity()函数。</p>
<h4 id="2-2-4-睡眠和唤醒"><a href="#2-2-4-睡眠和唤醒" class="headerlink" title="2.2.4 睡眠和唤醒"></a>2.2.4 睡眠和唤醒</h4><p>休眠（被阻塞）的进程处于一个特殊的不可执行状态。如果没有这种特殊状态的话，调度程序就可能选出一个本不愿意被执行的进程，甚至休眠就必须以轮询的方式实现了。进程休眠有多种原因，但肯定都是为了等待一些事件。事件可能是一段时间从文件UO读更多数据，或者是某个硬件事件。</p>
<p>一个进程还有可能在尝试获取一个已被占用的内核信号量时被迫进入休眠。休眠的一个常见原因就是文件IO——如进程对一个文件执行了read()操作，而这需要从磁盘里读取。还有，进程在获取键盘输入的时候也需安寺待。无论哪种情况，内核的操作都相同：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程。唤醒的过程刚好相反：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。</p>
<p>休眠有两种相关的进程状态:TASK_INTERRUPTIBLE和 TASK_UNINTERRUPTIBLE。它们的唯一区别是处于TASK_UNINTERRUPTIBLE的进程会忽略信号，而处于TASK_INTERRUPTIBLE 状态的进程如果接收到一个信号，会被提前唤醒并响应该信号。两种状态的进程位于同一个等待队列上，等待某些事件，不能够运行。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706111311113.png" alt="图4 休眠与唤醒" style="zoom:80%;" /></p>
<h5 id="1-等待队列"><a href="#1-等待队列" class="headerlink" title="1.等待队列"></a>1.等待队列</h5><p>休眠通过等待队列进行处理。等待队列是由等待某些事件发生的进程组成的简单链表。内核用wake_queue_head_t来代表等待队列。等待队列可以通过DECLARE_WAITQUEUE(O)静态创建，也可以由init_waitqueue_head()动态创建。</p>
<p>进程把自己放入等待队列中并设置成不可执行状态。当与等待队列相关的事件发生的时候，队列上的进程会被唤醒。为了避免产生竞争条件，休眠和唤醒的实现不能有纰漏。针对休眠，以前曾经使用过一些简单的接口。但那些接口会带来竞争条件:有可能导致在判定条件变为真后，进程却开始了休眠，那样就会使进程无限期地休眠下去。所以，在内核中进行休眠的推荐操作就相对复杂了一些。</p>
<p>而休眠的过程需要进程自己把自己加入到一个等待队列中，这可以使用内核所提供的、推荐的函数来实现。</p>
<p>一个可能的流程如下：</p>
<ol>
<li>调用宏<code>DEFINE_WAIT()</code>创建一个等待队列的项（链表的节点）</li>
<li>调用<code>add_wait_queue()</code>把自己加到队列中去。该队列会在进程等待的条件满足时唤醒它，当然唤醒的具体操作需要进程自己定义好（你可以理解为一个回调）</li>
<li>调用<code>prepare_to_wait()</code>方法把自己的状态变更为上面说到的两种休眠状态中的其中一种。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_wait_queue</span><span class="params">(<span class="keyword">struct</span> wait_queue_head *wq_head, <span class="keyword">struct</span> wait_queue_entry *wq_entry)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">	wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	__add_wait_queue(wq_head, wq_entry);</span><br><span class="line">	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __add_wait_queue(<span class="keyword">struct</span> wait_queue_head *wq_head, <span class="keyword">struct</span> wait_queue_entry *wq_entry) &#123;</span><br><span class="line">	list_add(&amp;wq_entry-&gt;entry, &amp;wq_head-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">prepare_to_wait</span><span class="params">(<span class="keyword">struct</span> wait_queue_head *wq_head, <span class="keyword">struct</span> wait_queue_entry *wq_entry, <span class="type">int</span> state)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"> </span><br><span class="line">	wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;</span><br><span class="line">	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;wq_entry-&gt;entry))</span><br><span class="line">		__add_wait_queue(wq_head, wq_entry);</span><br><span class="line">	<span class="comment">// 自己的进程状态</span></span><br><span class="line">	set_current_state(state);</span><br><span class="line">	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-唤醒"><a href="#2-唤醒" class="headerlink" title="2.唤醒"></a>2.唤醒</h5><p>唤醒操作通过函数wake_up()进行，它会唤醒指定的等待队列上的所有进程。</p>
<p>它调用函数try_to_wake_up()，该函数负责将进程设置为TASK_RUNNING状态，调用enqueue_task()将此进程放入红黑树中，如果被唤醒的进程优先级比当前正在执行的进程的优先级高，还要设置need_resched标志。通常哪段代码促使等待条件达成，它就要负责随后调用wake_up()函数。</p>
<p>举例来说,当磁盘数据到来时，VFS就要负责对等待队列调用wake_up()，以便唤醒队列中等待这些数据的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The core wakeup function. Non-exclusive wakeups (nr_exclusive == 0) just</span></span><br><span class="line"><span class="comment"> * wake everything up. If it&#x27;s an exclusive wakeup (nr_exclusive == small +ve</span></span><br><span class="line"><span class="comment"> * number) then we wake all the non-exclusive tasks and one exclusive task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are circumstances in which we can try to wake a task which has already</span></span><br><span class="line"><span class="comment"> * started to run but is not in state TASK_RUNNING. try_to_wake_up() returns</span></span><br><span class="line"><span class="comment"> * zero in this (rare) case, and we handle it by continuing to scan the queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __wake_up_common(<span class="keyword">struct</span> wait_queue_head *wq_head, <span class="type">unsigned</span> <span class="type">int</span> mode,</span><br><span class="line">			<span class="type">int</span> nr_exclusive, <span class="type">int</span> wake_flags, <span class="type">void</span> *key,</span><br><span class="line">			<span class="type">wait_queue_entry_t</span> *bookmark) &#123;</span><br><span class="line">	<span class="type">wait_queue_entry_t</span> *curr, *next;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) &#123;</span><br><span class="line">		curr = list_next_entry(bookmark, entry);</span><br><span class="line">		list_del(&amp;bookmark-&gt;entry);</span><br><span class="line">		bookmark-&gt;flags = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		curr = list_first_entry(&amp;wq_head-&gt;head, <span class="type">wait_queue_entry_t</span>, entry);</span><br><span class="line">	<span class="keyword">if</span> (&amp;curr-&gt;entry == &amp;wq_head-&gt;head)</span><br><span class="line">		<span class="keyword">return</span> nr_exclusive;</span><br><span class="line">	list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123;</span><br><span class="line">		<span class="type">unsigned</span> flags = curr-&gt;flags;</span><br><span class="line">		<span class="type">int</span> ret;</span><br><span class="line">		<span class="keyword">if</span> (flags &amp; WQ_FLAG_BOOKMARK)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		ret = curr-&gt;func(curr, mode, wake_flags, key);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (ret &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (bookmark &amp;&amp; (++cnt &gt; WAITQUEUE_WALK_BREAK_CNT) &amp;&amp;</span><br><span class="line">				(&amp;next-&gt;entry != &amp;wq_head-&gt;head)) &#123;</span><br><span class="line">			bookmark-&gt;flags = WQ_FLAG_BOOKMARK;</span><br><span class="line">			list_add_tail(&amp;bookmark-&gt;entry, &amp;next-&gt;entry);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr_exclusive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-公平调度算法总结"><a href="#2-3-公平调度算法总结" class="headerlink" title="2.3 公平调度算法总结"></a>2.3 公平调度算法总结</h3><p>CFS的出发点基于一个简单的理念：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。在这种系统中，每个进程将能获得1/n的处理器时间——n是指可运行进程的数量。同时可以调度给它们无限小的时间周期，所以在任何可测量周期内，给予n个进程中每个进程同样多的运行时间。</p>
<p>但是实际情况中无法在一个处理器上真的同时运行多个进程。而且如果每个进程运行无限小的时间周期也是不高效的——因为调度时进程抢占会带来一定的代价：将一个进程换出，另一个换入本身有消耗，同时还会影响到缓存的效率。因此虽然我们希望所有进程能只运行一个非常短的周期，但是CFS充分考虑了这将带来的额外消耗，实现中首先要确保系统性能不受损失。CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了，CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重:越高的nice值（越低的优先级）进程获得更低的处理器使用权重，这是相对默认nice值进程的进程而言的﹔相反，更低的nice值（越高的优先级）的进程获得更高的处理器使用权重。</p>
<p>每个进程都按其权重在全部可运行进程中所占比例的“时间片”来运行，为了计算准确的时间片，CFS为完美多任务中的无限小调度周期的近似值设立了一个目标。而这个目标称作“目标延迟”，越小的调度周期将带来越好的交互性，同时也更接近完美的多任务。但是也承受更高的切换代价和更差的系统总吞吐能力。</p>
<p>任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的。nice值对时间片的作用不再是算术加权，而是几何加权。CFS称为公平调度是因为它确保给每个进程公平间不再是一个绝对值，而是处理器的使用比。</p>
<p>CFS不是完美的公平，它只是近乎完美的多任务。确实在多进程环境下，降低了调度延迟带来的不公平性。</p>
<h2 id="3-Linux内核的下载、安装、编译"><a href="#3-Linux内核的下载、安装、编译" class="headerlink" title="3. Linux内核的下载、安装、编译"></a>3. Linux内核的下载、安装、编译</h2><h3 id="3-1-配置华为云ECS"><a href="#3-1-配置华为云ECS" class="headerlink" title="3.1 配置华为云ECS"></a>3.1 配置华为云ECS</h3><p>按照QQ群中的教程配置好服务器。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122125648.png" alt="image-20220706122125648" style="zoom:80%;" /></p>
<p>使用ssh命令登录。经过确认并输入密码后进入创建好的弹性云服务器中。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122034504.png" alt="图5 ssh登录" style="zoom:80%;" /></p>
<h3 id="3-2-内核的编译和安装"><a href="#3-2-内核的编译和安装" class="headerlink" title="3.2 内核的编译和安装"></a>3.2 内核的编译和安装</h3><h4 id="3-2-1-安装工具，构建开发环境"><a href="#3-2-1-安装工具，构建开发环境" class="headerlink" title="3.2.1 安装工具，构建开发环境"></a>3.2.1 安装工具，构建开发环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 ~] # yum group install -y &quot;Development Tools&quot;</span><br><span class="line">[root@c2200400109 ~] # yum install -y bc</span><br><span class="line">[root@c2200400109 ~]# yum install -y openssl-devel</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122556344.png" alt="图6 工具安装" style="zoom:80%;" /></p>
<h4 id="3-2-2-备份boot目录以防后续步骤更新内核失败"><a href="#3-2-2-备份boot目录以防后续步骤更新内核失败" class="headerlink" title="3.2.2 备份boot目录以防后续步骤更新内核失败"></a>3.2.2 备份boot目录以防后续步骤更新内核失败</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 ~] # tar czvf original_boot.tgz /boot/</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706122832856.png" alt="图7 备份boot目录" style="zoom:80%;" /></p>
<h4 id="3-2-3-获取内核源代码并解压"><a href="#3-2-3-获取内核源代码并解压" class="headerlink" title="3.2.3 获取内核源代码并解压"></a>3.2.3 获取内核源代码并解压</h4><p>获取内核源码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 ~] # wget https://gitee.com/openeuler/kernel/repository/archive/kernel-4.19.zip</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706123601521.png" alt="图8 获取内核源码" style="zoom:80%;" /></p>
<p>解压内核源代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 ~]# unzip kernel-4.19.zip</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706123804447.png" alt="图9 解压" style="zoom:80%;" /></p>
<h4 id="3-2-4-编译内核"><a href="#3-2-4-编译内核" class="headerlink" title="3.2.4 编译内核"></a>3.2.4 编译内核</h4><p>进入内核文件目录。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 kernel-kernel-4.19] # cd kernel-kernel-4.19/</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706124104408.png" alt="图10 编译内核" style="zoom:80%;" /></p>
<p>查看可编译的Image。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 kernel-kernel-4.19] # make help | grep Image</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706124202794.png" alt="图11 编译内核" style="zoom:80%;" /></p>
<p>编译内核的Image、modules和dtbs。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 kernel-kernel-4.19] # make openeuler_defconfig</span><br><span class="line">[root@c2200400109 kernel-kernel-4.19] # make -j4 Image modules dtbs</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706130223990.png" alt="图12 编译内核" style="zoom:80%;" /></p>
<h4 id="3-2-5-安装内核"><a href="#3-2-5-安装内核" class="headerlink" title="3.2.5 安装内核"></a>3.2.5 安装内核</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 kernel-kernel-4.19] # make modules_install</span><br><span class="line">[root@c2200400109 kernel-kernel-4.19] # make install</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133202184.png" alt="图13 安装内核" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133312671.png" alt="图14 安装内核" style="zoom:80%;" /></p>
<h3 id="3-3-内核启动"><a href="#3-3-内核启动" class="headerlink" title="3.3 内核启动"></a>3.3 内核启动</h3><p>使用VNC登录弹性云服务器。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706132756023.png" alt="图15 VNC登录" style="zoom:80%;" /></p>
<p>重启操作系统。在VNC窗口中选择新编译出的内核启动系统。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133719748.png" alt="图16 启动系统" style="zoom:80%;" /></p>
<p>查看内核是否更新。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@c2200400109 kernel-kernel-4.19] # uname -r</span><br></pre></td></tr></table></figure>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220706133852053.png" alt="图17 验证内核更新" style="zoom:80%;" /></p>
<p>Linux内核编译成功！</p>
<p>至此，Linux内核的下载、编译、安装全部过程完成。</p>
<h2 id="4-Linux堆内存管理"><a href="#4-Linux堆内存管理" class="headerlink" title="4. Linux堆内存管理"></a>4. Linux堆内存管理</h2><p>linux堆内存管理原理是什么？与windows系统的内存管理有何区别？</p>
<h3 id="4-1-Linux堆内存管理原理"><a href="#4-1-Linux堆内存管理原理" class="headerlink" title="4.1 Linux堆内存管理原理"></a>4.1 Linux堆内存管理原理</h3><p>linux下的进程堆管理提供两种分配方式，一个是brk()系统调用，另外一个是mmap()。brk的作用实际上就是设置进程数据段的结束地址，即它可以扩大或者缩小数据段。我们可以将数据段扩大的那一部分作为堆空间使用。mmap()的作用和windows下的VitualAlloc很相似，作用是向操作系统申请一段虚拟地址空间，当这块虚拟地址可以映射到某个文件的时候它的作用是共享内存，当它没有映射到文件的时候，那么这块虚拟地址空间成为匿名空间，可以被用来当做堆空间。</p>
<p>linux的堆内存管理分为三个层次，分别为分配区area、堆heap和内存块chunk。</p>
<p>area：堆内存最上层即为分配区area。分配区area分为主分配区（main area）和线程分配区（thread area）。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/650075-5a40190134864d49.png" alt="图5 Linux内存布局" style="zoom:80%;" /></p>
<h4 id="4-1-1-页"><a href="#4-1-1-页" class="headerlink" title="4.1.1 页"></a>4.1.1 页</h4><p>内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字（甚至字节)，但是，内存管理单元(MMU，管理内存并把虚拟地址转换为物理地址的硬件）通常以页为单位进行处理。正因为如此，MMU以页(page)大小为单位来管理系统中的页表（这也是页表名的来由)。从虚拟内存的角度来看，页就是最小单位。<br>体系结构不同，支持的页大小也不尽相同，还有些体系结构甚至支持几种不同的页大小。大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。这就意味着，在支持4KB页大小并有1GB物理内存的机器上，物理内存会被划分为262144个页。<br>内核用struct page结构表示系统中的每个物理页，该结构位于<linux/mm_types.h>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">atomic_t</span> _count ;</span><br><span class="line">	<span class="type">atomic_t</span> _mapcount ;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">	<span class="type">pgoff_t</span> index;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">	<span class="type">void</span> *virtual ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>count域存放页的引用计数——也就是这一页被引用了多少次。当计数值变为-1时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它。内核代码不应当直接检查该域，而是调用page_count()函数进行检查，该函数唯一的参数就是page结构。当页空闲时，尽管该结构内部的_count值是负的，但是对page_count()函数而言，返回0表示页空闲，返回一个正整数表示页在使用。一个页可以由页缓存使用（这时，mapping域指向和这个页关联的addresss_space对象)，或者作为私有数据（由private指向)，或者作为进程页表中的映射。</p>
<p>virtual域是页的虚拟地址。通常情况下，它就是页在虚拟内存中的地址。有些内存（即所谓的高端内存）并不永久地映射到内核地址空间上。在这种情况下，这个域的值为NULL，需要的时候，必须动态地映射这些页。稍后我们将讨论高端内存。</p>
<p>必须要理解的一点是page结构与物理页相关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个page结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关的物理页中存放的东西。这种数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。</p>
<p>内核用这一结构来管理系统中所有的页，因为内核需要知道一个页是否空闲（也就是页有没有被分配)。如果页已经被分配，内核还需要知道谁拥有这个页。拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存等。</p>
<h4 id="4-1-2-区"><a href="#4-1-2-区" class="headerlink" title="4.1.2 区"></a>4.1.2 区</h4><p>由于硬件的限制，内核并不能对所有的页一视同仁。有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区（zone)。内核使用区对具有相似特性的页进行分组。Linux必须处理如下两种由于硬件存在缺陷而引起的内存寻址问题:</p>
<ul>
<li>一些硬件只能用某些特定的内存地址来执行DMA（直接内存访问）。</li>
<li>一些体系结构的内存的物理寻址范围比虚拟寻址范围大得多。这样，就有一些内存不能永久地映射到内核空间上。</li>
</ul>
<h4 id="4-1-3-内存分配"><a href="#4-1-3-内存分配" class="headerlink" title="4.1.3 内存分配"></a>4.1.3 内存分配</h4><p>Linux把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如,ZONE_DMA内存池让内核有能力为DMA分配所需的内存。如果需要这样的内存，那么，内核就可以从ZONE_DMA中按照请求的数目取出页。注意，区的划分没有任何物理意义，这只不过是内核为了管理页而采取的一种逻辑上的分组。</p>
<p>某些分配可能需要从特定的区中获取页，而另外一些分配则可以从多个区中获取页。比如，尽管用于DMA的内存必须从ZONE_DMA中进行分配，但是一般用途的内存却既能从ZONE_DMA分配，也能从ZONE_NORMAL分配，不过不可能同时从两个区分配，因为分配是不能跨区界限的。当然，内核更希望一般用途的内存从常规区分配，这样能节省ZONE_DMA中的页，保证满足DMA的使用需求。但是，如果可供分配的资源不够用了（如果内存已经变得很少了),那么，内核就会去占用其他可用区的内存。</p>
<h3 id="4-2-与Windows内存管理区别"><a href="#4-2-与Windows内存管理区别" class="headerlink" title="4.2 与Windows内存管理区别"></a>4.2 与Windows内存管理区别</h3><p>windows的内存管理严格，使用内存必须首先分配，分为保留和提交两个阶段。其中保留阶段在进程的虚拟地址空间保留一块空间，不能用作他用。保留的概念是针对虚拟地址空间的，而提交的含义是将刚才保留的虚拟地址空间的虚拟内存块映射到物理内存，这里windows扩展了物理内存的含义，包括内存条代表的物理内存和磁盘页文件以及任何可以和真正的物理内存进行换入换出操作的后备存储，提交的概念其实就是一个映射，为了将虚拟内存变得可用而做的一个到实际物理存储的一个映射，就是将假的变真了。由于内存经常处于全部被使用的状态，则要先清理出一块内存，再分配给新的程序使用，因此，新程序的启动会慢一些。</p>
<p>linux没有为堆栈分配静态的大小，而是利用缺页中断使得堆栈在运行期动态增长，当然没有了固定的大小也就不存在溢出的问题了，只要虚拟内存足够，动态增长的需求就有可能被满足。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux-os/" rel="tag"># linux os</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/modern-algebra/modern-algebra/" rel="prev" title="近世代数">
      <i class="fa fa-chevron-left"></i> 近世代数
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E8%A3%85CentOS7"><span class="nav-text">安装CentOS7</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%88%BB%E5%BD%95"><span class="nav-text">镜像刻录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><span class="nav-text">系统安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E9%A1%B9"><span class="nav-text">引导项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2022Linux%E5%AE%9E%E9%AA%8C"><span class="nav-text">2022Linux实验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C1"><span class="nav-text">实验1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%BB%BA%E7%AB%8B%E7%94%A8%E6%88%B7%E8%B4%A6%E5%8F%B7"><span class="nav-text">一、建立用户账号</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">可能存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-text">二、文件管理操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#touch%E5%91%BD%E4%BB%A4"><span class="nav-text">touch命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rm%E5%91%BD%E4%BB%A4"><span class="nav-text">rm命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cp%E5%91%BD%E4%BB%A4"><span class="nav-text">cp命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mv%E5%91%BD%E4%BB%A4"><span class="nav-text">mv命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-text">三、目录管理操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ls%E5%91%BD%E4%BB%A4"><span class="nav-text">ls命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mkdir%E5%91%BD%E4%BB%A4"><span class="nav-text">mkdir命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#rmdir%E5%91%BD%E4%BB%A4"><span class="nav-text">rmdir命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#cd%E5%91%BD%E4%BB%A4"><span class="nav-text">cd命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%AE%A1%E7%90%86%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE"><span class="nav-text">四、管理使用与权限设置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#chmod%E5%91%BD%E4%BB%A4"><span class="nav-text">chmod命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chgrp%E5%91%BD%E4%BB%A4"><span class="nav-text">chgrp命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#chown%E5%91%BD%E4%BB%A4"><span class="nav-text">chown命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB%E4%B8%8E%E6%9F%A5%E6%89%BE"><span class="nav-text">五、文件阅读与查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB%E5%91%BD%E4%BB%A4"><span class="nav-text">1、文件阅读命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#cat%E5%91%BD%E4%BB%A4"><span class="nav-text">cat命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#more%E5%91%BD%E4%BB%A4"><span class="nav-text">more命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#less%E5%91%BD%E4%BB%A4"><span class="nav-text">less命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#head%E5%91%BD%E4%BB%A4"><span class="nav-text">head命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tail%E5%91%BD%E4%BB%A4"><span class="nav-text">tail命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4"><span class="nav-text">2、文件查找命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#find%E5%91%BD%E4%BB%A4"><span class="nav-text">find命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#grep%E5%91%BD%E4%BB%A4"><span class="nav-text">grep命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E7%B3%BB%E7%BB%9F%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-text">六、系统用户和组的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="nav-text">1、用户管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#useradd%E5%91%BD%E4%BB%A4%EF%BC%88%E9%85%8D%E5%90%88passwd%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">useradd命令（配合passwd命令使用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#usermod%E5%91%BD%E4%BB%A4"><span class="nav-text">usermod命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BB%84%E7%AE%A1%E7%90%86"><span class="nav-text">2、组管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#groupadd%E5%91%BD%E4%BB%A4"><span class="nav-text">groupadd命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#groupdel%E5%91%BD%E4%BB%A4"><span class="nav-text">groupdel命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90%E5%92%8C%E6%A3%80%E6%9F%A5"><span class="nav-text">七、网络配置与网络状态分析和检查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="nav-text">1、网络配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ifconfig%E5%91%BD%E4%BB%A4"><span class="nav-text">ifconfig命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#netstat%E5%91%BD%E4%BB%A4"><span class="nav-text">netstat命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E5%88%86%E6%9E%90"><span class="nav-text">2、网络状态分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ping%E5%91%BD%E4%BB%A4"><span class="nav-text">ping命令</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C2"><span class="nav-text">实验2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAshell%E8%84%9A%E6%9C%AC%E7%A8%8B%E5%BA%8F%EF%BC%9A%E8%BE%93%E5%85%A5%E5%9C%86%E5%8D%8A%E5%BE%84%E5%80%BC%EF%BC%8C%E8%BE%93%E5%87%BA%E5%9C%86%E9%9D%A2%E7%A7%AF%E7%9A%84%E5%80%BC"><span class="nav-text">1、创建一个shell脚本程序：输入圆半径值，输出圆面积的值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BC%96%E7%A8%8B%E6%B1%82%E8%A7%A3n%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C%EF%BC%8C%E8%A6%81%E6%B1%82n%E7%94%B1%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E5%AE%8C%E6%88%90"><span class="nav-text">2、编程求解n个数的和，要求n由键盘输入，使用循环语句完成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%88%A9%E7%94%A8for%E5%BE%AA%E7%8E%AF%E5%B0%86%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%8C%87%E5%AE%9A%E6%89%A9%E5%B1%95%E5%90%8D%EF%BC%88%E7%94%B1%E8%BE%93%E5%85%A5%E5%86%B3%E5%AE%9A%EF%BC%89%E6%96%87%E4%BB%B6%E8%BD%AC%E7%A7%BB%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E5%B9%B6%E6%8C%89%E7%85%A7%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%B9%B6%E6%98%BE%E7%A4%BA%E7%A7%BB%E5%8A%A8%E5%90%8E%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-text">三、利用for循环将当前目录下的指定扩展名（由输入决定）文件转移到指定的目录下，并按照文件大小排序，并显示移动后指定目录的内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2022Linux%E5%A4%A7%E4%BD%9C%E4%B8%9A"><span class="nav-text">2022Linux大作业</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%88%86%E6%9E%90ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86"><span class="nav-text">1. 分析ext4文件系统原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.1 虚拟文件系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="nav-text">1.2 ext4文件系统布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E8%B6%85%E7%BA%A7%E5%9D%97"><span class="nav-text">1.2.1 超级块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-%E5%9D%97%E7%BB%84%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="nav-text">1.2.2 块组描述符表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%9D%97%E4%BD%8D%E5%9B%BE%E5%92%8Cinode%E4%BD%8D%E5%9B%BE"><span class="nav-text">1.2.3 块位图和inode位图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-inode%E8%A1%A8"><span class="nav-text">1.2.4 inode表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.2.5 目录项对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-%E6%95%B0%E6%8D%AE%E5%9D%97"><span class="nav-text">1.2.6 数据块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%86%E6%9E%90Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%BA%90%E7%A0%81"><span class="nav-text">2. 分析Linux进程调度源码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99"><span class="nav-text">2.1 进程调度原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-CFS%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-text">2.2 CFS调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E6%97%B6%E9%97%B4%E8%AE%B0%E8%B4%A6"><span class="nav-text">2.2.1 时间记账</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%AE%9E%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-text">1.调度器实体结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%99%9A%E6%8B%9F%E5%AE%9E%E6%97%B6"><span class="nav-text">2.虚拟实时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-%E8%BF%9B%E7%A8%8B%E9%80%89%E6%8B%A9"><span class="nav-text">2.2.2 进程选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%8C%91%E9%80%89%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1"><span class="nav-text">1.挑选下一个任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%90%91%E6%A0%91%E4%B8%AD%E5%8A%A0%E5%85%A5%E8%BF%9B%E7%A8%8B"><span class="nav-text">2.向树中加入进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BB%8E%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">3.从树中删除进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%85%A5%E5%8F%A3"><span class="nav-text">2.2.3 调度器入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E7%9D%A1%E7%9C%A0%E5%92%8C%E5%94%A4%E9%86%92"><span class="nav-text">2.2.4 睡眠和唤醒</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%AD%89%E5%BE%85%E9%98%9F%E5%88%97"><span class="nav-text">1.等待队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%94%A4%E9%86%92"><span class="nav-text">2.唤醒</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-text">2.3 公平调度算法总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E4%B8%8B%E8%BD%BD%E3%80%81%E5%AE%89%E8%A3%85%E3%80%81%E7%BC%96%E8%AF%91"><span class="nav-text">3. Linux内核的下载、安装、编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E9%85%8D%E7%BD%AE%E5%8D%8E%E4%B8%BA%E4%BA%91ECS"><span class="nav-text">3.1 配置华为云ECS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%86%85%E6%A0%B8%E7%9A%84%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85"><span class="nav-text">3.2 内核的编译和安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%9E%84%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="nav-text">3.2.1 安装工具，构建开发环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E5%A4%87%E4%BB%BDboot%E7%9B%AE%E5%BD%95%E4%BB%A5%E9%98%B2%E5%90%8E%E7%BB%AD%E6%AD%A5%E9%AA%A4%E6%9B%B4%E6%96%B0%E5%86%85%E6%A0%B8%E5%A4%B1%E8%B4%A5"><span class="nav-text">3.2.2 备份boot目录以防后续步骤更新内核失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E8%8E%B7%E5%8F%96%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%A7%A3%E5%8E%8B"><span class="nav-text">3.2.3 获取内核源代码并解压</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="nav-text">3.2.4 编译内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E5%AE%89%E8%A3%85%E5%86%85%E6%A0%B8"><span class="nav-text">3.2.5 安装内核</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8"><span class="nav-text">3.3 内核启动</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">4. Linux堆内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86"><span class="nav-text">4.1 Linux堆内存管理原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-%E9%A1%B5"><span class="nav-text">4.1.1 页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E5%8C%BA"><span class="nav-text">4.1.2 区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-text">4.1.3 内存分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%B8%8EWindows%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB"><span class="nav-text">4.2 与Windows内存管理区别</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cheng</p>
  <div class="site-description" itemprop="description">my first blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cheng</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

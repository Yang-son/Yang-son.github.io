<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.gingkocyx.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="需要掌握功能特性（外特性） 内存：使用什么芯片计算机可以直接访问 $\begin{cases} RAM \\ ROM \\ \end{cases}$">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成原理：第4章 存储器">
<meta property="og:url" content="https://www.gingkocyx.top/computer_organization/computer-organization-ch4/index.html">
<meta property="og:site_name" content="gingkocyx">
<meta property="og:description" content="需要掌握功能特性（外特性） 内存：使用什么芯片计算机可以直接访问 $\begin{cases} RAM \\ ROM \\ \end{cases}$">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220113103102291.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132012588.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132029038.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132102239.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132141452.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220113105727882.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132213779.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302152419968.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132953214.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133219996.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133315990.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133343084.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133441283.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133518910.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133548297.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105355921.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105611033.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105635863.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105749956.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125100716032.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125100850329.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307165247384.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160517155.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160533664.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160558820.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309160958497.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309161157269.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309161451439.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125105813576.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128105943809.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309121524680.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309121612964.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309132525822.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309132622850.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316163138252.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128114909794.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115133016.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316165850524.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115441608.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171050903.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171111134.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115417652.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171737021.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309133933651.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165237238.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165142799.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165312839.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165345089.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165049480.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165015269.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164735646.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164735646.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164840004.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165743565.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165944751.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321170055398.png">
<meta property="og:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220130103055884.png">
<meta property="article:published_time" content="2022-03-21T11:06:17.000Z">
<meta property="article:modified_time" content="2022-03-25T13:52:39.618Z">
<meta property="article:author" content="Bob Cheng">
<meta property="article:tag" content="computer organization">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220113103102291.png">

<link rel="canonical" href="https://www.gingkocyx.top/computer_organization/computer-organization-ch4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机组成原理：第4章 存储器 | gingkocyx</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">gingkocyx</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">record every piece of life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.gingkocyx.top/computer_organization/computer-organization-ch4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bob Cheng">
      <meta itemprop="description" content="my first blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gingkocyx">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机组成原理：第4章 存储器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-21 19:06:17" itemprop="dateCreated datePublished" datetime="2022-03-21T19:06:17+08:00">2022-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-25 21:52:39" itemprop="dateModified" datetime="2022-03-25T21:52:39+08:00">2022-03-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2022-Spring/" itemprop="url" rel="index"><span itemprop="name">2022 Spring</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2022-Spring/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>46 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>需要掌握功能特性（外特性）</p>
<p>内存：使用什么芯片计算机可以直接访问 $\begin{cases} RAM \\ ROM \\ \end{cases}$</p>
<span id="more"></span>
<p>随机访问</p>
<p>存储器设计：</p>
<ul>
<li>设计-容量（按规定）</li>
<li>调试、证明</li>
<li>速度提高</li>
<li>可靠性4.1 概述</li>
</ul>
<p>【问题】</p>
<ol>
<li>存储器可分为哪些类型？</li>
<li>现代存储器的层次结构，为什么要分层？</li>
</ol>
<h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="一、存储器分类"><a href="#一、存储器分类" class="headerlink" title="一、存储器分类"></a>一、存储器分类</h3><h4 id="1-按存储介质分类"><a href="#1-按存储介质分类" class="headerlink" title="1.按存储介质分类"></a>1.按存储介质分类</h4><ul>
<li><p>半导体存储器（内存条芯片、U盘）——<strong>易失</strong></p>
<blockquote>
<p>TTL（集成度低，功耗高，高速）、MOS（主要）</p>
</blockquote>
</li>
<li><p>磁表面存储器（磁盘、磁带）——不易失</p>
<blockquote>
<p>基片表面磁层，分成若干个同心圆（磁道），分成若干个扇区（几百几K）</p>
</blockquote>
</li>
<li><p>磁芯存储器——不易失</p>
<blockquote>
<p>（1948，王安）</p>
<p>磁芯里面有导线，在电流作用下磁化，用于保存两个状态。硬磁材料、环状元件。</p>
</blockquote>
</li>
<li><p>光盘存储器——激光、磁光材料</p>
</li>
</ul>
<h4 id="2-按存取方式分类"><a href="#2-按存取方式分类" class="headerlink" title="2.按存取方式分类"></a>2.按存取方式分类</h4><ul>
<li><p>存取时间与物理地址无关（<strong>随机访问</strong>）</p>
<ul>
<li><p>随机存储器（$RAM$, Random Access Memory）：在程序执行过程中<strong>可读/可写</strong></p>
<blockquote>
<p>存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关</p>
<p>计算机系统的主存采用这种随机存储器</p>
</blockquote>
<p>$根据存储信息原理不同\begin{cases} 静态RAM（SRAM,static RAM）\\ \qquad ——以触发器原理寄存信息 ——Cache \\ 动态RAM（DRAM, dynamic RAM）\\ \qquad ——以电容充放电原理寄存信息——主存 \end{cases}$</p>
</li>
<li><p>只读存储器（$ROM$, Read Only Memory）：在程序执行过程中<strong>只读</strong></p>
<blockquote>
<p>能对其存储的内容读出，而不能对其重新写入的存储器。</p>
<p>一旦存储了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写入新的信息去改变原始信息。</p>
<p>通常存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。——BIOS，基本操作系统，初始化程序、检测程序（故障检测）</p>
</blockquote>
<p>它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。</p>
<p>$\begin{cases} 掩膜型只读存储器 \\（MROM, \ Masked \ ROM）\\ 可编程只读存储器 \\（PROM, \ Programmable \ ROM）\\ —— 烧录一次\\ 可擦除可编程只读存储器 \\（EPROM,\ Erasable \ Programmable \ ROM）\\ ——使用紫外线照射可以擦除。可擦写10000次以上 \\ 用电可擦除可编程只读存储器 \\（EEPROM,\ Electrically \ Erasable \  Programmable \ ROM） \\  —— 可再现（计算机攻击、病毒）\end{cases}$</p>
<p>闪速存储器（Flash Memory）：具有EEPROM的特点，而速度比EEPROM快得多</p>
</li>
</ul>
</li>
<li><p>存取时间与物理地址有关（串行访问）</p>
<ul>
<li><p>顺序存取存储器——磁带</p>
<blockquote>
<p>无论信息处在哪个位置，读/写必须从其介质的始端开始按顺序寻找</p>
</blockquote>
</li>
<li><p>直接存取存储器——磁盘</p>
<blockquote>
<p>属于部分串行访问的存储器</p>
<p>在对磁盘读/写时，首先直接指出该存储器中的某个小区域（<strong>磁道</strong>），然后再按顺序寻访，直到找到位置</p>
<p>前段是直接访问，后段是串行访问</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="3-按在计算机中的作用分类"><a href="#3-按在计算机中的作用分类" class="headerlink" title="3.按在计算机中的作用分类"></a>3.按在计算机中的作用分类</h4><ul>
<li><strong>主存储器</strong>（主存）：可以和CPU直接交换信息</li>
<li><strong>辅助存储器</strong>（辅存）：主存的后援存储器，用来存放当前暂时不用的程序和数据，不能与CPU直接交换信息</li>
<li><strong>缓冲存储器</strong>（缓存）：用在两个速度不同的部件之中</li>
</ul>
<blockquote>
<p>CPU与主存之间可设置一个高速缓存（Cache），起到缓冲作用——SRAM，存取速度快、价格更昂贵、集成度较低</p>
<p>DRAM一般用于主存储器</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220113103102291.png" alt="image-20220113103102291" style="zoom: 67%;" /></p>
<h3 id="二、存储器的层次结构"><a href="#二、存储器的层次结构" class="headerlink" title="二、存储器的层次结构"></a>二、存储器的层次结构</h3><h4 id="1-存储器三个主要特性的关系"><a href="#1-存储器三个主要特性的关系" class="headerlink" title="1.存储器三个主要特性的关系"></a>1.存储器三个主要特性的关系</h4><p>速度、容量、价格/位</p>
<blockquote>
<p>寄存器分组成堆，彼此之间不产生冲突</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132012588.png" alt="image-20220302132012588" style="zoom:67%;" /></p>
<h4 id="2-缓存-主存层次和主存-辅存层次（存储体系）"><a href="#2-缓存-主存层次和主存-辅存层次（存储体系）" class="headerlink" title="2.缓存-主存层次和主存-辅存层次（存储体系）"></a>2.缓存-主存层次和主存-辅存层次（存储体系）</h4><p>程序的局部性原理</p>
<ul>
<li><p>缓存-主存层次</p>
<ul>
<li><p>主要解决<strong>CPU和主存速度不匹配</strong>的问题。</p>
</li>
<li><p>缓存速度比主存高。将CPU近期要用的信息<strong>调入缓存</strong>，CPU便可以直接从缓存中获取信息，从而提高访存的速度。</p>
</li>
<li><p><strong>缓存容量小</strong>，需要不断将主存的内容调入缓存，使缓存中原来的信息被替换掉</p>
</li>
<li>主存和缓存的数据调动是<strong>硬件自动完成</strong>的，对程序员透明</li>
<li>使用了缓存的速度，容量和价位接近于主存</li>
</ul>
</li>
<li><p>主存-辅存层次</p>
<ul>
<li>主要解决<strong>存储系统容量</strong>的问题</li>
<li>辅存的速度比主存低，而且不能和CPU直接交换信息。但<strong>容量比主存大得多，可以存放大量暂时没有用到的信息</strong>。当CPU需要用这些信息时，再<strong>将辅存的内容调到主存</strong>，供CPU直接访问</li>
<li>主存和辅存之间的数据调动是由<strong>硬件和操作系统共同完成</strong>的——I/O线</li>
<li>使用了主存的速度，容量和价位接近于辅存</li>
</ul>
</li>
<li><p>主存-辅存层次逐渐形成了虚拟存储系统</p>
<p>（计算机体系结构、操作系统）</p>
<ul>
<li>程序员<strong>编程的地址范围</strong>与<strong>虚拟存储器的地址空间</strong>相对应</li>
</ul>
<blockquote>
<p>指令地址码——虚地址（虚存地址、虚拟地址）或逻辑地址</p>
<p>主存的实际地址——物理地址或实地址</p>
</blockquote>
<p>物理地址是程序在执行过程中能够真正访问的地址</p>
<p>对于程序员，可用的地址空间远远大于主存空间，使程序员以为自己占有一个容量极大的主存，实际这个主存不存在</p>
<p>当虚地址的内容在主存时，机器可以立即使用；虚地址内容不在主存，必须先将此虚地址的内容传递到主存的合适单元后再为机器所用</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132029038.png" alt="image-20220302132029038" style="zoom:67%;" /></p>
<h2 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-主存的基本组成"><a href="#1-主存的基本组成" class="headerlink" title="1.主存的基本组成"></a>1.主存的基本组成</h4><p>根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。</p>
<p>读出时，需经过读出放大器，才能将被选中单元的存储字送到MDR；</p>
<p>写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中的单元中。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132102239.png" alt="image-20220302132102239" style="zoom:67%;" /></p>
<blockquote>
<p>对于控制电路而言，读和写命令的优先级相同，因此不会出现两个信号都使能的情况。</p>
<p>在设计上，同一时刻最多有一个信号有效（低电平）。都为低电平为无效状态</p>
</blockquote>
<h4 id="2-主存和CPU的联系"><a href="#2-主存和CPU的联系" class="headerlink" title="2.主存和CPU的联系"></a>2.主存和CPU的联系</h4><p>通过三种类型的信号进行联系</p>
<blockquote>
<p>当要从存储器读出某一信息字时，</p>
<ul>
<li><p>首先由CPU将该字的地址送到MAR，经地址总线送至主存，然后发出读命令。</p>
</li>
<li><p>主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读到数据总线上</p>
</li>
</ul>
<p>当存储器要向主存存入一个信息字时，</p>
<ul>
<li><p>首先CPU将该字所在主存单元的地址经MAR送到地址总线，并将信息字送入MDR，然后向主存发出写命令。</p>
</li>
<li><p>主存接到写命令后，便将数据线上的信息写入到对应地址线指出的内存单元中。</p>
</li>
</ul>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132141452.png" alt="image-20220302132141452" style="zoom:67%;" /></p>
<h4 id="3-主存中存储单元地址的分配"><a href="#3-主存中存储单元地址的分配" class="headerlink" title="3.主存中存储单元地址的分配"></a>3.主存中存储单元地址的分配</h4><p>图中，纵为字地址，横为字节地址。</p>
<p>无论计算机的字长怎么变化，只会影响按字寻址的长度，不会影响存储空间的大小</p>
<p>大端法和小端法</p>
<ul>
<li><p>大端法：<strong>高位字节</strong>地址为字地址</p>
<blockquote>
<p>左图中的12对应的字节地址（大端地址）为字地址</p>
</blockquote>
</li>
<li><p>小端法：<strong>低位字节</strong>地址为字地址</p>
<blockquote>
<p>右图中的78对应的字节地址（小端地址）为字地址</p>
</blockquote>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220113105727882.png" alt="image-20220113105727882" style="zoom: 67%;" /></p>
<blockquote>
<p>$24$根地址线，按<strong>字节</strong>寻址：$2^{24} = 16MB$</p>
<p>字长为$16$位，按<strong>字</strong>寻址：$8MW$</p>
<p>字长为$32$位，按<strong>字</strong>寻址：$4MW$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132213779.png" alt="image-20220302132213779" style="zoom:67%;" /></p>
<p>如何区分“按字节寻址”和“按字寻址”？</p>
<p>【参考资料】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25297587/article/details/89818719">按字寻址和按字节寻址</a></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302152419968.png" alt="image-20220302152419968" style="zoom:67%;" /></p>
<h4 id="4-主存的技术指标"><a href="#4-主存的技术指标" class="headerlink" title="4.主存的技术指标"></a>4.主存的技术指标</h4><p><strong>存储容量</strong>：主存<strong>存放二进制代码的总位数</strong></p>
<p><strong>存储速度</strong>：</p>
<ul>
<li><p>存取时间（$Memory$ $Access$ $ Time$）：存储器的<strong>访问时间</strong>$\begin{cases} 读出时间 \\ 写入时间 \\ \end{cases}$</p>
<ul>
<li>读出时间——给出地址信号到数据线上稳定的输出</li>
<li>写入时间——给出地址信号到数据写入到给定的地址单元中</li>
</ul>
</li>
<li><p>存取周期（$Memory$  $Cycle$  $Time$）：<strong>连续两次独立的存储器操作</strong>。（读或写）所需的<strong>最小间隔时间</strong></p>
<p>​    $\begin{cases} 读周期 \\ 写周期 \\ \end{cases}$</p>
<blockquote>
<p>现代MOS型存储器的存取周期可达100ns，双极型TTL存储器的存取周期接近于10ns</p>
</blockquote>
<ul>
<li>存取时间比存取周期短</li>
</ul>
<p>【参考资料】：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40627648/article/details/83626288">计算机组成原理补充——三种刷新方式，存取周期＞存取时间的原因</a>）</p>
</li>
</ul>
<p><strong>存储器的带宽</strong>：<strong>位/秒</strong></p>
<p>与存取周期密切相关。表示单位时间内存储区存取的信息量</p>
<blockquote>
<p>如，存取周期$500ns$，每个存取周期可访问$16$位，则带宽为$32M位/秒$</p>
</blockquote>
<h5 id="提高存储器带宽的措施"><a href="#提高存储器带宽的措施" class="headerlink" title="提高存储器带宽的措施"></a>提高存储器带宽的措施</h5><ul>
<li>缩短存取周期</li>
<li>增加存储字长，使每个存取周期可读/写更多的二进制位数</li>
<li>增加存储体</li>
</ul>
<h3 id="二、半导体存储芯片简介"><a href="#二、半导体存储芯片简介" class="headerlink" title="二、半导体存储芯片简介"></a>二、半导体存储芯片简介</h3><p>内存在存储器中唯一 $\begin{cases} 地址：一般是CPU低位地址寻找芯片内的位置 \\ 片选：对应CPU的地址译码。芯片之间  \end{cases}$</p>
<p>数据：单元内容</p>
<p>读写控制</p>
<p>电压VCC和接地GND</p>
<h4 id="1-半导体存储芯片的基本结构"><a href="#1-半导体存储芯片的基本结构" class="headerlink" title="1.半导体存储芯片的基本结构"></a>1.半导体存储芯片的基本结构</h4><blockquote>
<p>地址线涉及空间分配，在内存的什么地方</p>
</blockquote>
<p>包括存储矩阵（01代码）、译码驱动（地址线）、读写电路（数据线）</p>
<p>还有芯片选择线（判断）、读写控制线</p>
<p>片选线：$\overline{CS}（selected）、\overline{CE}（enabled）$</p>
<p>读/写控制线：$\overline{WE}$（低电平时进行写操作，高电平读）、$\overline{OE}$（允许读）、$\overline{WE}$（允许写）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132953214.png" alt="image-20220302132953214" style="zoom:67%;" /></p>
<h5 id="存储芯片片选线的作用"><a href="#存储芯片片选线的作用" class="headerlink" title="存储芯片片选线的作用"></a>存储芯片片选线的作用</h5><p>可以让某一个或某一些芯片同时作用</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133219996.png" alt="image-20220302133219996" style="zoom:67%;" /></p>
<h4 id="2-半导体存储芯片的译码驱动方式"><a href="#2-半导体存储芯片的译码驱动方式" class="headerlink" title="2.半导体存储芯片的译码驱动方式"></a>2.半导体存储芯片的译码驱动方式</h4><h5 id="（1）线选法"><a href="#（1）线选法" class="headerlink" title="（1）线选法"></a>（1）线选法</h5><p>$4$位地址，决定$2^4 = 16$根地址线上的$8$位数据</p>
<blockquote>
<p>用一根字选择线（字线），直接选中一个存储单元的各位（如一个字节）</p>
<p>结构较简单，但只适于容量不大的存储芯片</p>
<p>如当$A_3A_2A_1A_0$为1111时，则第15根字线被选中，对应最后一行的8位代码可直接读出或写入</p>
</blockquote>
<p>地址线从一个方向送过来，控制一行的芯片——译码器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133315990.png" alt="image-20220302133315990" style="zoom:67%;" /></p>
<h5 id="（2）重合法"><a href="#（2）重合法" class="headerlink" title="（2）重合法"></a>（2）重合法</h5><p>$X、Y$各$5$根地址线，构成了$2^5 \times 2^5 = 32 \times 32$的矩阵。每个地址对应$1$位的数据</p>
<blockquote>
<p>被选单元是由X、Y两个方向的地址决定的</p>
<p>例如，当地址线全0时，译码输出$X_0$和$Y_0$有效，矩阵中的第0行、第0列共同选中的那位即被选中</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133343084.png" alt="image-20220302133343084" style="zoom:67%;" /></p>
<h3 id="三、随机存取存储器（RAM）"><a href="#三、随机存取存储器（RAM）" class="headerlink" title="三、随机存取存储器（RAM）"></a>三、随机存取存储器（RAM）</h3><h4 id="1-静态RAM（SRAM）"><a href="#1-静态RAM（SRAM）" class="headerlink" title="1.静态RAM（SRAM）"></a>1.静态RAM（SRAM）</h4><h5 id="（1）静态RAM基本电路"><a href="#（1）静态RAM基本电路" class="headerlink" title="（1）静态RAM基本电路"></a>（1）静态RAM基本电路</h5><p>存储器中用于寄存“0”和“1”代码的电路，下图是一个由6个MOS管组成的基本单元电路</p>
<blockquote>
<p>$T_1$-$T_4$是一个由MOS管组成的触发器的基本电路，$T_5$、$T_6$犹如一个开关，受行地址选择信号控制。$T_1$-$T_6$共同构成一个基本单元电路。</p>
<p>$T_7$、$T_8$受列地址选择控制，分别与位线$A’$和$A$相连。不属于基本电路内的部件，芯片内同一列的各个基本电路所共有。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133441283.png" alt="image-20220302133441283" style="zoom:67%;" /></p>
<h6 id="①静态RAM基本电路的读操作"><a href="#①静态RAM基本电路的读操作" class="headerlink" title="①静态RAM基本电路的读操作"></a>①静态RAM基本电路的读操作</h6><blockquote>
<p>给出行选和列选信号 $\to$ 读选择有效 $\to$ 读放</p>
</blockquote>
<p>假设触发器已有“1”信号，即A点高电平。</p>
<ul>
<li>当需要读出时，只要使行、列地址选择信号均有效，$T_5$、$T_6$、$T_7$、$T_8$均导通，</li>
<li>A点高电平通过$T_6$后，再由位线通过$T_8$作为读放大器的输入信号，</li>
<li>在读选择有效时，将“1”信号读出</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133518910.png" alt="image-20220302133518910" style="zoom:67%;" /></p>
<p>静态RAM是用触发器原理存储信息，因此即使信息读出后，它仍保持其原状态，不需要再生。但电源掉电后，原存信息丢失，属于<strong>易失性半导体存储器</strong></p>
<h6 id="②静态RAM基本电路的写操作"><a href="#②静态RAM基本电路的写操作" class="headerlink" title="②静态RAM基本电路的写操作"></a>②静态RAM基本电路的写操作</h6><blockquote>
<p>行地址选择信号有效，列地址选择信号有效 （低电平）$\to $ 写选择信号有效 $\to$ 数据经过$D_{IN}$通过写放大器进入$A’$和$A$</p>
<p>由于两个写放大器相反，保证信号不同。</p>
</blockquote>
<ul>
<li>写入时不论触发器原状态如何，只要将写入代码送至$D_{IN}$端，</li>
<li>在写选择有效时，经两个写放大器，使两端输出相反电平，</li>
<li>这样，就欲把写入的信息写入到该基本单元电路中。</li>
</ul>
<blockquote>
<p>如欲写入“1“，即$D_{IN}$ = 1，经两个写放大器使位线$A$为高电平，位线$A’$为低电平，结果使$A$点为高，$A’$点为低，即写入了”1“信息。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133548297.png" alt="image-20220302133548297" style="zoom:67%;" /></p>
<h5 id="（2）静态RAM芯片举例"><a href="#（2）静态RAM芯片举例" class="headerlink" title="（2）静态RAM芯片举例"></a>（2）静态RAM芯片举例</h5><h6 id="①Intel-2114外特性"><a href="#①Intel-2114外特性" class="headerlink" title="①Intel 2114外特性"></a>①Intel 2114外特性</h6><p>$\overline{WE}$复用，低电平为写，高电平为读</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105355921.png" alt="image-20220307105355921" style="zoom: 67%;" /></p>
<h6 id="②Intel-2114-RAM矩阵（64-times-64）读"><a href="#②Intel-2114-RAM矩阵（64-times-64）读" class="headerlink" title="②Intel 2114 RAM矩阵（64 $\times$ 64）读"></a>②Intel 2114 RAM矩阵（64 $\times$ 64）读</h6><h6 id="③Intel-2114-RAM矩阵（64-times-64）写"><a href="#③Intel-2114-RAM矩阵（64-times-64）写" class="headerlink" title="③Intel 2114 RAM矩阵（64 $\times$ 64）写"></a>③Intel 2114 RAM矩阵（64 $\times$ 64）写</h6><h5 id="（3）静态RAM读时序"><a href="#（3）静态RAM读时序" class="headerlink" title="（3）静态RAM读时序"></a>（3）静态RAM读时序</h5><p>在整个读周期中，$\overline{WE}$始终为高电平。</p>
<p><strong>读周期</strong>$t_{RC}$是指<strong>对芯片进行两次连续读操作的最小间隔时间</strong></p>
<p><strong>读时间</strong>$t_A$表示<strong>从地址有效到数据稳定所需的时间</strong>，显然读时间小于读周期</p>
<p>图中$t_{CO}$是从片选有效到数据稳定的时间</p>
<blockquote>
<p>只有当地址有效经$t_A$后，且当片选有效经$t_{CO}$后，数据才能稳定输出，二者必须同时具备</p>
<p>根据$t_A$和$t_{CO}$的值，便可知当地址有效后经$t_A$-$t_{CO}$时间必须给出片选有效信号，否则信号不能出现在数据线上</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105611033.png" alt="image-20220307105611033" style="zoom:67%;" /></p>
<p>注意：<strong>从片选失效到输出高阻需一段时间$t_{OTD}$，故地址失效后，数据线上的有效数据有一段维持时间$t_{OTA}$，以保证所读的数据可靠</strong></p>
<h5 id="（4）静态RAM写时序"><a href="#（4）静态RAM写时序" class="headerlink" title="（4）静态RAM写时序"></a>（4）静态RAM写时序</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105635863.png" alt="image-20220307105635863" style="zoom:67%;" /></p>
<p>写周期$t_{WC}$是对芯片进行连续两次写操作的最小间隔时间</p>
<p>写周期包括滞后时间$t_{AW}$、写入时间$t_w$和写恢复时间$t_{WR}$</p>
<blockquote>
<p>在有效数据出现前，RAM的数据线上存在着前一时刻的数据$D_{OUT}$，故在地址线发生变化后，$\overline{CS}$、$\overline{WE}$均需滞后$t_{AW}$再有效，以避免将无效数据写入RAM的错误。</p>
<p>但写允许$\overline{WE}$失效后，地址必须保持一段时间，称为写恢复时间。</p>
<p>此外，RAM数据线上的有效数据（即CPU送至RAM的写入数据$D_{IN}$）必须在$\overline{CS}$、$\overline{WE}$失效前的$t_{DW}$时刻出现，并延续一段时间$t_{DH}$（此刻地址线仍有效，$t_{WR} &gt; t_{DH}$），以保证数据可靠写入。（采样点）</p>
</blockquote>
<p>SRAM总结：触发器原理。写入数据后一直保持，直至下次写入</p>
<h4 id="2-动态RAM（DRAM）——了解内容"><a href="#2-动态RAM（DRAM）——了解内容" class="headerlink" title="2.动态RAM（DRAM）——了解内容"></a>2.动态RAM（DRAM）——了解内容</h4><p>【问题】</p>
<ul>
<li>保存0和1的原理是什么？——电容（保存电荷——保存信息，有电1）</li>
<li>基本单元电路的构成是什么？</li>
<li>对单元电路如何读出和写入？</li>
<li>典型芯片的结构是什么样子？</li>
<li>动态RAM芯片如何进行读出和写入操作？</li>
<li>动态RAM为什么要刷新，刷新方法？</li>
</ul>
<h5 id="（1）动态RAM基本单元电路"><a href="#（1）动态RAM基本单元电路" class="headerlink" title="（1）动态RAM基本单元电路"></a>（1）动态RAM基本单元电路</h5><p>电容记录0和1。带有电荷电路特点：电荷2ms内维持，之后变化归零。因此需要再生（刷新）电路</p>
<p>SRAM则是4个三极管，利用触发器原理</p>
<ul>
<li>$C_s$表示与电荷带电有关<ul>
<li>读出相反，写入相同</li>
</ul>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105749956.png" alt="image-20220307105749956" style="zoom:67%;" /></p>
<h5 id="（2）动态RAM芯片举例"><a href="#（2）动态RAM芯片举例" class="headerlink" title="（2）动态RAM芯片举例"></a>（2）动态RAM芯片举例</h5><p>①三管动态RAM芯片（Intel 1103）读</p>
<p>②三管动态RAM芯片（Intel 1103）写</p>
<p>③单管动态RAM 4116（16K $\times$ 1位）外特性</p>
<p>④4116（16K $\times$ 1位）芯片读原理</p>
<p>⑤4116（16K $\times$ 1位）芯片写原理</p>
<h5 id="（3）动态RAM时序"><a href="#（3）动态RAM时序" class="headerlink" title="（3）动态RAM时序"></a>（3）动态RAM时序</h5><p><strong>行、列地址分开传送</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">读时序</th>
<th style="text-align:center">写时序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">行地址$\overline{RAS}$有效</td>
<td style="text-align:center">行地址$\overline{RAS}$有效</td>
</tr>
<tr>
<td style="text-align:center">写允许$\overline{WE}$有效（高）</td>
<td style="text-align:center">写允许$\overline{WE}$有效（低）</td>
</tr>
<tr>
<td style="text-align:center">列地址$\overline{CAS}$有效</td>
<td style="text-align:center">数据$\overline{D_{IN}}$有效</td>
</tr>
<tr>
<td style="text-align:center">数据$\overline{D_{OUT}}$有效</td>
<td style="text-align:center">列地址$\overline{CAS}$有效</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（4）动态RAM刷新"><a href="#（4）动态RAM刷新" class="headerlink" title="（4）动态RAM刷新"></a>（4）动态RAM刷新</h5><p><strong>刷新与行地址有关</strong></p>
<h6 id="①集中刷新（存取周期为0-5μs）：专时专用"><a href="#①集中刷新（存取周期为0-5μs）：专时专用" class="headerlink" title="①集中刷新（存取周期为0.5μs）：专时专用"></a>①集中刷新（存取周期为0.5μs）：专时专用</h6><ul>
<li>“死区”、“死时间率”</li>
</ul>
<p>以128$\times$128矩阵为例</p>
<h6 id="②分散刷新（存取周期为1μs）：频繁刷新"><a href="#②分散刷新（存取周期为1μs）：频繁刷新" class="headerlink" title="②分散刷新（存取周期为1μs）：频繁刷新"></a>②分散刷新（存取周期为1μs）：频繁刷新</h6><ul>
<li>无“死区”</li>
</ul>
<p>以128$\times$128矩阵为例</p>
<h6 id="③异步刷新（分散刷新与集中刷新相结合）"><a href="#③异步刷新（分散刷新与集中刷新相结合）" class="headerlink" title="③异步刷新（分散刷新与集中刷新相结合）"></a>③异步刷新（分散刷新与集中刷新相结合）</h6><ul>
<li>每行每隔2ms刷新一次</li>
<li>每一段为集中刷新，整体来看是分散刷新</li>
</ul>
<h4 id="3-动态RAM和静态RAM的比较（重点）"><a href="#3-动态RAM和静态RAM的比较（重点）" class="headerlink" title="3.动态RAM和静态RAM的比较（重点）"></a>3.动态RAM和静态RAM的比较（重点）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">DRAM（主存）</th>
<th style="text-align:center">SRAM（缓存）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>存储原理</strong></td>
<td style="text-align:center">电容</td>
<td style="text-align:center">触发器</td>
</tr>
<tr>
<td style="text-align:center"><strong>集成度</strong></td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center"><strong>芯片引脚</strong></td>
<td style="text-align:center">少</td>
<td style="text-align:center">多</td>
</tr>
<tr>
<td style="text-align:center"><strong>功耗</strong></td>
<td style="text-align:center">小</td>
<td style="text-align:center">大</td>
</tr>
<tr>
<td style="text-align:center"><strong>价格</strong></td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center"><strong>速度</strong></td>
<td style="text-align:center">慢</td>
<td style="text-align:center">快</td>
</tr>
<tr>
<td style="text-align:center"><strong>刷新</strong></td>
<td style="text-align:center">有</td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="四、只读存储器（ROM）——了解内容"><a href="#四、只读存储器（ROM）——了解内容" class="headerlink" title="四、只读存储器（ROM）——了解内容"></a>四、只读存储器（ROM）——了解内容</h3><h4 id="1-掩膜ROM（MROM"><a href="#1-掩膜ROM（MROM" class="headerlink" title="1.掩膜ROM（MROM)"></a>1.掩膜ROM（MROM)</h4><ul>
<li>行列选择器交叉处有MOS管为“1”</li>
<li>行列选择器交叉处无MOS管为“0”</li>
</ul>
<h4 id="2-PROM（一次性编程）"><a href="#2-PROM（一次性编程）" class="headerlink" title="2.PROM（一次性编程）"></a>2.PROM（一次性编程）</h4><p>优点：程序完成后保持稳定的状态</p>
<p>但是若修改需要更换芯片</p>
<ul>
<li>熔丝断为“0”</li>
<li>熔丝未断为“1”</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125100716032.png" alt="image-20220125100716032" style="zoom:80%;" /></p>
<h4 id="3-EPROM（多次性编程）"><a href="#3-EPROM（多次性编程）" class="headerlink" title="3.EPROM（多次性编程）"></a>3.EPROM（多次性编程）</h4><h5 id="（1）N型沟道浮动栅MOS电路"><a href="#（1）N型沟道浮动栅MOS电路" class="headerlink" title="（1）N型沟道浮动栅MOS电路"></a>（1）N型沟道浮动栅MOS电路</h5><p>浮动栅使用<strong>紫外线</strong>照射5-10分钟进行擦除，需要芯片脱离CPU/系统，离线到EPROM编程器照射</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125100850329.png" alt="image-20220125100850329" style="zoom:80%;" /></p>
<h5 id="（2）2716-EPROM的逻辑图和引脚图"><a href="#（2）2716-EPROM的逻辑图和引脚图" class="headerlink" title="（2）2716 EPROM的逻辑图和引脚图"></a>（2）2716 EPROM的逻辑图和引脚图</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307165247384.png" alt="image-20220307165247384" style="zoom:67%;" /></p>
<h4 id="4-EEPROM（多次性编程）"><a href="#4-EEPROM（多次性编程）" class="headerlink" title="4.EEPROM（多次性编程）"></a>4.EEPROM（多次性编程）</h4><ul>
<li>电可擦写</li>
<li>局部擦写</li>
<li>全部擦写</li>
</ul>
<h4 id="5-Flash-Memory（闪速型存储器）"><a href="#5-Flash-Memory（闪速型存储器）" class="headerlink" title="5.Flash Memory（闪速型存储器）"></a>5.Flash Memory（闪速型存储器）</h4><ul>
<li>EPROM——价格便宜、集成度高</li>
<li>EEPROM——电可擦洗重写</li>
<li>比EEPROM快，具备RAM功能</li>
</ul>
<h3 id="五、存储器与CPU的连接（重点和难点）"><a href="#五、存储器与CPU的连接（重点和难点）" class="headerlink" title="五、存储器与CPU的连接（重点和难点）"></a>五、存储器与CPU的连接（重点和难点）</h3><p>（本节的重点和难点）</p>
<h4 id="1-存储器容量的扩展"><a href="#1-存储器容量的扩展" class="headerlink" title="1.存储器容量的扩展"></a>1.存储器容量的扩展</h4><p>包括<strong>位扩展、字扩展、字位扩展</strong></p>
<ul>
<li>位扩展（增加存储字长）</li>
<li>字扩展（增加存储字的数量）</li>
<li>字、位扩展</li>
</ul>
<h5 id="（1）位扩展"><a href="#（1）位扩展" class="headerlink" title="（1）位扩展"></a>（1）位扩展</h5><p>【例】用2片1K×4位存储芯片组成1K×8位的存储器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160517155.png" alt="image-20220316160517155" style="zoom:50%;" /></p>
<h5 id="（2）字扩展"><a href="#（2）字扩展" class="headerlink" title="（2）字扩展"></a>（2）字扩展</h5><p>增加存储单元的个数</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160533664.png" alt="image-20220316160533664" style="zoom:50%;" /></p>
<h5 id="（3）字、位扩展"><a href="#（3）字、位扩展" class="headerlink" title="（3）字、位扩展"></a>（3）字、位扩展</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160558820.png" alt="image-20220316160558820" style="zoom:50%;" /></p>
<h4 id="2-存储器与CPU连接"><a href="#2-存储器与CPU连接" class="headerlink" title="2.存储器与CPU连接"></a>2.存储器与CPU连接</h4><ol>
<li><p>地址线的连接</p>
</li>
<li><p>数据线的连接</p>
</li>
<li><p>读/写命令线的连接——控制</p>
<p>需要地址、数据、控制总线</p>
</li>
<li><p>片选线的连接</p>
<p>地址线</p>
</li>
<li><p>合理选择存储芯片——芯片的性质（可读可写/只读）</p>
<ul>
<li>配置文件使用ROM</li>
<li>可读可写使用RAM</li>
</ul>
</li>
<li><p>其他：时序（性能选择，如主频总线和CPU不同）、负载、干扰</p>
</li>
</ol>
<h4 id="【例4-1】（P94）"><a href="#【例4-1】（P94）" class="headerlink" title="【例4-1】（P94）"></a>【例4-1】（P94）</h4><blockquote>
<p>给出内存的一部分，开始的地址和截止的地址，未告知空间大小——需要自己查</p>
<p>给出系统的性质（系统程序/工作区和用户程序）</p>
</blockquote>
<p>系统程序——ROM；用户程序/程序工作区——RAM</p>
<ul>
<li><p>地址</p>
<p><strong>不变的地址为片选地址，变化的为片内地址</strong></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309160958497.png" alt="image-20220309160958497" style="zoom:50%;" /></p>
<p>只读存储器用于系统工作区，随机存储区用于程序工作区</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309161157269.png" alt="image-20220309161157269" style="zoom:50%;" /></p>
<p>芯片地址要和CPU地址一一对应，剩余地址进行片选</p>
<blockquote>
<p>$A_{13}, A_{12},A_{11}用于片选$</p>
<p>注意输入端不悬空</p>
<p>$\overline{MREQ}$和$\overline{WR}$协作，控制读操作和写操作</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309161451439.png" alt="image-20220309161451439" style="zoom:50%;" /></p>
<blockquote>
<p>设计时注意：<br>①元件/芯片要命名</p>
<p>②每条信号线也要标识信号的名称</p>
<p>③厂家名、类型——考试可以免</p>
<p>④达到线-线一一对应</p>
</blockquote>
<h4 id="【例4-2】（P95）"><a href="#【例4-2】（P95）" class="headerlink" title="【例4-2】（P95）"></a>【例4-2】（P95）</h4><blockquote>
<p>地址线必须全用——保证唯一性</p>
<p>尽量CPU地址线和芯片的地址线一一对应</p>
</blockquote>
<ul>
<li><p>最小8K地址</p>
<p>前3位全0</p>
<p>需要13根地址线——$A_0-A_{12}$</p>
</li>
<li><p>相邻16K地址</p>
<p>需要14根地址线——两个8K</p>
</li>
<li><p>最大4K地址</p>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>①实质上，CPU和芯片的信号线都接到总线上</p>
<p>②作为设计草图，信号线可以省略标注（<strong>画三个点，不可省</strong>）——学会简化</p>
<p>③标好芯片名称</p>
</blockquote>
<h4 id="【例4-3】"><a href="#【例4-3】" class="headerlink" title="【例4-3】"></a>【例4-3】</h4><p>某计算机地址为$A_{15}-A_{0}$，共16条。数据$D_{7}-D_{0}$，用$\overline{MEMR}$和$\overline{MEMW}$作为控制信号。用8K×8RAM及8K×8ROM芯片设计一个存储器系统。</p>
<p>其中：最小8K地址为系统程序区，其他为用户程序区</p>
<p>回答：①存储器需多少个芯片以及类型；②写出系统每个芯片的地址空间分配；③画出CPU和存储器原理图；④叙述说明存储器工作的正常和异常的测试程序；⑤若变成16位/32位计算机，该如何设计？</p>
<blockquote>
<p>RAM和ROM测试</p>
<p>【参考资料】<a target="_blank" rel="noopener" href="https://blog.csdn.net/u012252959/article/details/107955566#:~:text=%E6%B5%8B%E8%AF%95RAM%E7%9A%84%E6%96%B9%E6%B3%95,%E5%B9%B6%E4%B8%8E%E6%A0%A1%E9%AA%8C%E5%92%8C%E6%AF%94%E8%BE%83%E3%80%82">ROM和RAM测试总结</a></p>
<p>测试RAM的方法是写读各个内存单元，检查是否能够正确写入；测试ROM的方法是累加各存储单元数值并与校验和比较。</p>
<p>ROM</p>
<p>留一个单元——</p>
<p>驱动和隔离</p>
<p>使用三态门</p>
</blockquote>
<h4 id="存储器设计总结"><a href="#存储器设计总结" class="headerlink" title="存储器设计总结"></a>存储器设计总结</h4><ul>
<li>芯片选择：系统程序ROM存储器，用户程序/系统工作RAM</li>
<li>地址空间的确定</li>
<li>存储器的数据线与芯片的数据线对应相连（别忘了驱动和隔离——工程设计，考试不要求）</li>
<li>控制线（芯片）端——CPU与存储器控制线相连<ul>
<li>写控（$\overline{OE}$）</li>
<li>读控（）</li>
<li>驱动</li>
</ul>
</li>
<li>芯片的地址线与CPU地址线对应相连<ul>
<li>保证芯片地址在内存的唯一性</li>
<li>CPU（$A_0…A_i$）——芯片</li>
<li>总线的片选线时该芯片的总线地址（去掉片内地址的所有的唯一译码得来）</li>
</ul>
</li>
</ul>
<h4 id="译码方法总结"><a href="#译码方法总结" class="headerlink" title="译码方法总结"></a>译码方法总结</h4><ul>
<li>少变多<ul>
<li>1$\to$2：反相器</li>
<li>2$\to$4：74LS139</li>
<li>3$\to$8：74LS138</li>
<li>4$\to$16：74LS164</li>
</ul>
</li>
<li>多变少——地址译码<ul>
<li>适当添加反相器</li>
<li>控制端：使用读控、写控相与</li>
</ul>
</li>
</ul>
<p>补充题：1.例1和例2仿照例3重新完成 2.双CPU共享存储器</p>
<h3 id="六、存储器的校验——可靠性、容错性"><a href="#六、存储器的校验——可靠性、容错性" class="headerlink" title="六、存储器的校验——可靠性、容错性"></a>六、存储器的校验——可靠性、容错性</h3><p>目的：使存储器（自身）具有检测错误、纠正错误的能力。</p>
<p>容错设计的常见方法有四种：</p>
<blockquote>
<p>A、硬件冗余方法</p>
<p>B、软件冗余方法</p>
<p>C、时间冗余方法</p>
<p>D、信息冗余方法</p>
</blockquote>
<h4 id="硬件冗余"><a href="#硬件冗余" class="headerlink" title="硬件冗余"></a>硬件冗余</h4><p>是通过<strong>外加硬件的方式来达到系统容错的目的方式</strong>。是系统级的容错技术。技术常采用，它是用两倍、三倍的元件重复，从而增加了系统的可靠性。如：二模冗余、三模冗余等方式实现。 </p>
<ul>
<li><p>二模冗余</p>
<p>采用结果比较原则：结果相同，取其一； </p>
<p>结果不同，重新执行或每个模块进行自检，查出错误模块为止。</p>
</li>
<li><p>三模冗余：按照“三中取二”原则进行。</p>
</li>
</ul>
<h4 id="软件冗余"><a href="#软件冗余" class="headerlink" title="软件冗余"></a>软件冗余</h4><p>软件冗余技术：指开发容错软件的适宜环境和系统方法；<br>其主要目的是<strong>提供足够的冗余信息与算法程序，使系统在实际运行过程中，能够及时发现程序错误，采取补救措施</strong>，保证整个计算的正确性。<br>软件冗余包含多种技术和方法。<br>(研究生开设一门—-容错技术讲解)</p>
<h4 id="时间冗余"><a href="#时间冗余" class="headerlink" title="时间冗余"></a>时间冗余</h4><p>基本思想是：<strong>在一定时间内，重复执行指令或者一段程序来消除故障的影响</strong>，以达到容错的效果，它是用消耗时间来换取容错性的目 的，时间冗余的典型应用是程序卷回。</p>
<ul>
<li>两种方法：指令复执、程序卷回</li>
</ul>
<h4 id="信息冗余"><a href="#信息冗余" class="headerlink" title="信息冗余"></a>信息冗余</h4><p>通过在数据中，附加冗余的信息位，来达到故障检测和容错的目的。</p>
<p>常用的信息冗余技术：奇偶校验码、汉明码、循环码等。</p>
<p>存储器的检测及纠错功能，采用的是汉明码技术。</p>
<h4 id="存储器的汉明码校验原理"><a href="#存储器的汉明码校验原理" class="headerlink" title="存储器的汉明码校验原理"></a>存储器的汉明码校验原理</h4><p>题型：生成汉明码、汉明码纠错</p>
<h5 id="1-编码的最小距离"><a href="#1-编码的最小距离" class="headerlink" title="1.编码的最小距离"></a>1.编码的最小距离</h5><ul>
<li><p>编码的检测能力和纠错能力和什么有关？——任意二组合法代码之间<strong>二进制位的最小差异数</strong></p>
</li>
<li><p>编码的最小距离</p>
<p>任意两组合法代码之间的<strong>二进制位数</strong>的<strong>最小差异编码的纠错、检错能力与编码的最小距离有关</strong></p>
<script type="math/tex; mode=display">
L-1 = D+C \quad (D \geq C)</script><p>（L——编码的最小距离，L=3）</p>
<p>（D——检测错误的位数，具有一位纠错能力）</p>
<p>（C——纠正错误的位数）</p>
<blockquote>
<p>BCD码、ASCII码是没有检测及纠错能力的编码</p>
<p><strong>汉明码是具有一位纠错能力的编码</strong></p>
</blockquote>
</li>
<li><p>汉明码</p>
<p>具有一位纠错能力的编码</p>
<p>采用奇偶校验</p>
<p>采用分组校验</p>
<p>汉明码的分组是一种非划分方式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125105813576.png" alt="image-20220125105813576" style="zoom: 50%;" /></p>
</li>
</ul>
<h5 id="2-汉明码的组成"><a href="#2-汉明码的组成" class="headerlink" title="2.汉明码的组成"></a>2.汉明码的组成</h5><ul>
<li><p>三要素</p>
<script type="math/tex; mode=display">
2^{k}-1 \geq n+k \\</script><p>多少位检测位、检测位的位置、检测位的取值</p>
<p><code>信息位n位，校验位k位</code></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128105943809.png" alt="image-20220128105943809" style="zoom: 67%;" /></p>
</li>
</ul>
<blockquote>
<p>各检测位$C_i$所承担的检测小组为：</p>
<p>$C_1$检测的$g_1$小组包含第1，3，5，7，9，11，…</p>
<p>$C_2$检测的$g_2$小组包含第2，3，6，7，10，11，…</p>
<p>$C_4$检测的$g_3$小组包含第4，5，6，7，12，13，…</p>
<p>$C_8$检测的$g_4$小组包含第8，9，10，11，12，13，14，15，24，…</p>
<p>$g_i$小组独占第$2^{i-1}$位</p>
<p>$g_i$和$g_j$小组共同占第$2^{i-1}+2^{j-1}$位</p>
<p>$g_i、g_j$和$g_l$小组共同占第$2^{i-1}+2^{j-1}+2^{l-1}$位</p>
</blockquote>
<p>【例4-4】求0101按“偶校验”配置的汉明码</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309121524680.png" alt="image-20220309121524680" style="zoom:50%;" /></p>
<p>【练习1】按配偶原则配置0011的汉明码</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309121612964.png" alt="image-20220309121612964" style="zoom:50%;" /></p>
<h5 id="3-汉明码的纠错过程"><a href="#3-汉明码的纠错过程" class="headerlink" title="3.汉明码的纠错过程"></a>3.汉明码的纠错过程</h5><ul>
<li><p><strong>偶校验</strong>：异或的结果为0则不出错，为1则出错</p>
</li>
<li><p><strong>奇校验</strong>：与偶校验相反</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309132525822.png" alt="image-20220309132525822" style="zoom:50%;" /></p>
<p>【例4.5】已知接收到的汉明码为0100111（按配偶原则配置）试问要求传送的信息是什么？</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309132622850.png" alt="image-20220309132622850" style="zoom:50%;" /></p>
<p>【练习2】写出按偶校验配置的汉明码0101101的纠错过程</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316163138252.png" alt="image-20220316163138252" style="zoom:50%;" /></p>
<blockquote>
<p>出错的是第4位（校验码），不需要纠错</p>
</blockquote>
<p>【练习3】按配奇原则配置0011的汉明码</p>
<ul>
<li><p>答：配奇的汉明码为</p>
<blockquote>
<p>$1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7$</p>
<p>$c_1 \ c_2 \ 0 \  0 \ c_4 \ 1 \ 1$</p>
<p>$c_1 = 3 \oplus 5 \oplus 7 = 1$  </p>
</blockquote>
</li>
</ul>
<h5 id="4-汉明码应用"><a href="#4-汉明码应用" class="headerlink" title="4.汉明码应用"></a>4.汉明码应用</h5><p>按照汉明码的特点，在设计计算机存储器时，要明确存储器的性能指标：检测错误个数、纠正错误个数；</p>
<blockquote>
<p>例如：哈工大设计的“神舟”飞船的容错计算机中，它的存储器字长为16位、采用校验位为6位，所以，选用 SN54LS630实现”1位纠错、2位报警”功能。</p>
</blockquote>
<h3 id="七、提高访存速度的措施"><a href="#七、提高访存速度的措施" class="headerlink" title="七、提高访存速度的措施"></a>七、提高访存速度的措施</h3><blockquote>
<p>CPU速度每年提升52%，但内存的速度提升很慢。CPU得不到指令，进行空载（等待）。需要解决存储墙的问题。</p>
</blockquote>
<p>【解决方式】</p>
<ul>
<li>采用高速器件（带宽大、延迟小）</li>
<li>采用层次结构Cache-主存</li>
<li>调整主存的结构</li>
</ul>
<h4 id="1-单体多字系统"><a href="#1-单体多字系统" class="headerlink" title="1.单体多字系统"></a>1.单体多字系统</h4><p>CPU每次访问内存都可以访问四个数据寄存器，可以增加存储器的带宽。</p>
<p>【问题】：</p>
<ul>
<li>造成给定的存储字长被错误修改</li>
<li>如果取得指令不是连续存储</li>
</ul>
<p>【原因】：位置连续</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128114909794.png" alt="image-20220128114909794" style="zoom: 80%;" /></p>
<p>原理：由于程序、数据在内存中是顺序存放，一个地址，一个存取周期内可取出4×W位。<br>要求：存储器的各个存储器体的数据能够寄存及顺序读出等硬件支持。 遇到转移指令、数据非顺序<br>时失效。</p>
<h4 id="2-多体并行系统"><a href="#2-多体并行系统" class="headerlink" title="2.多体并行系统"></a>2.多体并行系统</h4><ul>
<li><p>存储器模块组成：各个模块各自都有独立的：MAR、 MDR、地址译码、驱动电路、读写控制；</p>
</li>
<li><p>特点： 每个存储器模块有相同的容量和存储速度； 各个存储器模块可以并行工作，又可以交叉工作；</p>
</li>
<li><p>并行工作：即同时可以访问N个存储器模块，同时启动、同时读出、完全并行的工作；（注意：同时读出的N个存储字，在总线上需要顺序、分时传出）；</p>
</li>
</ul>
<h5 id="（1）高位交叉，顺序编址存储器"><a href="#（1）高位交叉，顺序编址存储器" class="headerlink" title="（1）高位交叉，顺序编址存储器"></a>（1）高位交叉，顺序编址存储器</h5><blockquote>
<p>高位译码决定体地址，低位译码决定体内的地址</p>
</blockquote>
<p>【问题】具有并行基础，但会造成某一个存储体十分繁忙，其余闲置</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115133016.png" alt="image-20220128115133016" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316165850524.png" alt="image-20220316165850524" style="zoom: 50%;" /></p>
<p>适合存储器的扩展，不适合带宽的提升</p>
<ul>
<li>高位交叉编址多体存储器工作原理：只要合理安排及调度，可以实现不同请求源，与不同存储体进行访问，实现并行工作；</li>
</ul>
<ul>
<li><p>优点：一个体内地址是连续的，有利于扩充；</p>
</li>
<li><p>缺点：相邻指令或数据是在连续存放在一个存储体内。<strong>不利于程序并行</strong></p>
<blockquote>
<p>一个体内运行——串行</p>
</blockquote>
</li>
</ul>
<h5 id="（2）低位交叉并行多体存储器（各个体轮流编址）"><a href="#（2）低位交叉并行多体存储器（各个体轮流编址）" class="headerlink" title="（2）低位交叉并行多体存储器（各个体轮流编址）"></a>（2）低位交叉并行多体存储器（各个体轮流编址）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115441608.png" alt="image-20220128115441608" style="zoom: 67%;" /></p>
<blockquote>
<p>低位不同——体号。高位——体内地址</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171050903.png" alt="image-20220316171050903" style="zoom:50%;" /></p>
<blockquote>
<p>地址译码需要加上三态门进行驱动和隔离</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171111134.png" alt="image-20220316171111134" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115417652.png" alt="image-20220128115417652" style="zoom: 67%;" /></p>
<blockquote>
<p>注：带宽：数据传输率</p>
<p>每个存储体完成数据传输（总线传输周期），则下一个存储体开始传输</p>
<p>对于每个存储体，访存周期不变</p>
</blockquote>
<ul>
<li>特点：在一个存储器周期结束之后，每隔1/4周期，CPU即可获得一个结果。</li>
<li>优点：相邻各个存储体内地址是连续的，有利于并行—流水线计算机相邻各个存储体内地址是连续的，单独每个体的地址是间隔的。</li>
</ul>
<blockquote>
<p><strong>题型</strong></p>
<p>对于低位交叉的存储器，连续读取n个字所需要的时间$t_1$为：$t_1 = T + (n-1) \tau$ </p>
<p>其中，$T$为存取周期，$\tau$为总线传输周期</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171737021.png" alt="image-20220316171737021" style="zoom:50%;" /></p>
<h5 id="（3）存储器控制部件（存控）"><a href="#（3）存储器控制部件（存控）" class="headerlink" title="（3）存储器控制部件（存控）"></a>（3）存储器控制部件（存控）</h5><blockquote>
<p>在多体交叉并行存储器的设计中，不仅要考虑存储器自身的并行性支撑：单独MAR、MDR、译码驱动、读控制、写控制、数据寄存器等；</p>
<p>如何确定存储器与CPU、外存、I/O设备、I/O处理机等，不同信息交换源之间的关系；<br>因此，在某一时刻，如何进行<strong>优先级排队</strong>，<strong>选出</strong>优先级高的请求源，<strong>与存储器进行信息交换</strong>；这个功能及任务<strong>由存储器的控制器（存控）来实现</strong>。</p>
</blockquote>
<p>存储器控制部件（存控）组成：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309133933651.png" alt="image-20220309133933651" style="zoom: 67%;" /></p>
<p><strong>（1）排队器（硬件）</strong></p>
<p>（详见ch8，中断优先级排队器的设计）</p>
<p><strong>确定</strong>同一时刻访问存储器的请求源；按照<strong>优先级</strong>原则进行。</p>
<ul>
<li><p>对易发生代码丢失的请求源，安排最高优先级；</p>
<blockquote>
<p>如，某些外设信息最易丢失</p>
</blockquote>
</li>
<li><p>严重影响CPU工作的请求源，安排次级优先级，否则导致CPU工作异常；</p>
<blockquote>
<p>如，写数高于读数；读数高于读指令</p>
</blockquote>
</li>
</ul>
<p><strong>（2）存控标志触发器$C_m$</strong></p>
<p>用来<strong>接收排队器输出信号</strong>，一旦响应某个请求源，标记 $C_m$ 被置“1”，以便<strong>启动节拍发生器工作</strong>。</p>
<p><strong>（3）节拍发生器</strong></p>
<p><strong>产生固定节拍</strong>，与机器<strong>主脉冲同步</strong>，使控制线路按一定时序发出控制信号；</p>
<p><strong>（4）控制线路</strong></p>
<p>将排队器输出的信号，与<strong>节拍器发生器提供的信号配合</strong>，向存储器各个部件发出各种控制信号，用于实现对总线控制，以及完成存储器的读/写操作，并向请求源发出回答信号，表示存储器已经响应了它的请求；</p>
<h4 id="3-高性能存储芯片（了解内容）"><a href="#3-高性能存储芯片（了解内容）" class="headerlink" title="3.高性能存储芯片（了解内容）"></a>3.高性能存储芯片（了解内容）</h4><p>按照摩尔定律：存储器容量每3年两番的规律，使DRAM的性能得到提高。</p>
<p><strong>（1）SDRAM（同步DRAM）</strong></p>
<p>在系统时钟的控制下进行读出和写入</p>
<p><strong>CPU无须等待</strong></p>
<p><strong>（2）RDRAM</strong></p>
<p>由<code>Rambus</code>开发，主要解决<strong>存储器带宽</strong>的问题</p>
<p><strong>（3）带Cache的DRAM</strong></p>
<p>在DRAM的芯片内集成了一个由<strong>SRAM</strong>组成的<strong>Cache</strong>，有利于<strong>猝发式读取</strong></p>
<blockquote>
<p>一次读取几个存储字长（给出首地址就能完成剩余的读写操作，不需要再给出地址）</p>
</blockquote>
<h2 id="4-3-高速缓冲存储器"><a href="#4-3-高速缓冲存储器" class="headerlink" title="4.3 高速缓冲存储器"></a>4.3 高速缓冲存储器</h2><p>Cache是用SRAM制成的</p>
<h3 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-为什么用Cache"><a href="#1-为什么用Cache" class="headerlink" title="1.为什么用Cache"></a>1.为什么用Cache</h4><blockquote>
<p>CPU 优先级低于易失性外设的请求源；出现CPU“空等”现象</p>
<p>CPU 和主存（DRAM）的速度差异发展快，且速度差越来越大；</p>
</blockquote>
<p>——避免CPU“空等”现象</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165237238.png" alt="image-20220321165237238" style="zoom: 67%;" /></p>
<h5 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h5><p>CPU在访问内存时，在一定时间，是<strong>局部地址区域的访问</strong>，指令和数据中内存中的地址是<strong>连续存放</strong>的，是<strong>相对的簇聚</strong>的。</p>
<blockquote>
<p>如：子程序、循环出现、一些常数等</p>
</blockquote>
<ul>
<li>时间的局部性：在不久的将来还会使用</li>
<li>空间的局部性：相邻的指令或数据还会使用</li>
</ul>
<blockquote>
<p>主存和Cache之间的数据传送单位不是一个字，而是几个字组成的子块</p>
<p>不适合离散情况</p>
</blockquote>
<h4 id="2-Cache的工作原理——注意Cache的命中率"><a href="#2-Cache的工作原理——注意Cache的命中率" class="headerlink" title="2.Cache的工作原理——注意Cache的命中率"></a>2.Cache的工作原理——注意Cache的命中率</h4><p><strong>（1）主存和缓存的编址</strong></p>
<blockquote>
<p>都分为块号和块内地址</p>
<p>主存和缓存的块的长度均为b位</p>
<p>主存有$2^m-1$块，缓存有$2^c-1$块</p>
<p>实际过程中，$M$ &gt;&gt; $C$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165142799.png" alt="image-20220321165142799" style="zoom:80%;" /></p>
<p><strong>主存和缓存按块存储，块的大小相同</strong></p>
<p><strong>（2）命中与未命中</strong></p>
<blockquote>
<p>缓存有C块，主存共有M块，M &gt;&gt; C</p>
</blockquote>
<p>命中与否取决于<strong>主存块是否调入缓存</strong>，用<code>标记记录</code>与某缓存块建立了对应关系的<code>主存块号</code></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165312839.png" alt="image-20220321165312839" style="zoom:67%;" /></p>
<p><strong>（3）Cache的命中率</strong></p>
<p>——CPU欲访问的信息在Cache中的比率</p>
<p>命中率与<strong>Cache的容量与块长</strong>有关</p>
<p>一般每块可取4~8个字</p>
<p><strong>块长取一个存取周期内从主存调出的信息长度</strong></p>
<blockquote>
<p>例如，</p>
<p>CRAY_1：16体交叉，块长取16个存储字</p>
<p>IBM 370/168：4体交叉，块长取4个存储字（64位 × 4 = 256位）</p>
</blockquote>
<p><strong>（4）Cache-主存系统的效率</strong></p>
<p>效率<strong>e</strong>与<strong>命中率</strong>有关</p>
<script type="math/tex; mode=display">
e = \frac{访问Cache的时间}{平均访问时间} \times 100 \%</script><p>平均访问时间：访问t的时间 * 访问t的概率</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165345089.png" alt="image-20220321165345089" style="zoom:80%;" /></p>
<h4 id="3-Cache的基本结构"><a href="#3-Cache的基本结构" class="headerlink" title="3.Cache的基本结构"></a>3.Cache的基本结构</h4><blockquote>
<p>添加Cache后，计算机的读取写入速度提升。</p>
<p>①<strong>CPU需要给出地址</strong>，分为两部分：块内地址（不需要识别，主存和Cache同）、块号（块外地址的值）；</p>
<p>②送入<strong>主存Cache地址映射变换机构</strong>。硬件设计时要在3种方式之一（追求指标：快速）。里面是组合逻辑电路，<strong>比较主存和Cache的块号</strong>；</p>
<p>③如果块号相同，则命中，进入<strong>Cache存储体</strong>内读取数据，<strong>与数据总线</strong>进行信息交换；</p>
<p>④如果没有命中，则<strong>判断是否可以装入</strong>（Cache是否有空闲空间，与映射方式有关）。如果可以装入，则访问主存装入Cache；不能装入则进入<strong>Cache替换机构</strong>。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165049480.png" alt="image-20220321165049480" style="zoom: 80%;" /></p>
<ul>
<li><p>CPU完成的部件：</p>
<ul>
<li><p>Cache存储体：一定是RAM。</p>
</li>
<li><p>地址映射变换机构。是否命中是比较器。</p>
</li>
<li><p>Cache替换机构：是硬件，把某一个叶判断是否需要写入内存</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Cache工作时间一定要小于读取时间（读周期、写周期）</p>
</blockquote>
<h4 id="4-Cache的读写操作"><a href="#4-Cache的读写操作" class="headerlink" title="4.Cache的读写操作"></a>4.Cache的读写操作</h4><ul>
<li><p><strong>Cache读操作</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165015269.png" alt="image-20220321165015269" style="zoom:67%;" /></p>
<blockquote>
<p><strong>过程</strong>：</p>
<ol>
<li><p>CPU发送地址，同时到达Cache和主存。</p>
</li>
<li><p>比较是否命中（Cache的内容是否在主存中）：</p>
<ul>
<li><p>命中：直接访问Cache取出信息送到CPU</p>
</li>
<li><p>没有命中：判断Cache是否满：</p>
<ul>
<li>Cache满：替换算法，腾出空位（替换算法与映射方式有关）</li>
<li>Cache没满：将新主存块调入Cache中</li>
</ul>
</li>
</ul>
<p>访问主存，取出信息送到CPU</p>
</li>
<li><p>结束Cache的读操作</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>Cache写操作</strong>——Cache和主存的一致性</p>
<ol>
<li><p>写直达法（Write-through）</p>
<p>数据既写入Cache又写入主存</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164735646.png" alt="image-20220321164735646" style="zoom: 80%;" /></p>
</li>
<li><p>写回法（Write-back）</p>
<blockquote>
<p>速度更快，但需要注意把Cache的信息写回主存</p>
</blockquote>
<p>出现主存和Cache映射的数据不一致，Cache的信息是有效的。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164735646.png" style="zoom:80%;" /></p>
<p><strong>写操作的时间就是访问Cache的时间</strong>。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164840004.png" alt="image-20220321164840004" style="zoom:80%;" /></p>
</li>
</ol>
</li>
</ul>
<h4 id="5-Cache的改进"><a href="#5-Cache的改进" class="headerlink" title="5.Cache的改进"></a>5.Cache的改进</h4><p><strong>（1）增加Cache的级数</strong></p>
<ul>
<li>片载（片内）Cache</li>
<li>片外 Cache</li>
</ul>
<p><strong>（2）统一缓存和分立缓存</strong></p>
<blockquote>
<p>统一缓存：指令和数据都存放在同一缓存内的Cache</p>
<p>分立缓存：指令和数据分别存放在两个缓存中，一个称为指令Cache，一个称为数据Cache</p>
</blockquote>
<ul>
<li><p><strong>指令Cache</strong>和<strong>数据Cache</strong>——与主存结构有关</p>
</li>
<li><p>与指令执行的控制方式有关，是否流水（ch8）</p>
<blockquote>
<p>并行加工指令：提速，但产生资源的竞争、冲突</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>例如，</p>
<p>Pentium：8K指令Cache，8K数据Cache</p>
<p>PowerPC620：32K指令Cache，32K数据Cache</p>
</blockquote>
<h3 id="二、Cache-主存的地址映射"><a href="#二、Cache-主存的地址映射" class="headerlink" title="二、Cache-主存的地址映射"></a>二、Cache-主存的地址映射</h3><h4 id="1-直接映射"><a href="#1-直接映射" class="headerlink" title="1.直接映射"></a>1.直接映射</h4><blockquote>
<p>主存块只能装载/映射到指定的缓存块</p>
<p>下图中每个主存块只与一个缓存块相对应。</p>
<p>映射关系式：$i = j \ \ mod \  \ C$ 或 $i = \ j \ \ mod \ \ 2^C$</p>
<p>（$i$为缓存块号，$j$为主存块号，$C$为缓存块号）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165743565.png" alt="image-20220321165743565" style="zoom:67%;" /></p>
<ul>
<li><strong>每个缓存块i</strong>可以和<strong>若干个主存块</strong>对应</li>
<li><strong>每一个主存块j</strong>只能和<strong>一个缓存块</strong>对应</li>
</ul>
<blockquote>
<p>Cache存储体的字块是一对多的关系</p>
<p>主存块是一对一的关系</p>
<p>t位地址全相同——匹配成功，命中</p>
</blockquote>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>不够灵活</strong>。即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分利用。</li>
<li>重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而<strong>降低命中率</strong></li>
</ul>
<p><strong>总结</strong>：速度快，效率低</p>
<h4 id="2-全相联映射"><a href="#2-全相联映射" class="headerlink" title="2.全相联映射"></a>2.全相联映射</h4><blockquote>
<p>任何一个主存块可以调用任何一个空闲的缓存块</p>
<p>主存子块标记从$t$位增加到$t+c$位，使得Cache“标记”的位数增多，而且访问Cache时<strong>主存子块标记需要和Cache的全部“标记”位进行比较</strong>，才能判断出所访问的主存地址是否已在Cache内</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165944751.png" alt="image-20220321165944751" style="zoom:80%;" /></p>
<ul>
<li><strong>主存中的任一块</strong>可以映射到<strong>缓存的任一块</strong></li>
</ul>
<blockquote>
<p>缺点：识别字段由t变为t+c，除了主存子块标记判断的位数增多，延长匹配的时间</p>
<p><strong>解决方法</strong>（书P153）相联存储器</p>
</blockquote>
<p><strong>总结</strong>：效率最高，比较时间长，硬件复杂</p>
<h4 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3.组相联映射"></a>3.组相联映射</h4><blockquote>
<p>直接映射和组相联映射的结合</p>
<p>Cache分为若干组，每一组又分为若干块（2, 4, 8, 16, … ）</p>
<p>主存储器中的区数 = Cache中的组数</p>
</blockquote>
<script type="math/tex; mode=display">
i = j \mod Q</script><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321170055398.png" alt="image-20220321170055398" style="zoom:80%;" /></p>
<ul>
<li><strong>某一主存块j</strong>按<strong>模Q</strong>映射到缓存的<strong>第i组的任一块</strong></li>
</ul>
<blockquote>
<p>比直接映射方式的主存子块标记位数多，比全相联映射方式的标记位数少</p>
<p>组间为直接映射，组内为全相联映射</p>
</blockquote>
<h3 id="三、替换算法"><a href="#三、替换算法" class="headerlink" title="三、替换算法"></a>三、替换算法</h3><ol>
<li><p>先进先出（FIFO）算法</p>
<p>选择最早调入Cache的字块进行替换。</p>
</li>
<li><p>近期最小使用（LRU）算法</p>
<p>Least Recently Used</p>
<p>较好地利用访存局部性原理，替换出近期用得最少的字块</p>
<blockquote>
<p><strong>全相联映射</strong></p>
<p>每个主存块可以调用任何空闲的缓存块，能够确定哪个字块近期使用最少</p>
</blockquote>
</li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220130103055884.png" alt="image-20220130103055884" style="zoom: 80%;" /></p>
<p><strong>小结</strong></p>
<ul>
<li>直接：<strong>某一</strong>主存块<strong>只能固定</strong>映射到<strong>某一</strong>缓存块——不灵活</li>
<li>全相联：<strong>某一</strong>主存块<strong>能</strong>映射到<strong>任一</strong>缓存块——成本高</li>
<li>组相联：<strong>某一</strong>主存块只能映射到<strong>某一</strong>缓存<strong>组</strong>中的<strong>任一块</strong></li>
</ul>
<h2 id="4-4-辅助存储器（了解内容）"><a href="#4-4-辅助存储器（了解内容）" class="headerlink" title="4.4 辅助存储器（了解内容）"></a>4.4 辅助存储器（了解内容）</h2><p>（考试不要求）</p>
<h3 id="一、概述-2"><a href="#一、概述-2" class="headerlink" title="一、概述"></a>一、概述</h3><ol>
<li><p>特点：不直接与CPU交换信息</p>
</li>
<li><p>磁表面存储器的技术指标</p>
<ul>
<li><p>记录密度：道密度Dt，位密度Db</p>
</li>
<li><p>存储容量：$C = n \times k \times s$​ </p>
</li>
<li><p>平均寻址时间：寻道时间+等待时间</p>
<script type="math/tex; mode=display">
 辅存的速度
\begin{cases}
寻址时间\\
磁头读写时间
\end{cases}</script></li>
<li><p>数据传输率</p>
</li>
</ul>
</li>
</ol>
<script type="math/tex; mode=display">
     D_r = D_b \times V</script><ul>
<li>误码率：出错信息位数与读出信息的总位数之比</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/computer-organization/" rel="tag"># computer organization</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/algorithm/algorithm-ch4/" rel="prev" title="算法设计与分析：第4章 蛮力法">
      <i class="fa fa-chevron-left"></i> 算法设计与分析：第4章 蛮力法
    </a></div>
      <div class="post-nav-item">
    <a href="/algorithm/algorithm-ch5/" rel="next" title="算法设计与分析：第5章 分治法">
      算法设计与分析：第5章 分治法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">4.1 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-text">一、存储器分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8C%89%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8%E5%88%86%E7%B1%BB"><span class="nav-text">1.按存储介质分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8C%89%E5%AD%98%E5%8F%96%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="nav-text">2.按存取方式分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8C%89%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB"><span class="nav-text">3.按在计算机中的作用分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">二、存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%89%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">1.存储器三个主要特性的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1%E5%92%8C%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1%EF%BC%88%E5%AD%98%E5%82%A8%E4%BD%93%E7%B3%BB%EF%BC%89"><span class="nav-text">2.缓存-主存层次和主存-辅存层次（存储体系）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">4.2 主存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="nav-text">1.主存的基本组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E7%9A%84%E8%81%94%E7%B3%BB"><span class="nav-text">2.主存和CPU的联系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%BB%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-text">3.主存中存储单元地址的分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%B8%BB%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="nav-text">4.主存的技术指标</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8F%90%E9%AB%98%E5%AD%98%E5%82%A8%E5%99%A8%E5%B8%A6%E5%AE%BD%E7%9A%84%E6%8E%AA%E6%96%BD"><span class="nav-text">提高存储器带宽的措施</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%AE%80%E4%BB%8B"><span class="nav-text">二、半导体存储芯片简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">1.半导体存储芯片的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%89%87%E9%80%89%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">存储芯片片选线的作用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">2.半导体存储芯片的译码驱动方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%BA%BF%E9%80%89%E6%B3%95"><span class="nav-text">（1）线选法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%87%8D%E5%90%88%E6%B3%95"><span class="nav-text">（2）重合法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88RAM%EF%BC%89"><span class="nav-text">三、随机存取存储器（RAM）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%9D%99%E6%80%81RAM%EF%BC%88SRAM%EF%BC%89"><span class="nav-text">1.静态RAM（SRAM）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF"><span class="nav-text">（1）静态RAM基本电路</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A0%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="nav-text">①静态RAM基本电路的读操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A1%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-text">②静态RAM基本电路的写操作</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%9D%99%E6%80%81RAM%E8%8A%AF%E7%89%87%E4%B8%BE%E4%BE%8B"><span class="nav-text">（2）静态RAM芯片举例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A0Intel-2114%E5%A4%96%E7%89%B9%E6%80%A7"><span class="nav-text">①Intel 2114外特性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A1Intel-2114-RAM%E7%9F%A9%E9%98%B5%EF%BC%8864-times-64%EF%BC%89%E8%AF%BB"><span class="nav-text">②Intel 2114 RAM矩阵（64 $\times$ 64）读</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A2Intel-2114-RAM%E7%9F%A9%E9%98%B5%EF%BC%8864-times-64%EF%BC%89%E5%86%99"><span class="nav-text">③Intel 2114 RAM矩阵（64 $\times$ 64）写</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%9D%99%E6%80%81RAM%E8%AF%BB%E6%97%B6%E5%BA%8F"><span class="nav-text">（3）静态RAM读时序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E9%9D%99%E6%80%81RAM%E5%86%99%E6%97%B6%E5%BA%8F"><span class="nav-text">（4）静态RAM写时序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8A%A8%E6%80%81RAM%EF%BC%88DRAM%EF%BC%89%E2%80%94%E2%80%94%E4%BA%86%E8%A7%A3%E5%86%85%E5%AE%B9"><span class="nav-text">2.动态RAM（DRAM）——了解内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8A%A8%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF"><span class="nav-text">（1）动态RAM基本单元电路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8A%A8%E6%80%81RAM%E8%8A%AF%E7%89%87%E4%B8%BE%E4%BE%8B"><span class="nav-text">（2）动态RAM芯片举例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8A%A8%E6%80%81RAM%E6%97%B6%E5%BA%8F"><span class="nav-text">（3）动态RAM时序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%8A%A8%E6%80%81RAM%E5%88%B7%E6%96%B0"><span class="nav-text">（4）动态RAM刷新</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A0%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0%EF%BC%88%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F%E4%B8%BA0-5%CE%BCs%EF%BC%89%EF%BC%9A%E4%B8%93%E6%97%B6%E4%B8%93%E7%94%A8"><span class="nav-text">①集中刷新（存取周期为0.5μs）：专时专用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A1%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0%EF%BC%88%E5%AD%98%E5%8F%96%E5%91%A8%E6%9C%9F%E4%B8%BA1%CE%BCs%EF%BC%89%EF%BC%9A%E9%A2%91%E7%B9%81%E5%88%B7%E6%96%B0"><span class="nav-text">②分散刷新（存取周期为1μs）：频繁刷新</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E2%91%A2%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0%EF%BC%88%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0%E4%B8%8E%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0%E7%9B%B8%E7%BB%93%E5%90%88%EF%BC%89"><span class="nav-text">③异步刷新（分散刷新与集中刷新相结合）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81RAM%E5%92%8C%E9%9D%99%E6%80%81RAM%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-text">3.动态RAM和静态RAM的比较（重点）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88ROM%EF%BC%89%E2%80%94%E2%80%94%E4%BA%86%E8%A7%A3%E5%86%85%E5%AE%B9"><span class="nav-text">四、只读存储器（ROM）——了解内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8E%A9%E8%86%9CROM%EF%BC%88MROM"><span class="nav-text">1.掩膜ROM（MROM)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-PROM%EF%BC%88%E4%B8%80%E6%AC%A1%E6%80%A7%E7%BC%96%E7%A8%8B%EF%BC%89"><span class="nav-text">2.PROM（一次性编程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-EPROM%EF%BC%88%E5%A4%9A%E6%AC%A1%E6%80%A7%E7%BC%96%E7%A8%8B%EF%BC%89"><span class="nav-text">3.EPROM（多次性编程）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89N%E5%9E%8B%E6%B2%9F%E9%81%93%E6%B5%AE%E5%8A%A8%E6%A0%85MOS%E7%94%B5%E8%B7%AF"><span class="nav-text">（1）N型沟道浮动栅MOS电路</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%892716-EPROM%E7%9A%84%E9%80%BB%E8%BE%91%E5%9B%BE%E5%92%8C%E5%BC%95%E8%84%9A%E5%9B%BE"><span class="nav-text">（2）2716 EPROM的逻辑图和引脚图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-EEPROM%EF%BC%88%E5%A4%9A%E6%AC%A1%E6%80%A7%E7%BC%96%E7%A8%8B%EF%BC%89"><span class="nav-text">4.EEPROM（多次性编程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Flash-Memory%EF%BC%88%E9%97%AA%E9%80%9F%E5%9E%8B%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="nav-text">5.Flash Memory（闪速型存储器）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%88%E9%87%8D%E7%82%B9%E5%92%8C%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="nav-text">五、存储器与CPU的连接（重点和难点）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-text">1.存储器容量的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="nav-text">（1）位扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%AD%97%E6%89%A9%E5%B1%95"><span class="nav-text">（2）字扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AD%97%E3%80%81%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="nav-text">（3）字、位扩展</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%8ECPU%E8%BF%9E%E6%8E%A5"><span class="nav-text">2.存储器与CPU连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E4%BE%8B4-1%E3%80%91%EF%BC%88P94%EF%BC%89"><span class="nav-text">【例4-1】（P94）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E4%BE%8B4-2%E3%80%91%EF%BC%88P95%EF%BC%89"><span class="nav-text">【例4-2】（P95）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E4%BE%8B4-3%E3%80%91"><span class="nav-text">【例4-3】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93"><span class="nav-text">存储器设计总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%91%E7%A0%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-text">译码方法总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%A0%A1%E9%AA%8C%E2%80%94%E2%80%94%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E5%AE%B9%E9%94%99%E6%80%A7"><span class="nav-text">六、存储器的校验——可靠性、容错性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%86%97%E4%BD%99"><span class="nav-text">硬件冗余</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%86%97%E4%BD%99"><span class="nav-text">软件冗余</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%86%97%E4%BD%99"><span class="nav-text">时间冗余</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E5%86%97%E4%BD%99"><span class="nav-text">信息冗余</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%B1%89%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E5%8E%9F%E7%90%86"><span class="nav-text">存储器的汉明码校验原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BC%96%E7%A0%81%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="nav-text">1.编码的最小距离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E6%B1%89%E6%98%8E%E7%A0%81%E7%9A%84%E7%BB%84%E6%88%90"><span class="nav-text">2.汉明码的组成</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%B1%89%E6%98%8E%E7%A0%81%E7%9A%84%E7%BA%A0%E9%94%99%E8%BF%87%E7%A8%8B"><span class="nav-text">3.汉明码的纠错过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%B1%89%E6%98%8E%E7%A0%81%E5%BA%94%E7%94%A8"><span class="nav-text">4.汉明码应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%8F%90%E9%AB%98%E8%AE%BF%E5%AD%98%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8E%AA%E6%96%BD"><span class="nav-text">七、提高访存速度的措施</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F"><span class="nav-text">1.单体多字系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F"><span class="nav-text">2.多体并行系统</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89%EF%BC%8C%E9%A1%BA%E5%BA%8F%E7%BC%96%E5%9D%80%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">（1）高位交叉，顺序编址存储器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E5%B9%B6%E8%A1%8C%E5%A4%9A%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E5%90%84%E4%B8%AA%E4%BD%93%E8%BD%AE%E6%B5%81%E7%BC%96%E5%9D%80%EF%BC%89"><span class="nav-text">（2）低位交叉并行多体存储器（各个体轮流编址）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AD%98%E5%82%A8%E5%99%A8%E6%8E%A7%E5%88%B6%E9%83%A8%E4%BB%B6%EF%BC%88%E5%AD%98%E6%8E%A7%EF%BC%89"><span class="nav-text">（3）存储器控制部件（存控）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%EF%BC%88%E4%BA%86%E8%A7%A3%E5%86%85%E5%AE%B9%EF%BC%89"><span class="nav-text">3.高性能存储芯片（了解内容）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-text">4.3 高速缓冲存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-1"><span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Cache"><span class="nav-text">1.为什么用Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-text">程序访问的局部性原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Cache%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E6%B3%A8%E6%84%8FCache%E7%9A%84%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="nav-text">2.Cache的工作原理——注意Cache的命中率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">3.Cache的基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Cache%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-text">4.Cache的读写操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Cache%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="nav-text">5.Cache的改进</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Cache-%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="nav-text">二、Cache-主存的地址映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="nav-text">1.直接映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="nav-text">2.全相联映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84"><span class="nav-text">3.组相联映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-text">三、替换算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%88%E4%BA%86%E8%A7%A3%E5%86%85%E5%AE%B9%EF%BC%89"><span class="nav-text">4.4 辅助存储器（了解内容）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-2"><span class="nav-text">一、概述</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bob Cheng</p>
  <div class="site-description" itemprop="description">my first blog</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bob Cheng</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

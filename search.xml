<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法设计与分析：第1章 算法基础</title>
    <url>/algorithm/algorithm-ch1/</url>
    <content><![CDATA[<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/202201072028024.png" alt="image-20220107202845894" style="zoom: 50%;" /></p>
<p>终极目标：问题求解</p>
<ul>
<li>分析问题：已知条件、数据结构、问题划分</li>
<li>计算模型：技术、工具、手段</li>
<li>求解策略：技术路线</li>
<li>编程求解：程序设计</li>
<li>效率评估：算法评估手段——算法分析工具</li>
</ul>
<span id="more"></span>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>算法的基本概念</li>
<li>算法的描述方法</li>
<li>算法的设计过程</li>
<li>算法设计工具</li>
<li>基本的数据结构</li>
</ul>
<h2 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h2><p>算法：对解题方案准确而完整的描述</p>
<h3 id="【例1-1】最大公约数"><a href="#【例1-1】最大公约数" class="headerlink" title="【例1-1】最大公约数"></a>【例1-1】最大公约数</h3><p>【例1-1】求任意两个非负整数最大公约数（greatest common divisor, gcd）</p>
<ul>
<li><p>问题分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221185238540.png" alt="image-20220221185238540" style="zoom: 67%;" /></p>
</li>
<li><p>计算模型</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221185310925.png" alt="image-20220221185310925" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221185340266.png" alt="image-20220221185340266" style="zoom: 67%;" /></p>
<ul>
<li>欧几里德算法正确性的解释<script type="math/tex; mode=display">
设gcd(a,b) = d, 则d|a \and d|b \newline
a = m \times b + r \to d|r
\and a \geq b > r \\</script></li>
</ul>
</li>
<li><p>算法设计与描述</p>
<ul>
<li>自然语言描述——脱离语言限制，提取出核心部分，$\color{red} {注意关注自然语言的二义性，要准确、清晰}$</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221185823296.png" alt="image-20220221185823296" style="zoom: 67%;" /></p>
</li>
<li><p>算法分析——效率</p>
<ul>
<li><p>错误的分析方式——通过实例来证明，不具有普遍性</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221185922706.png" alt="image-20220221185922706" style="zoom: 67%;" /></p>
</li>
<li><p>正确的分析方式——使用数学证明</p>
<ul>
<li><p>穷举法</p>
<p><strong>注：考虑a、b互质的最坏情况，获得穷举法的算法运算数量级</strong></p>
<p>$f(b) = p_i \times \sum_{i = 0}^{b - 1} (b-i)$</p>
<p>$f(b) = \frac{b+1}{2}$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221190212104.png" alt="image-20220221190212104" style="zoom: 67%;" /></p>
</li>
<li><p>欧几里德算法——渐进法</p>
<p><strong>注：渐进法即构造出一个可计算、趋近于欧式算法的模型，利用不等式得到数量级</strong></p>
<p>考虑到欧式算法中的第三项与前两项存在$\color{blue} {u_{k} = u_{k+1} + u_{k+2} \times m}$​的关系，</p>
<p>将斐波那契数列$\color{blue}{f_{k+2} = f_{k+1} + f_{k}}$的倒序与其进行比较。</p>
<p>最后发现$F_{n-1} \leq f(b) &lt; F_{n}$，并且$F_{n} \div F_{n-1} \approx 0.618$，得到结论。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221190518385.png" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221191800171.png" alt="image-20220221191800171" style="zoom: 67%;" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算法实现</p>
<ul>
<li><p>课件上的代码（有些问题）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221193047193.png" alt="image-20220221193047193" style="zoom:80%;" /></p>
</li>
<li><p>更正</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例1-1 求任意两个非负整数最大公约数（greatest common divisor, gcd）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 穷举法 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gcd_enum</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="comment">// 判断为0的情况</span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b); <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a); <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> r = a;</span><br><span class="line">	<span class="keyword">if</span> (b &lt; a) &#123;</span><br><span class="line">		r = b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">0</span> != a%r || <span class="number">0</span> != b%r) &#123;</span><br><span class="line">		r = r<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧几里德算法（辗转相除法） </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gcd_euclid</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="comment">// 判断为0的情况</span></span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b); <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a); <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 辗转相除</span></span><br><span class="line">	<span class="type">int</span> r = a%b;</span><br><span class="line">	<span class="keyword">while</span> (r) &#123;</span><br><span class="line">		a = b; b = r; r = a%b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	gcd_enum();</span><br><span class="line">	gcd_euclid();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：<strong>考试可能会从欧几里得方法的正确性证明出题</strong></p>
<h2 id="算法的描述方法"><a href="#算法的描述方法" class="headerlink" title="算法的描述方法"></a>算法的描述方法</h2><ul>
<li><p>自然语言描述</p>
</li>
<li><p>程序流程图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221191901115.png" alt="image-20220221191901115" style="zoom:80%;" /></p>
</li>
<li><p>NS流程图</p>
<p><a href="https://zhuanlan.zhihu.com/p/360968980">怎么将流程图转化为N-S图（盒图）？</a></p>
<blockquote>
<p>随着结构化程序设计方法的出现，美国学者Ike Nassi和Ben Shneiderman于1973年提出了一种新的流程图形式，NS流程图完全去掉了流程线，算法的每一步都用一个矩形框来描述，把一个个矩形框按执行的次序连接起来就是一个完整的算法描述。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221192424910.png" alt="image-20220221192424910" style="zoom:80%;" /></p>
</li>
<li><p>伪代码</p>
</li>
<li><p>程序设计语言</p>
</li>
</ul>
<p>（以上内容作为了解）</p>
<h2 id="算法设计的过程"><a href="#算法设计的过程" class="headerlink" title="算法设计的过程"></a>算法设计的过程</h2><ol>
<li>问题分析<ul>
<li>信息整理</li>
<li>数据结构抽象</li>
</ul>
</li>
<li>算法策略/建立<strong>计算模型</strong></li>
<li>算法设计与描述</li>
<li>算法分析【评价——算法选择】</li>
<li>算法实现</li>
<li>测试</li>
<li>结果整理与文档编制</li>
</ol>
<h3 id="【例1-2】交通指挥灯问题"><a href="#【例1-2】交通指挥灯问题" class="headerlink" title="【例1-2】交通指挥灯问题"></a>【例1-2】交通指挥灯问题</h3><p>一个具有五条通路的交叉路口， 当允许某些通路上的车辆在交叉路口通行时，必须对其他通路 上的车辆加以限制，不许同时在交叉路口通行，以免发生碰撞， 求最少用几盏灯来指挥。</p>
<ul>
<li><p>问题分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221193622198.png" alt="image-20220221193622198" style="zoom:80%;" /></p>
<p>​    CE是单行道，A、D、B构成的是双行道</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221193640315.png" alt="image-20220221193640315" style="zoom:67%;" /></p>
<p>将每一条道路抽象成一个结点，线路发生冲突的道路（结点）连线</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221193848066.png" alt="image-20220221193848066" style="zoom:80%;" /></p>
<p><strong>问题转化为：顶点染色问题，相邻的顶点不同色。</strong><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221193907765.png" alt="image-20220221193907765" style="zoom:80%;" /></p>
</li>
<li><p>模型建立</p>
<p>采用<code>无向图</code>来存储结点及其之间的关系，建立邻接矩阵。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221194041665.png" alt="image-20220221194041665" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221194213253.png" alt="image-20220221194213253" style="zoom:80%;" /></p>
</li>
</ul>
<ul>
<li><p>算法设计与描述</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221194358162.png" alt="image-20220221194358162" style="zoom:80%;" /><br>例1-2 交通指挥灯问题 BFS</p>
<p>参考资料：<a href="https://blog.csdn.net/gyuan_/article/details/114654579">https://blog.csdn.net/gyuan_/article/details/114654579</a> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点类型定义</span></span><br><span class="line"><span class="comment">// 定义13个顶点 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="comment">// 路线名称和顶点颜色 </span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> color;</span><br><span class="line">&#125; vertex[<span class="number">13</span>];</span><br><span class="line"><span class="comment">// 邻接矩阵，1表示两个顶点不能通行 </span></span><br><span class="line"><span class="type">int</span> e[<span class="number">13</span>][<span class="number">13</span>]&#123;</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化各结点名称</span></span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">0</span>].name, <span class="string">&quot;AB&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">1</span>].name, <span class="string">&quot;AC&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">2</span>].name, <span class="string">&quot;AD&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">3</span>].name, <span class="string">&quot;BA&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">4</span>].name, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">5</span>].name, <span class="string">&quot;BD&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">6</span>].name, <span class="string">&quot;DA&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">7</span>].name, <span class="string">&quot;DB&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">8</span>].name, <span class="string">&quot;DC&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">9</span>].name, <span class="string">&quot;EA&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">10</span>].name, <span class="string">&quot;EB&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">11</span>].name, <span class="string">&quot;EC&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(vertex[<span class="number">12</span>].name, <span class="string">&quot;ED&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化各个结点的颜色</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">		vertex[i].color = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> cnt_color = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (vertex[i].color == <span class="number">0</span>) &#123;</span><br><span class="line">			vertex[i].color = cnt_color;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;第%d种颜色：%s&quot;</span>,cnt_color,vertex[i].name);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">13</span>; j++) &#123;</span><br><span class="line">				<span class="comment">// 不相邻且没有着色结点j </span></span><br><span class="line">				<span class="keyword">if</span> (e[i][j] == <span class="number">0</span> &amp;&amp; vertex[j].color == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> h = <span class="number">0</span>; h &lt; <span class="number">13</span>; h++) &#123;</span><br><span class="line">						<span class="comment">// 考察与j相邻的顶点的颜色</span></span><br><span class="line">                        <span class="comment">// 若相邻顶点与j同色，不能染色</span></span><br><span class="line">						<span class="keyword">if</span> (e[j][h] == <span class="number">1</span> &amp;&amp; vertex[h].color == cnt_color) &#123;</span><br><span class="line">							<span class="comment">// 若有，则j不能着色 </span></span><br><span class="line">							flag = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 没有相邻且涂同一颜色的结点，可以给j着色 </span></span><br><span class="line">					<span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">						vertex[j].color = cnt_color;	<span class="comment">// 着色</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot; %s&quot;</span>,vertex[j].name);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 用一种颜色能涂都涂完，贪心 </span></span><br><span class="line">			cnt_color++;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;总共%d种颜色\n&quot;</span>,cnt_color<span class="number">-1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  优化：</p>
<ul>
<li>当所有顶点都着色，退出最外层循环。不必循环13次（设置cnt_v统计已着色顶点个数）</li>
</ul>
<ul>
<li><p>算法分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221200332576.png" alt="image-20220221200332576" style="zoom:80%;" /></p>
<p>注：本题答案不唯一</p>
</li>
</ul>
<p>思考题：</p>
<ul>
<li><p>算法设计过程包含几个步骤？</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223082210018.png" alt="image-20220223082210018" style="zoom: 80%;" /></p>
<ul>
<li>算法分析还需要考虑运算（乘除、积分、微分）</li>
<li>测试技巧：考虑覆盖率（例1-1，Euclid和穷举法比较不能使用某个实例评价算法效率）<ul>
<li>两个相似的算法类比</li>
</ul>
</li>
<li>不要信息丢失、挖掘隐含信息、抽象出数据结构</li>
</ul>
</li>
<li><p>哪几个步骤必须？</p>
</li>
<li><p>交通指挥灯问题的算法分析的分析主要对象是什么？</p>
</li>
<li><p>交通指挥灯问题的结果是否唯一？</p>
<p>——顶点划分。</p>
</li>
<li><p>拓展：仿照1-2完成中国地图着色</p>
<ul>
<li>思路：每个省份抽象为一个结点，相邻的结点（省份）不同色</li>
<li>进一步深究：丰富语义——考虑地域风俗、饮食特色</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227112209868.png" alt="image-20220227112209868" style="zoom:67%;" /></p>
</li>
</ul>
<h2 id="算法设计工具"><a href="#算法设计工具" class="headerlink" title="算法设计工具"></a>算法设计工具</h2><h3 id="1-循环设计"><a href="#1-循环设计" class="headerlink" title="1.循环设计"></a>1.循环设计</h3><h4 id="（1）设计思维"><a href="#（1）设计思维" class="headerlink" title="（1）设计思维"></a>（1）设计思维</h4><ul>
<li><p>自底向上——<strong>合并</strong></p>
<p>解决子问题，合并子问题的解，得到大问题的解。</p>
</li>
<li><p>自顶向下——<strong>分解</strong></p>
<p>大问题分解为小问题，找到每个问题的关键，解决小问题。</p>
</li>
</ul>
<p>思考：数据结构中学过的例子</p>
<p>归并排序：先拆分，再合并</p>
<p>自底向上：冒泡排序</p>
<p>自顶向下：二分查找、快排</p>
<h4 id="（2）挖掘内在规律构建计算模型"><a href="#（2）挖掘内在规律构建计算模型" class="headerlink" title="（2）挖掘内在规律构建计算模型"></a>（2）挖掘内在规律构建计算模型</h4><p>挖掘问题的内在规律，进行抽象并构建计算模型</p>
<h4 id="【例1-3】三角矩阵"><a href="#【例1-3】三角矩阵" class="headerlink" title="【例1-3】三角矩阵"></a>【例1-3】三角矩阵</h4><p>设计算法，输出一个n×n的三角矩阵，如图所示规律。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220222211604373.png" alt="image-20220222211604373" style="zoom: 50%;" /></p>
<ul>
<li><p>问题分析</p>
<ul>
<li><p>找相似问题：建立下标和摆放值的映射关系</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223084020198.png" alt="image-20220223084020198" style="zoom:67%;" /></p>
<p>九宫格、旋转矩阵</p>
</li>
<li><p>引入中间变量——斜行</p>
<p>——转化为直角坐标系，$F(i_m) = j_m + L_k$​（对应第k斜行）​​</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223084416612.png" alt="image-20220223084416612" style="zoom:67%;" /></p>
</li>
</ul>
</li>
<li><p>计算模型</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223084744264.png" alt="image-20220223084744264" style="zoom: 67%;" /></p>
</li>
<li><p>算法设计与描述</p>
<p>外层循环为斜行，内层循环一次完成一个斜行，外层循环结束摆放完成</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223084854470.png" alt="image-20220223084854470" style="zoom:67%;" /></p>
</li>
<li><p>算法分析</p>
<p>$f(n) = \sum_{L=0}^{n-1} \sum_{j=0}^{n-L-1} 1 = n+(n-1)+…+1 = \frac{n(n-1)}{2}$​</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223085012327.png" alt="image-20220223085012327" style="zoom:67%;" /></p>
</li>
<li><p>算法实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> a[n][n];</span><br><span class="line">	<span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 逻辑行 </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="comment">// 逻辑列 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n-i; j++) &#123;</span><br><span class="line">			a[i+j][j] = k++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>,a[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（3）改进计算模型提高运算效率"><a href="#（3）改进计算模型提高运算效率" class="headerlink" title="（3）改进计算模型提高运算效率"></a>（3）改进计算模型提高运算效率</h4><h4 id="【例1-4】泰勒公式"><a href="#【例1-4】泰勒公式" class="headerlink" title="【例1-4】泰勒公式"></a>【例1-4】泰勒公式</h4><p>求1/1!-1/3!+1/5!-1/7!+…+$(-1)^{n+1}$/(2n-1)!</p>
<ul>
<li><p>问题分析</p>
<p>求sin的泰勒公式值</p>
<p>迭代方法是在累乘的基础上实现累加</p>
</li>
<li><p>计算模型</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223090030433.png" alt="image-20220223090030433" style="zoom:67%;" /></p>
<p>由（4-1），外层循环累加，内层循环累乘</p>
<p>由（4-2），相邻两项具有规律：利用相邻两项$T_n$​和$T_{n-1}$​的关系避免内层n重循环，减少复杂度</p>
</li>
<li><p>算法设计与描述</p>
<p>体现两重循环：外层循环为n次</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223090517951.png" alt="image-20220223090517951" style="zoom: 67%;" /></p>
</li>
<li><p>算法分析</p>
</li>
</ul>
<h3 id="2-递归设计"><a href="#2-递归设计" class="headerlink" title="2.递归设计"></a>2.递归设计</h3><ul>
<li>定义：一个过程或函数在定义中直接或间接调用自身的一种方法</li>
<li>设计关键：找出递归关系(方程)和递归终止(边界)条件。递归关系就是使问题向边界条件转化的规则</li>
<li>递归设计的步骤：<ul>
<li>分析问题找到递归关系：找出大规模问题与小规模问题的关系，以便通过递归使问题规模变小——能用递归用递归，让递归收敛</li>
<li>设置终止条件控制递归：通过停止条件的设置，找出可解的最小规模问题。</li>
<li>设计函数确定数据传递方式</li>
</ul>
</li>
</ul>
<p>思考：</p>
<ul>
<li><p>递归的效率高or低？</p>
<p>——循环比递归更好</p>
</li>
</ul>
<p>【例】运用递归方式设计求解斐波那契数列的第n项的值</p>
<ul>
<li><p>计算模型</p>
<script type="math/tex; mode=display">
\begin{cases}
f_1 = f_2 = 1 \qquad (5-1) \\ 
f_{n} = f_{n-1} + f_{n-2} \quad ,n \geq 3 \qquad(5-2) \\
\end{cases}</script></li>
<li><p>算法分析</p>
<p>第n项对应n次运算</p>
</li>
<li><p>算法实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fun</span>(x<span class="number">-1</span>)+<span class="built_in">fun</span>(x<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-循环与递归的比较"><a href="#3-循环与递归的比较" class="headerlink" title="3.循环与递归的比较"></a>3.循环与递归的比较</h3><p>【例1-5】任意给定十进制数：</p>
<p>(1)从低位到高位逐位输出各位数字;</p>
<p>(2) 从高位到低位逐位输出各位数字。</p>
<ul>
<li><p>算法实现</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223092001323.png" alt="image-20220223092001323" style="zoom:80%;" /></p>
<ul>
<li>从低位向高位输出：循环和递归的效率相同</li>
<li>从高位向低位输出：递归比循环的功能强大得多（类比树的遍历）</li>
</ul>
</li>
</ul>
<ul>
<li><p>思考：递归和循环的优缺点</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223092831064.png" alt="image-20220223092831064" style="zoom:67%;" /></p>
</li>
<li><p>递归法求斐波那契数列</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">			 <span class="built_in">f</span>(<span class="number">9</span>)</span><br><span class="line">	 <span class="built_in">f</span>(<span class="number">9</span>-<span class="number">1</span>)		   <span class="built_in">f</span>(<span class="number">9</span>-<span class="number">2</span>)</span><br><span class="line"><span class="built_in">f</span>(<span class="number">8</span>-<span class="number">1</span>)	<span class="built_in">f</span>(<span class="number">8</span>-<span class="number">2</span>)	<span class="built_in">f</span>(<span class="number">7</span>-<span class="number">1</span>)	<span class="built_in">f</span>(<span class="number">7</span>-<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>【例1-6】求从n个自然数(1,2,3,…, n)中取出r个数的所有组合。</p>
<h2 id="基本的数据结构"><a href="#基本的数据结构" class="headerlink" title="基本的数据结构"></a>基本的数据结构</h2><h3 id="（1）线性数据结构"><a href="#（1）线性数据结构" class="headerlink" title="（1）线性数据结构"></a>（1）线性数据结构</h3><p>线性表、栈（LIFO）、队列（FIFO）</p>
<h3 id="（2）树"><a href="#（2）树" class="headerlink" title="（2）树"></a>（2）树</h3><p>只有一个双亲结点</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223093104142.png" alt="image-20220223093104142" style="zoom:67%;" /></p>
<p>二叉树使用层数计算效率</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">	TElemtype data;</span><br><span class="line">	Struct BiTNode *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree；</span><br></pre></td></tr></table></figure>
<h3 id="（3）图"><a href="#（3）图" class="headerlink" title="（3）图"></a>（3）图</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223093530012.png" alt="image-20220223093530012" style="zoom:67%;" /></p>
<p>关注：入度、出度</p>
<p><strong>图的表示方法</strong></p>
<ul>
<li>邻接矩阵</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223093621870.png" alt="image-20220223093621870" style="zoom:67%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">	elementtype vertex;</span><br><span class="line">&#125;VNode, v[<span class="number">4</span>];</span><br><span class="line">weight vr[<span class="number">4</span>][<span class="number">4</span>]= &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">                    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>邻接表</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223093730037.png" alt="image-20220223093730037" style="zoom:67%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">V:</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">    vertextype data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">adjvex</span> *firstedge;</span><br><span class="line">&#125;VNode, v[n];</span><br><span class="line"></span><br><span class="line">VR:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">adjvex</span> &#123;</span><br><span class="line">    <span class="type">int</span> seqNo;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">adjvex</span> *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>评价算法看模型</p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第2章 算法分析基础</title>
    <url>/algorithm/algorithm-ch2/</url>
    <content><![CDATA[<p>算法效率评价的指标：算法对计算机资源的使用</p>
<p><strong>时间&gt;&gt;内存</strong></p>
<span id="more"></span>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227163339607.png" alt="image-20220227163339607" style="zoom:67%;" /></p>
<ul>
<li><p>计算机资源的计量方法</p>
<p>设输入数据/问题规模为n。假设算法要用到</p>
<ul>
<li><p>m种元运算；（不再分解，一条指令）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = x+<span class="number">1</span>;</span><br><span class="line">y = y*<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每种元运算执行的时间为$t_1, t_2, … , t_m$；</p>
</li>
<li><p>每种元运算的执行的次数为$e_1, e_2, … e_m$；</p>
</li>
<li><p>元运算与问题规模的关系：$\forall e_i(n), 1 \leq i \leq m$</p>
</li>
</ul>
<p>若用$T(n)$表示时间复杂度，则有$T(n) = \sum_{i = 1}^{m} t_i \times e_i(n)$​ </p>
</li>
<li><p>元运算的提取和时间复杂度的计算</p>
<p>【例2-1】编程输出具有下述特点的n×n阶三角矩阵，试分析该算法的时间复杂度</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227171256853.png" alt="image-20220227171256853" style="zoom: 50%;" /></p>
<blockquote>
<p>只执行一次：</p>
<p>1.i,j,n,k= 1;</p>
<p>2.scanf</p>
<p>3.i = 0;</p>
<p>4.i &lt; n;</p>
<p>第一层循环</p>
<p>1.i &lt; n;</p>
<p>2.i++;</p>
<p>3.j = 0;</p>
<p>4.j &lt; i;</p>
<p>5.printf(“\n”);</p>
<p>第二层循环</p>
<p>1.j &lt; i;</p>
<p>2.j++;</p>
<p>3.printf</p>
<p>4.k++</p>
</blockquote>
<p>​        $T(n) = \sum_{i = 0}^{n-1} (5 + \sum_{j = 0}^{i} 3) + 4 \\ = \frac{3}{2}n^2 + \frac{7}{2}n + 4$​​​</p>
</li>
</ul>
<h2 id="一、数学基础"><a href="#一、数学基础" class="headerlink" title="一、数学基础"></a>一、数学基础</h2><h3 id="1-函数渐近的界"><a href="#1-函数渐近的界" class="headerlink" title="1.函数渐近的界"></a>1.函数渐近的界</h3><h4 id="函数渐近的界的概念"><a href="#函数渐近的界的概念" class="headerlink" title="函数渐近的界的概念"></a>函数渐近的界的概念</h4><p>设$T(n)$​是算法A的时间复杂性函数，n是问题规模，$n \geq 0 $​且$n \in Z$​。</p>
<p>一般来说，当n单调递增且趋于$\infty$时，$T(n)$也将单调递增趋于$\infty$。</p>
<p>对于$T(n)$，如果存在$T’(n)$，使$n \to \infty$时，有$(T(n)-T’(n))/T(n) \to 0$。</p>
<p>那么，我们就说$T’(n)$​是$T(n)$​当$n \to \infty$​时的渐近态，或称$T’(n)$​为算法A当$T(n) \to \infty$​​的渐近复杂性。</p>
<blockquote>
<p>相似性原理</p>
<p>突出主体部分——printf，k++</p>
</blockquote>
<h4 id="定义2-1（阶的概念）"><a href="#定义2-1（阶的概念）" class="headerlink" title="定义2.1（阶的概念）"></a>定义2.1（阶的概念）</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227165538276.png" alt="image-20220227165538276" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227165601851.png" alt="image-20220227165601851" style="zoom:67%;" /></p>
<h5 id="【例2-2】设有函数-f-n-n-2-3n-1-​，当n足够大时，试证明下述内容："><a href="#【例2-2】设有函数-f-n-n-2-3n-1-​，当n足够大时，试证明下述内容：" class="headerlink" title="【例2-2】设有函数$f(n)=n^2+3n+1$​，当n足够大时，试证明下述内容："></a>【例2-2】设有函数$f(n)=n^2+3n+1$​，当n足够大时，试证明下述内容：</h5><p>​    (1) $f(n)=O(n^2)$​和$f(n)=O(n^3)$​成立；</p>
<p>​    (2) $f(n)=o(n^2)$​不成立</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227171405514.png" alt="image-20220227171405514" style="zoom:67%;" /></p>
<ul>
<li>适当放缩</li>
</ul>
<h5 id="【例2-3】试证明-f-n-frac-1-2-n-n-1-有-f-n-Theta-n-2"><a href="#【例2-3】试证明-f-n-frac-1-2-n-n-1-有-f-n-Theta-n-2" class="headerlink" title="【例2-3】试证明$f(n) = \frac{1}{2}n(n-1)$有$f(n) = \Theta(n^2)$"></a>【例2-3】试证明$f(n) = \frac{1}{2}n(n-1)$有$f(n) = \Theta(n^2)$</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227171557402.png" alt="image-20220227171557402" style="zoom:67%;" /></p>
<ul>
<li>限定一下n的范围。找对应的$c_1,c_2$​，一个满足上界、一个满足下界：$c_2g(n) \leq f(n) \leq c_1g(n)$</li>
</ul>
<h4 id="定理2-1（传递性）"><a href="#定理2-1（传递性）" class="headerlink" title="定理2.1（传递性）"></a><strong>定理2.1（传递性）</strong></h4><p>设$f、g、h$是定义域为自然数集合，</p>
<p>如果$f=O(g)$且$g=O(h)$，那么$f=O(h)$； </p>
<p>如果$f=Ω(g)$且$g=Ω(h)$，那么$f=Ω(h)$； </p>
<p>如果$f=Θ(g)$且$g=Θ(h)$，那么$f=Θ(h)$​。</p>
<blockquote>
<p>证明：</p>
<p>只需要证明第一条，第二条同理。前两条可直接推出第三条</p>
<p>按照定义展开，找到合适的$n_0$。取$n_0 = \max\{n_1, n_2 \}$</p>
<p>可以直接推出</p>
</blockquote>
<h4 id="定理2-2-（同阶合并）"><a href="#定理2-2-（同阶合并）" class="headerlink" title="定理2.2 （同阶合并）"></a>定理2.2 （同阶合并）</h4><p>假设$f$和$g$是定义域为自然数集合的函数，若对于某个其他的函数$h$，有$f=O(h)$和$g=O(h)$，那么$f+g=O(h)$​。</p>
<blockquote>
<p>证明：</p>
<p>证明思路与2.1相同，按照定义，找到合适的$n_0$</p>
<p>取$n_0 = \max\{n_1,n_2\}$</p>
</blockquote>
<h4 id="常用的渐近函数及其渐近的界"><a href="#常用的渐近函数及其渐近的界" class="headerlink" title="常用的渐近函数及其渐近的界"></a>常用的渐近函数及其渐近的界</h4><ul>
<li><p>多项式函数、对数函数、不同底a和b的对数</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227170231007.png" alt="image-20220227170231007" style="zoom: 67%;" /></p>
</li>
</ul>
<p>对于多项式函数，每一项的上界都是$n^k$</p>
<p>对于对数函数，<strong>两边取以b为底的对数</strong>，$log_b{a^{log_bn}} = log_b{n^{log_ba}} = log_ba \times log_bn$​​</p>
<h4 id="定理2-3-（多项式的阶高于对数）"><a href="#定理2-3-（多项式的阶高于对数）" class="headerlink" title="定理2.3 （多项式的阶高于对数）"></a>定理2.3 （多项式的阶高于对数）</h4><p>对于每一个$b&gt;1$和每一个$a&gt;0$，有$log_bn=o(n^a)$​。</p>
<p>（多项式函数的阶高于对数函数）</p>
<h4 id="定理2-4（指数的阶高于多项式）"><a href="#定理2-4（指数的阶高于多项式）" class="headerlink" title="定理2.4（指数的阶高于多项式）"></a>定理2.4（指数的阶高于多项式）</h4><p>对每个$a&gt;1$​和每个$k&gt;0$​，有$n^k=o(a^n)$</p>
<p>（指数函数的阶高于多项式函数）</p>
<h3 id="2-利用极限求函数渐近的界"><a href="#2-利用极限求函数渐近的界" class="headerlink" title="2.利用极限求函数渐近的界"></a>2.利用极限求函数渐近的界</h3><h4 id="常用的公式"><a href="#常用的公式" class="headerlink" title="常用的公式"></a>常用的公式</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227170744849.png" alt="image-20220227170744849" style="zoom:67%;" /></p>
<h4 id="定理2-5（紧的界的极限定义）"><a href="#定理2-5（紧的界的极限定义）" class="headerlink" title="定理2.5（紧的界的极限定义）"></a>定理2.5（紧的界的极限定义）</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227170855787.png" alt="image-20220227170855787" style="zoom:67%;" /></p>
<p>两个函数互为紧的界</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227170911299.png" alt="image-20220227170911299" style="zoom:67%;" /></p>
<p>【思考题】：</p>
<ul>
<li>证（3）</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301202430470.png" alt="image-20220301202430470" style="zoom:67%;" /></p>
<ul>
<li>列出已讲解渐近函数及它们之间阶的高低（运用斯特林、洛必达、2.5）</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301202505790.png" alt="image-20220301202505790" style="zoom:67%;" /></p>
<h3 id="3-有用的求和级数及其推导方法"><a href="#3-有用的求和级数及其推导方法" class="headerlink" title="3.有用的求和级数及其推导方法"></a>3.有用的求和级数及其推导方法</h3><h4 id="两个基本法则和常见的数列"><a href="#两个基本法则和常见的数列" class="headerlink" title="两个基本法则和常见的数列"></a>两个基本法则和常见的数列</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227170956453.png" alt="image-20220227170956453" style="zoom:67%;" /></p>
<ul>
<li>调和级数通常使用微积分进行计算</li>
</ul>
<h5 id="【例2-6】求和"><a href="#【例2-6】求和" class="headerlink" title="【例2-6】求和"></a>【例2-6】求和</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227171059943.png" alt="image-20220227171059943" style="zoom:67%;" /></p>
<h5 id="【例2-7】估计-sum-k-1-n-frac-1-k-​的渐近的界"><a href="#【例2-7】估计-sum-k-1-n-frac-1-k-​的渐近的界" class="headerlink" title="【例2-7】估计$\sum_{k=1}^{n} \frac{1}{k}$​的渐近的界"></a>【例2-7】估计$\sum_{k=1}^{n} \frac{1}{k}$​的渐近的界</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220227171113797.png" alt="image-20220227171113797" style="zoom:67%;" /></p>
<h3 id="4-基本效率类型"><a href="#4-基本效率类型" class="headerlink" title="4.基本效率类型"></a>4.基本效率类型</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301205626390.png" alt="image-20220301205626390" style="zoom: 80%;" /></p>
<p>$n^3$：迪杰斯特拉、弗洛伊德算法</p>
<h2 id="二、算法分析实例"><a href="#二、算法分析实例" class="headerlink" title="二、算法分析实例"></a>二、算法分析实例</h2><h3 id="1-非递归形式算法分析"><a href="#1-非递归形式算法分析" class="headerlink" title="1.非递归形式算法分析"></a>1.非递归形式算法分析</h3><p>分析非递归算法是，可遵循以下步骤：</p>
<ul>
<li><p>决定用哪些参数表示输入规模；</p>
</li>
<li><p>找出算法的核心操作，它通常位于算法的<strong>最内层循环</strong>中；</p>
</li>
<li><p>检查核心操作的<strong>执行次数是否依赖于输入规模</strong>。如果它还依赖于一些其他的特性，则可能需要对最差效率、平均效率以及最优效率分别研究；</p>
<blockquote>
<p>快排</p>
</blockquote>
</li>
<li><p>以式（2-1）$T(n) = \sum_{i = 1}^{m} t_i \times e_i(n)$ 的思想为核心，建立一个算法基本操作执行次数的求和表达式；</p>
</li>
<li><p>利用求和运算标准公式和法则来建立一个操作次数的闭合公式，或者至少确定它的增长次数。</p>
</li>
</ul>
<p>【例2-9】交换$a$和$b$的值</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301210324305.png" alt="image-20220301210324305" style="zoom:67%;" /></p>
<p>三种算法：</p>
<ul>
<li><p>如上图方法</p>
</li>
<li><p>加减减运算符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = a+b;</span><br><span class="line">b = a-b;</span><br><span class="line">a = a-b;</span><br></pre></td></tr></table></figure>
</li>
<li><p>异或法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用了位异或运算的特性:一个数据对两一个数据位异或两次，该数本身不变。</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">34</span>;</span><br><span class="line"><span class="comment">// 交换两个整数</span></span><br><span class="line">a = a ^ b;		<span class="comment">// a = 12^34</span></span><br><span class="line">b = a ^ b;		<span class="comment">// b = 12 ^ 34^34=12</span></span><br><span class="line">a = a ^ b;		<span class="comment">// a = 12^ 34 ^12 = 34</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用传参</p>
</li>
<li><p>指针传参</p>
</li>
</ul>
<h5 id="【例2-10】求-n"><a href="#【例2-10】求-n" class="headerlink" title="【例2-10】求$n!$"></a>【例2-10】求$n!$</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301210412937.png" alt="image-20220301210412937" style="zoom:67%;" /></p>
<blockquote>
<p>主体部分：$s = s*i;$</p>
</blockquote>
<h5 id="【例2-11】对于任意给定的-n-阶方阵-A-和-B-，求-A×B-的积-C-并且分析它算法执行效率"><a href="#【例2-11】对于任意给定的-n-阶方阵-A-和-B-，求-A×B-的积-C-并且分析它算法执行效率" class="headerlink" title="【例2-11】对于任意给定的$n$阶方阵$A$和$B$，求$A×B$的积$C$并且分析它算法执行效率"></a>【例2-11】对于任意给定的$n$阶方阵$A$和$B$，求$A×B$的积$C$并且分析它算法执行效率</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301210518138.png" alt="image-20220301210518138" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301210552598.png" alt="image-20220301210552598" style="zoom:67%;" /></p>
<p>优化算法：</p>
<ul>
<li><p>《算法导论》提及的Strassen算法</p>
<p>参考资料：<a href="https://zhuanlan.zhihu.com/p/78657463">详解矩阵乘法中的Strassen算法</a></p>
</li>
</ul>
<h4 id="错误印象"><a href="#错误印象" class="headerlink" title="错误印象"></a>错误印象</h4><ul>
<li><p>循环变量的无规律变化</p>
<blockquote>
<p>如，Euclid和斐波那契</p>
</blockquote>
</li>
<li><p>过于复杂而无法求解的求和表达式</p>
<blockquote>
<p>有些级数不能求解</p>
</blockquote>
</li>
<li><p>算法分析时固有的难度</p>
</li>
</ul>
<p>【思考题】韩信点兵问题</p>
<h3 id="2-递归形式算法分析"><a href="#2-递归形式算法分析" class="headerlink" title="2.递归形式算法分析"></a>2.递归形式算法分析</h3><p>分析递归算法时，可遵循以下步骤：</p>
<ul>
<li><p>决定用哪些参数作为输入规模的度量标准</p>
</li>
<li><p>找出算法的核心操作，它通常是<strong>递推公式</strong></p>
</li>
<li><p>检查一下，对于相同规模的不同输入，核心操作的执行次数是否可能不同</p>
<p><strong>如果有这种可能，则必须对最差效率、平均效率以及最优效率做单独研究</strong></p>
</li>
<li><p>对于算法核心操作的执行次数，建立一个递推关系以及相应的边界条件</p>
</li>
<li><p>解这个递推式，或者至少<strong>确定它的解的增长次数</strong></p>
</li>
</ul>
<h5 id="【例2-12】求-n"><a href="#【例2-12】求-n" class="headerlink" title="【例2-12】求$n!$"></a>【例2-12】求$n!$</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301212808470.png" alt="image-20220301212808470" style="zoom:67%;" /></p>
<p>时间效率紧的界是n</p>
<blockquote>
<p>递归变非递归：</p>
<p>1.减少重复计算——去重</p>
<p>2.减少使用栈——效率低。应从模型入手</p>
</blockquote>
<h5 id="【例2-13】汉诺塔问题"><a href="#【例2-13】汉诺塔问题" class="headerlink" title="【例2-13】汉诺塔问题"></a>【例2-13】汉诺塔问题</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301212841660.png" alt="image-20220301212841660" style="zoom:67%;" /></p>
<ul>
<li>n为计算规模</li>
<li>核心操作为移动盘子 </li>
<li>依据递推公式，两次递推之间，执行一次移动操作，因此有如下推导过程：<br>$T(n) =2T(n-1)+1$</li>
</ul>
<blockquote>
<p>$T(n) =2T(n-1)+1 \\<br>=2[2T(n-2)+1]+1 \\ =2^2T(n-2)+2+1 \\<br>=2^2[2T(n-3)+1]+2+1 \\ = 2^3T(n-3)+2^2+2+1 …… \\<br>=2^{i-1}[2T(n-i)+1]+2^{i-2}+2^{i-3}…+2^0 \\ = 2^iT(n-i)+ 2^{i}-1 …… \\<br>=2^{n-1}T(n-(n-1))+ 2^{n-1}-1 \\ =2^{n-1}T(1)+ 2^{n-1}-1=2^n-1 \$</p>
</blockquote>
<p><strong>谨慎使用递归算法，它们的简洁可能会掩盖其低效率的事实</strong></p>
<h5 id="【例2-14】试分析二路归并排序算法的时间复杂度"><a href="#【例2-14】试分析二路归并排序算法的时间复杂度" class="headerlink" title="【例2-14】试分析二路归并排序算法的时间复杂度"></a>【例2-14】试分析二路归并排序算法的时间复杂度</h5><blockquote>
<p>二路归并排序：二分 + 合并（简单插入排序）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301213658379.png" alt="image-20220301213658379" style="zoom:67%;" /></p>
<p>对于Merge，输入是两个排好序的数组。</p>
<blockquote>
<p>计算两个数组的长度</p>
<p>重构$A$数组，将前半部分存入$B$，后半部分存入$C$</p>
<p>依次比较$B$和$C$元素大小，按顺序放回$A$</p>
<p>处理$B$或$C$剩余元素，放回$A$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301213722688.png" alt="image-20220301213722688" style="zoom:67%;" /></p>
<p>空间复杂度：上界是$n^2$，下界是$logn \times n$</p>
<p>【思考题】考虑完全二叉树的先根遍历，找最大值的时间复杂度</p>
<h3 id="定理2-6（主定理）——重要内容"><a href="#定理2-6（主定理）——重要内容" class="headerlink" title="定理2.6（主定理）——重要内容"></a>定理2.6（主定理）——重要内容</h3><p><strong>定理2.6</strong> 主定理（Master Theorem）设$a \geq 1,b \geq 1$为常数，$f(n)$为函数，$T(n)$为<strong>非负整数</strong>，且$T(n) = aT(n/b) + f(n)$</p>
<p>则有以下结果：</p>
<ul>
<li><p>若$f(n) = O(n^{log_ba-\epsilon}), \epsilon &gt; 0$，那么$T(n) = \Theta(n^{log_ba})$；</p>
<blockquote>
<p>必须把$\epsilon$找出来</p>
</blockquote>
</li>
<li><p>若$f(n) = \Theta (n^{log_ba})$，那么$T(n) = \Theta (n^{log_ba} logn)$；</p>
</li>
<li><p>若$f(n) = Ω(n^{log_ba+\epsilon}), \epsilon &gt; 0$，且对于常数$c&lt;1$和所有充分大的$n$有$af(n/b) \leq cf(n)$，那么$T(n) = \Theta(f(n))$；</p>
<blockquote>
<p>不能使用主定理，可以使用递归式</p>
</blockquote>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231134023.png" alt="image-20220301231134023" style="zoom:67%;" /></p>
<blockquote>
<p>必须让$T(n)$中的参数$n$收敛</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231214720.png" alt="image-20220301231214720" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231230067.png" alt="image-20220301231230067" style="zoom:67%;" /></p>
<blockquote>
<p>（3）的整体证明思路：$T(n) = O(f(n)) \and T(n) = \Omega(f(n))$</p>
<p>①显然有：$T(n) \geq f(n)$</p>
<p>②需要证明$T(n) \leq \Theta(f(n))$。利用条件$af(n/b) \leq cf(n)$进行放缩</p>
<p>最后需要用上$f(n)$的阶比$c_1n^{log_ba}$高的条件，使用定理2.2进行合并</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231245912.png" alt="image-20220301231245912" style="zoom:67%;" /></p>
<p>【思考题】</p>
<ul>
<li>自己证明一次主定理</li>
<li>用主定理证明归并排序的时间复杂度</li>
</ul>
<h5 id="【例2-15】求解递推方程-T-n-9T-n-3-n"><a href="#【例2-15】求解递推方程-T-n-9T-n-3-n" class="headerlink" title="【例2-15】求解递推方程$T(n) = 9T(n/3) + n$"></a>【例2-15】求解递推方程$T(n) = 9T(n/3) + n$</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231338193.png" alt="image-20220301231338193" style="zoom:67%;" /></p>
<h5 id="【例2-16】求解递推方程-T-n-T-2n-3-1"><a href="#【例2-16】求解递推方程-T-n-T-2n-3-1" class="headerlink" title="【例2-16】求解递推方程$T(n) = T(2n/3) + 1$"></a>【例2-16】求解递推方程$T(n) = T(2n/3) + 1$</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231416380.png" alt="image-20220301231416380" style="zoom:67%;" /></p>
<h5 id="【例2-17】求解递推方程-T-n-3T-n-4-nlogn"><a href="#【例2-17】求解递推方程-T-n-3T-n-4-nlogn" class="headerlink" title="【例2-17】求解递推方程$T(n) = 3T(n/4) + nlogn$"></a>【例2-17】求解递推方程$T(n) = 3T(n/4) + nlogn$</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231458494.png" alt="image-20220301231458494" style="zoom:67%;" /></p>
<p>递归树</p>
<p>表示每一层拥有的计算量</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231522615.png" alt="image-20220301231522615" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231537308.png" alt="image-20220301231537308" style="zoom:67%;" /></p>
<h5 id="【例2-18】以下递归方程，是第四章将介绍的二分算法典型的递归方程。同样假设-n-2-k-："><a href="#【例2-18】以下递归方程，是第四章将介绍的二分算法典型的递归方程。同样假设-n-2-k-：" class="headerlink" title="【例2-18】以下递归方程，是第四章将介绍的二分算法典型的递归方程。同样假设$n = 2^k$："></a>【例2-18】以下递归方程，是第四章将介绍的二分算法典型的递归方程。同样假设$n = 2^k$：</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301231641596.png" alt="image-20220301231641596" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第3章 迭代法</title>
    <url>/algorithm/algorithm-ch3/</url>
    <content><![CDATA[<h2 id="3-1-简单的迭代运算"><a href="#3-1-简单的迭代运算" class="headerlink" title="3.1 简单的迭代运算"></a>3.1 简单的迭代运算</h2><ul>
<li><p>迭代（辗转法）</p>
<p>是一种不断用变量的旧值递推新值的过程</p>
</li>
<li><p>分类</p>
<ul>
<li>精准迭代：杨辉三角、内在移动算法等</li>
<li>近似迭代：二分法和牛顿迭代法</li>
</ul>
</li>
<li><p>设计方法</p>
<ul>
<li>确定迭代模型</li>
<li>控制迭代过程</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="【例3-1】输出如图4-1的杨辉三角形"><a href="#【例3-1】输出如图4-1的杨辉三角形" class="headerlink" title="【例3-1】输出如图4-1的杨辉三角形"></a>【例3-1】输出如图4-1的杨辉三角形</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307133002224.png" alt="image-20220307133002224" style="zoom: 67%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> ans[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">	<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">	ans[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="comment">// 行初和行末的初始化 </span></span><br><span class="line">		ans[i][<span class="number">0</span>] = ans[i][i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 递推公式 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i<span class="number">-1</span>; j++)	ans[i][j] = ans[i<span class="number">-1</span>][j<span class="number">-1</span>] + ans[i<span class="number">-1</span>][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)	<span class="built_in">printf</span>(<span class="string">&quot;%-3d&quot;</span>,ans[i][j]);</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用一维数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>*<span class="number">99</span>/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">1 3 3 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Yanghui</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> begin = <span class="number">0</span>;  <span class="comment">// 计算行初位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 行首和行尾为1</span></span><br><span class="line">        a[begin+<span class="number">1</span>] = a[begin+i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;   <span class="comment">// 行中根据公式迭代</span></span><br><span class="line">            a[begin+j] = a[begin-(i)+j] + a[begin-(i<span class="number">-1</span>)+j];</span><br><span class="line">        &#125;</span><br><span class="line">        begin += i; <span class="comment">// 更新下一行的行初位置（本行的行尾）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            cout &lt;&lt; a[k++] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Yanghui</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="【例3-2】穿越沙漠问题"><a href="#【例3-2】穿越沙漠问题" class="headerlink" title="【例3-2】穿越沙漠问题"></a>【例3-2】穿越沙漠问题</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307133019008.png" alt="image-20220307133019008" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307133040216.png" alt="image-20220307133040216" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307133648577.png" alt="image-20220307133648577" style="zoom: 67%;" /></p>
<p>【参考资料】<a href="https://blog.csdn.net/weixin_43983838/article/details/88125782">穿越沙漠问题（递推法）</a></p>
<blockquote>
<p>储油点地址的确定比较复杂，从出发点考虑问题，很难确保按要求以最少的耗油量穿越沙漠，即很难保证到达终点时，沙漠中的各临时油库和车的储油量都恰好为0。所以我们从终点向起点应用逆推法。<br>过程：</p>
<p>为了做到耗油最少，那么每次吉普车出发时都应满载，放下一部分油再返回时，油恰好用完，并且把下一个油库建好后这个油库中的油恰好用完。所以每个点的油库中的油都应是吉普车装油量的整数倍(因为出发时满载)，即500n(n为正整数)，并且每个点的 存油量为下一个点的存油量及吉普车为建立下个油库在两点之间往返的油耗之和 (下一个油库建成，前一个油库中的油恰好用完)。</p>
<p>（1）由题可知，吉普车满载可以走500km。所以，第一段（即离终点最近的一段）长度为500km，并且，第一个加油点station_1（也是离终点最近的）的储油量为500L。<br>（2）那我们来看第二个加油点station_2。<br>它需要储存上一个加油点的储油量 + 车来往的耗油量。为了给station_1送500L油，车至少送两次油（因为中间路程要耗油嘛）。所以，车往返路程共3趟。<br>又考虑最少油耗，我们使这3趟路程耗油500L。那么station_2距station_1为500/3 = 167km，总共储油1000L。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            （3）同样，我们看station_3。<br>为了给station_2送1000L油，至少送3次嘛，所以往返共5趟。<br>同样考虑耗油最少，那么station_3距station_2为 500/5 = 100km。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> distance; std::cin &gt;&gt; distance;</span><br><span class="line">	<span class="type">int</span> dis = <span class="number">500</span>, oil = <span class="number">500</span>, n = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (dis &lt; distance) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个加油站：储油量&quot;</span> &lt;&lt; oil &lt;&lt; <span class="string">&quot;L；距离终点&quot;</span> &lt;&lt; dis &lt;&lt; <span class="string">&quot;KM&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">		++n;</span><br><span class="line">		<span class="comment">// 每一趟包含前面的油 </span></span><br><span class="line">		dis = dis + <span class="number">500</span>/(<span class="number">2</span>*n<span class="number">-1</span>);</span><br><span class="line">		oil = oil + <span class="number">500</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dis = distance - (dis - <span class="number">500</span>/(<span class="number">2</span>*n<span class="number">-1</span>));</span><br><span class="line">	oil = oil - <span class="number">500</span> + dis*(<span class="number">2</span>*n<span class="number">-1</span>);</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个加油站：储油量&quot;</span> &lt;&lt; oil &lt;&lt; <span class="string">&quot;L；距离起点&quot;</span> &lt;&lt; distance &lt;&lt; <span class="string">&quot;KM&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>算法分析：</p>
<ul>
<li><p>问题规模是由distance控制的，与n相关的</p>
</li>
<li><p>核心语句是while循环中的语句，但是由这些语句推出它的时间复杂度较为困难。如果变换为两加油站之间的距离，则其规律如下：</p>
<blockquote>
<p>500+500/3+500/5+…+500/(2n+1) $\leq$ distance</p>
</blockquote>
</li>
</ul>
<script type="math/tex; mode=display">
n = f(distanc,dis) \\
= ln(n+1) + r - \frac{1}{2}(ln(n+1)+r) + \frac{1}{n+1} +\frac{1}{n+2} + ... + \frac{1}{n+n} \\
= \frac{1}{2}ln(n+1) + C\\
\geq d/a \\ 
\to ln(n+1) \geq 2(d/a+C)\\
\to n = e^{d/a-C} + 1 \\
T(n) = T(a,d) = O(e^{d/a-C}+1) = O(e^{d/a-C})\\</script></li>
</ul>
<h3 id="【例3-3】内存移动问题"><a href="#【例3-3】内存移动问题" class="headerlink" title="【例3-3】内存移动问题"></a>【例3-3】内存移动问题</h3><ul>
<li>问题分析</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307152154641.png" alt="image-20220307152154641" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307152213540.png" alt="image-20220307152213540" style="zoom: 67%;" /></p>
<p>两种方式：</p>
<p>两个数组</p>
<p>一个数组，一个辅助变量，移动k次</p>
<p>优化：减少k——（i+k）%n</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307152319822.png" alt="image-20220307152319822" style="zoom: 67%;" /></p>
<ul>
<li>计算模型</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307152336508.png" alt="image-20220307152336508" style="zoom: 67%;" /></p>
<ul>
<li><p>算法描述与分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307152409287.png" alt="image-20220307152409287" style="zoom: 67%;" /></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="type">int</span> r = x % y;	x = y;	y = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memory_move</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// n和k的最大公约数，移动的轮数 </span></span><br><span class="line">	<span class="type">int</span> Q = <span class="built_in">gcd</span>(n,k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Q; i++) &#123;</span><br><span class="line">		<span class="type">int</span> t = a[i], m = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n/Q; j++) &#123;</span><br><span class="line">			m = (m + k) % n;</span><br><span class="line">			<span class="comment">// 交换a[m]和t </span></span><br><span class="line">			std::<span class="built_in">swap</span>(t,a[m]); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">	<span class="built_in">memory_move</span>(<span class="number">5</span>,<span class="number">2</span>,a);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) std::cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改进：运算最后一次：j = n/q-1——末尾元素位置对应移动轮数</li>
</ul>
<h3 id="【例3-4】编程求当-n-leq-100-时，-n-的准确值"><a href="#【例3-4】编程求当-n-leq-100-时，-n-的准确值" class="headerlink" title="【例3-4】编程求当$n \leq 100$时，$n!$的准确值"></a>【例3-4】编程求当$n \leq 100$时，$n!$的准确值</h3><ul>
<li>问题分析</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309083111599.png" alt="image-20220309083111599" style="zoom:67%;" />        </p>
<ul>
<li><p>竖式乘法原理</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309083537051.png" alt="image-20220309083537051" style="zoom:67%;" /></p>
<ul>
<li>需要注意对0的处理——整数需要添加0</li>
</ul>
</li>
<li><p>计算模型</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309084016286.png" alt="image-20220309084016286" style="zoom: 67%;" /></p>
</li>
<li><p>算法设计与描述</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309084417861.png" alt="image-20220309084417861" style="zoom:67%;" /></p>
</li>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Q 1000000</span></span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算补0个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = x, b = Q;</span><br><span class="line">    <span class="type">int</span> ca = <span class="number">0</span>, cb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a || b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a) &#123;</span><br><span class="line">            ++ca; a /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            ++cb; b /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cb - ca - <span class="number">1</span>; <span class="comment">// 注意-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bigdigital</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a)); <span class="type">int</span> len = <span class="number">1</span>, j;</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>; <span class="comment">// 向高位的进位</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len; j++) &#123;</span><br><span class="line">            <span class="type">int</span> b = a[j]*i + d; <span class="comment">// 计算该单元的计算结果</span></span><br><span class="line">            a[j] = b % Q;  <span class="comment">// 更新单元数据</span></span><br><span class="line">            d = b / Q;   <span class="comment">// 更新进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d != <span class="number">0</span>) &#123;   <span class="comment">// 存在高位进位，开辟下一个单元</span></span><br><span class="line">            ++len;	a[j] = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; a[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">length</span>(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; L; k++) cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        cout &lt;&lt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">Bigdigital</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="【思考题】设a和b两个数为大数，求a-b的值"><a href="#【思考题】设a和b两个数为大数，求a-b的值" class="headerlink" title="【思考题】设a和b两个数为大数，求a*b的值"></a>【思考题】设a和b两个数为大数，求a*b的值</h3><ul>
<li><p>问题分析：</p>
<p>将问题分为两步：①表示a和b两个大数；②完成大数乘法运算</p>
</li>
<li><p>算法设计与分析</p>
<p>$a：a[1], a[2], … , a[size_a]$</p>
<p>$b：b[1], b[2], … , b[size_b]$</p>
<p>$c：a[1]\times b[1], a[1]\times b[2] + a[2]\times b[1] + d, … $</p>
</li>
<li><p>算法实现</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Q 10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Qbit 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bigdigital</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num[MAXN];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bigdigital</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Bigdigital</span>(string s) &#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; s.size() &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; s &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="built_in">sizeof</span>(num));</span><br><span class="line">        stringstream ss; <span class="type">int</span> val, index = <span class="number">0</span>; string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % Qbit) &#123;  <span class="comment">// 考虑最高位不满Qbit位的情况</span></span><br><span class="line">            length = s.<span class="built_in">size</span>()/Qbit+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; s.<span class="built_in">size</span>() % Qbit ; k++) &#123;</span><br><span class="line">                temp += s[index++];</span><br><span class="line">            &#125;</span><br><span class="line">            ss &lt;&lt; temp; ss &gt;&gt; val;  num[length] = val;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                stringstream sss;</span><br><span class="line">                temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Qbit; j++) &#123;</span><br><span class="line">                    temp += s[index++];</span><br><span class="line">                &#125;</span><br><span class="line">                sss &lt;&lt; temp; sss &gt;&gt; val; num[i] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 最高位的位数恰好为Qbit位</span></span><br><span class="line">            length = s.<span class="built_in">size</span>() / Qbit;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = length; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">                stringstream sss;</span><br><span class="line">                temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= Qbit; j++) &#123;</span><br><span class="line">                    temp += s[index++];</span><br><span class="line">                &#125;</span><br><span class="line">                sss &lt;&lt; temp; sss &gt;&gt; val; num[i] = val;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[i] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算补0个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">zerolength</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, number = x;</span><br><span class="line">        <span class="keyword">while</span> (number) &#123;</span><br><span class="line">            ++ans; number /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Qbit-ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出大数结果</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> zl = <span class="built_in">zerolength</span>(num[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; zl; ++j) cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            cout &lt;&lt; num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; length &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Bigdigital <span class="title">Cal</span><span class="params">(Bigdigital a, Bigdigital b)</span> </span>&#123;</span><br><span class="line">    Bigdigital c; c.length = <span class="number">1</span>; <span class="comment">// 初始化结果c</span></span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;  <span class="comment">// 进位</span></span><br><span class="line">    <span class="comment">// 竖式乘法原理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= b.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a.length; j++) &#123;</span><br><span class="line">            </span><br><span class="line">            c.num[i+j<span class="number">-1</span>] += b.num[i]*a.num[j];</span><br><span class="line">            c.length = <span class="built_in">max</span>(c.length,i+j<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i+j-1 &lt;&lt; &quot; &quot; &lt;&lt; b.num[i] &lt;&lt; &quot; &quot; &lt;&lt; a.num[j] &lt;&lt; &quot; &quot; &lt;&lt; c.num[i+j-1] &lt;&lt; &quot; &quot; &lt;&lt; c.length &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = c.num[i]+d;</span><br><span class="line">        c.num[i] = temp % Q;</span><br><span class="line">        d = temp / Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d != <span class="number">0</span>) &#123;</span><br><span class="line">        c.length++;</span><br><span class="line">        c.num[c.length] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Bigdigital <span class="title">a</span><span class="params">(<span class="string">&quot;1234567890&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Bigdigital <span class="title">b</span><span class="params">(<span class="string">&quot;9999999990&quot;</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">show</span>();</span><br><span class="line">    b.<span class="built_in">show</span>();</span><br><span class="line">    Bigdigital c = <span class="built_in">Cal</span>(a,b);</span><br><span class="line">    c.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309135022824.png" alt="image-20220309135022824"></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309135116475.png" alt="image-20220309135116475" style="zoom:67%;" /></p>
<h2 id="3-2-求解方程的近似算法"><a href="#3-2-求解方程的近似算法" class="headerlink" title="3.2 求解方程的近似算法"></a>3.2 求解方程的近似算法</h2><h3 id="非线性方程"><a href="#非线性方程" class="headerlink" title="非线性方程"></a>非线性方程</h3><blockquote>
<p>问：两个$n \times n$矩阵运算迭代次数的极限是多少？</p>
<p>——$O(n^{2.3})$但是每一次运算的复杂度较高</p>
</blockquote>
<h4 id="非线性方程的收敛性及收敛速度"><a href="#非线性方程的收敛性及收敛速度" class="headerlink" title="非线性方程的收敛性及收敛速度"></a>非线性方程的收敛性及收敛速度</h4><ul>
<li><p><strong>定义3.1</strong> 设$x_k$是方程$f(x)=0$的根，若存在$x_k$的一个邻域$\Delta$，当初值以属于$\Delta$时，迭代收敛，则称该迭代过程具有局部收敛性。</p>
<blockquote>
<p>注：局部不收敛不意味着无解。确定好邻域避免发散</p>
</blockquote>
</li>
<li><p><strong>定义3.2</strong> 设$\epsilon_k = x^* - x_k$为第k个迭代的迭代误差，若$\lim_{k \to \infty} \frac{|\epsilon_{k+1}|}{| \epsilon_k |^p} = c \neq 0$。则称迭代是p阶收敛的。称c为渐近误差函数。</p>
<blockquote>
<p>阶很重要，越迭代，阶越小</p>
<p>阶与误差有关，误差与计算效率有关</p>
</blockquote>
</li>
<li><p><strong>定义3.3</strong> 称$EI = p^{\frac{1}{\theta}}$为效率指数，其中，$\theta$表示每次迭代的计算量，p表示迭代的收敛阶。</p>
</li>
<li><p><strong>定理3.1</strong>  若当$x \in [a,b]$时，$\phi(x) \in [a,b]$，且$\phi(x)$满足$|\phi’(x)| \leq L &lt; 1$，$x \in [a,b]$。则迭代收敛于唯一的根。</p>
<blockquote>
<p>构造求解方程的方程式</p>
<p>由$f(x)$构造迭代方程，向解靠近</p>
<p>需要迭代方程收敛</p>
</blockquote>
</li>
</ul>
<h4 id="建立迭代方程"><a href="#建立迭代方程" class="headerlink" title="建立迭代方程"></a>建立迭代方程</h4><ul>
<li>选取适当的初值$x_0$；</li>
<li>建立迭代方程，将方程$f(x) = 0$转换成$x = \phi(x)$的等价形式； </li>
<li>运用迭代方程$x = \phi(x)$，反复计算，如$x_1 = \phi(x_0)$，$x_2 = \phi(x_1), … , x_n = \phi(x_{n-1})$。得到x的序列，若该数列收敛，则最终可以得到满足一定精度$\epsilon$的解，即有$|x_n - x_{n-1}| &lt; \epsilon$。有时候也会用$f(x_{n}) \leq \epsilon$ 或$f(x_n) = 0$来判断。</li>
</ul>
<h5 id="【例3-5】求-9x-2-sinx-1-0-，在-0-1-之间的解，要求-9x-2-sinx-1-lt-0-00001"><a href="#【例3-5】求-9x-2-sinx-1-0-，在-0-1-之间的解，要求-9x-2-sinx-1-lt-0-00001" class="headerlink" title="【例3-5】求$9x^2 - sinx -1 = 0$，在$(0,1)$之间的解，要求$|9x^2-sinx-1| &lt; 0.00001$"></a>【例3-5】求$9x^2 - sinx -1 = 0$，在$(0,1)$之间的解，要求$|9x^2-sinx-1| &lt; 0.00001$</h5><ul>
<li><p>问题分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309091036849.png" alt="image-20220309091036849" style="zoom:50%;" /></p>
</li>
<li><p>计算模型</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309091205962.png" alt="image-20220309091205962" style="zoom: 50%;" /></p>
<blockquote>
<p>效率衡量：达到相同精度的迭代次数</p>
</blockquote>
<ul>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代方程：x = (sinx+1)^(1/2)/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">equation</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x1 = x, x0 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(x1-x0) &gt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">       ++cnt;</span><br><span class="line">       x0 = x1;</span><br><span class="line">       x1 = <span class="built_in">sqrt</span>(<span class="built_in">sin</span>(x0)+<span class="number">1</span>)/<span class="number">3.0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.4</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309141137838.png" alt="image-20220309141137838"></p>
</li>
</ul>
</li>
</ul>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220306222435439.png" alt="image-20220306222435439" style="zoom:67%;" /></p>
<h5 id="二分法的时间渐近复杂度分析"><a href="#二分法的时间渐近复杂度分析" class="headerlink" title="二分法的时间渐近复杂度分析"></a>二分法的时间渐近复杂度分析</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220306222529276.png" alt="image-20220306222529276" style="zoom:67%;" /></p>
<blockquote>
<p>效率衡量：达到运算精度需要的迭代次数，与计算出来的k相比较</p>
</blockquote>
<h5 id="【例3-6】用二分法求-9x-2-sinx-1-0-，在-0，1-之间的解，要求-x-k-x-k-1-lt-0-00001-。"><a href="#【例3-6】用二分法求-9x-2-sinx-1-0-，在-0，1-之间的解，要求-x-k-x-k-1-lt-0-00001-。" class="headerlink" title="【例3-6】用二分法求$9x^2-sinx-1=0$，在$(0，1)$之间的解，要求$|x_k-x_{k-1}| &lt; 0.00001$。"></a>【例3-6】用二分法求$9x^2-sinx-1=0$，在$(0，1)$之间的解，要求$|x_k-x_{k-1}| &lt; 0.00001$。</h5><ul>
<li><p>计算模型</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309092219816.png" alt="image-20220309092219816" style="zoom:50%;" /></p>
</li>
<li><p>算法设计与描述</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309092247221.png" alt="image-20220309092247221" style="zoom:67%;" /></p>
<blockquote>
<p>二分法没有迭代法效率高</p>
</blockquote>
</li>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">F</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">9</span>*<span class="built_in">pow</span>(x,<span class="number">2</span>) - <span class="built_in">sin</span>(x) - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">equation</span><span class="params">(<span class="type">double</span> x1, <span class="type">double</span> x2)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> f1 = <span class="built_in">F</span>(x1), f2 = <span class="built_in">F</span>(x2), f = <span class="number">1.0</span>, x = x1, x3 = x2;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">if</span> (f1 * f2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fabs</span>(x-x3) &gt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">            x = (x1 + x2)/<span class="number">2.0</span>;</span><br><span class="line">            f = <span class="built_in">F</span>(x);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (f * f1 &gt; <span class="number">0</span>) &#123;   <span class="comment">// 向后半区[x,x2]二分</span></span><br><span class="line">                x3 = x1; x1 = x;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 向前半区[x1,x]二分</span></span><br><span class="line">                x3 = x2; x2 = x;</span><br><span class="line">            &#125;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">30</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.0</span>,<span class="number">0.4</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.0</span>,<span class="number">0.5</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311175417804.png" alt="image-20220311175417804"  /></p>
</li>
</ul>
</li>
</ul>
<h4 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h4><p>$f(x) = f(x_0) + f’(x_0)(x-x_0)$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308201115399.png" alt="image-20220308201115399" style="zoom:67%;" /></p>
<p>牛顿法需要进行判断收敛</p>
<h5 id="牛顿法的时间复杂度分析"><a href="#牛顿法的时间复杂度分析" class="headerlink" title="牛顿法的时间复杂度分析"></a>牛顿法的时间复杂度分析</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308201141988.png" alt="image-20220308201141988" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308201352032.png" alt="image-20220308201352032" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308201408592.png" alt="image-20220308201408592" style="zoom:67%;" /></p>
<h5 id="【例3-7】用牛顿法求-9x-2-sinx-1-0-，在-0-1-之间的解，要求-x-k-x-k-1-lt-0-00001"><a href="#【例3-7】用牛顿法求-9x-2-sinx-1-0-，在-0-1-之间的解，要求-x-k-x-k-1-lt-0-00001" class="headerlink" title="【例3-7】用牛顿法求$9x^2-sinx-1=0$，在$(0,1)$之间的解，要求$|x_k-x_{k-1}|$&lt;0.00001"></a>【例3-7】用牛顿法求$9x^2-sinx-1=0$，在$(0,1)$之间的解，要求$|x_k-x_{k-1}|$&lt;0.00001</h5><ul>
<li>计算模型</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309094457168.png" alt="image-20220309094457168" style="zoom:50%;" /></p>
<blockquote>
<p>取常数和导数的区别：导数为爬山法</p>
</blockquote>
<ul>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">equation</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> x1 = x, x2 = x1 - (<span class="number">9</span>*x1*x1 - <span class="built_in">sin</span>(x1) - <span class="number">1</span>) / (<span class="number">18</span>*x1 - <span class="built_in">cos</span>(x1));</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(x1-x2) &gt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">        x1 = x2;</span><br><span class="line">        x2 = x1 - (<span class="number">9</span>*x1*x1 - <span class="built_in">sin</span>(x1) - <span class="number">1</span>) / (<span class="number">18</span>*x1 - <span class="built_in">cos</span>(x1)); </span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.4</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行截图</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309143047300.png" alt="image-20220309143047300"></p>
</li>
</ul>
<p>【思考题】用牛顿法求$x^3-cosx-1=0$，在$(0,1)$之间的解，要求$|x_k-x_{k-1}| &lt; 0.00001。$</p>
<ul>
<li>计算模型</li>
</ul>
<blockquote>
<p>$f(x) = x^3-cosx-1$</p>
<p>$f’(x) = 3x^2 + sinx$</p>
<p>得$x_2 = x_1 - \frac{x_1^3-cosx_1-1}{3x_1^2 + sinx_1} \quad (|x_1-x_2| &gt; 0.00001)$</p>
</blockquote>
<ul>
<li>算法描述</li>
</ul>
<blockquote>
<p>equation(x) {</p>
<p>​    $x_1$ $\leftarrow$ x;     $x_2$ $\leftarrow$  $x_1 - \frac{x_1^3-cosx_1-1}{3x_1^2 + sinx_1}$</p>
<p>​    while($|x_1-x_2| &gt; 0.00001$) {</p>
<p>​        $x_1$ $\leftarrow$ $x_2$;     $x_2$ $\leftarrow$  $x_1 - \frac{x_1^3-cosx_1-1}{3x_1^2 + sinx_1}$</p>
<p>​    }</p>
<p>​    return $ x_2$;</p>
<p>}</p>
</blockquote>
<ul>
<li>算法实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">equation</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> x1 = x, x2 = x1 - (x1*x1*x1 - <span class="built_in">cos</span>(x1) - <span class="number">1</span>) / (<span class="number">3</span>*x1*x1 + <span class="built_in">sin</span>(x1));</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(x1-x2) &gt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">        x1 = x2;</span><br><span class="line">        x2 = x1 - (x1*x1*x1 - <span class="built_in">cos</span>(x1) - <span class="number">1</span>) / (<span class="number">3</span>*x1*x1 + <span class="built_in">sin</span>(x1));</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> x2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">equation</span>(<span class="number">0.5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：在(0,1)之间无解</p>
<h3 id="线性代数方程组"><a href="#线性代数方程组" class="headerlink" title="线性代数方程组"></a>线性代数方程组</h3><p>设线性代数方程组具有如下特征</p>
<script type="math/tex; mode=display">
\begin{cases}
a_{11}x_1 + a_{12}x_2 + ... + a_{1n}x_n = b_1 \\
a_{21}x_1 + a_{22}x_2 + ... + a_{2n}x_n = b_2 \\
\qquad \qquad \qquad...... \\
a_{n1}x_1 + a_{n2}x_2 + ... + a_{nn}x_n = b_n \\
\end{cases}</script><ul>
<li>算法框架<ul>
<li>设置线性代数方程组的初值为$X = {x_1, … , x_{n-1}, x_n}$；</li>
<li>构造迭代方程$x_i = g_i(X)$，($i = 1,…,n-1,n$)及精度求解方法；</li>
<li>达到迭代次数或精度结束迭代。</li>
</ul>
</li>
</ul>
<h4 id="Jacobi算法"><a href="#Jacobi算法" class="headerlink" title="Jacobi算法"></a>Jacobi算法</h4><script type="math/tex; mode=display">
\begin{cases}
x_1^{(k+1)} = \frac{1}{a_{11}} (b_1 - a_{12}x_2^{(k)} - ... - a_{1n}x_n^{(k)}) \\
x_2^{(k+1)} = \frac{1}{a_{22}} (b_2 - a_{21}x_1^{(k)} - ... - a_{2n}x_n^{(k)}) \\
x_1^{(k+1)} = \frac{1}{a_{nn}} (b_n - a_{n1}x_1^{(k)} - a_{n2}x_2^{(k)} - ... ) \\

\end{cases}</script><ul>
<li>缺点：没有运用运算得到的结果，收敛速度慢</li>
</ul>
<h4 id="Gauss-Seidel算法"><a href="#Gauss-Seidel算法" class="headerlink" title="Gauss-Seidel算法"></a>Gauss-Seidel算法</h4><script type="math/tex; mode=display">
\begin{cases}
x_1^{(k+1)} = \frac{1}{a_{11}} (b_1 - a_{12}x_2^{(k)} - ... - a_{1n}x_n^{(k)}) \\
x_2^{(k+1)} = \frac{1}{a_{22}} (b_2 - a_{21}x_1^{(k+1)} - ... - x_n^{(k)}) \\
x_1^{(k+1)} = \frac{1}{a_{nn}} (b_n - a_{n1}x_1^{(k+1)} - a_{n2}x_2^{(k+1)} - ... ) \\


\end{cases}</script><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314081232914.png" alt="image-20220314081232914" style="zoom:67%;" /></p>
<h5 id="【例3-8】求下列解线性方程组的解"><a href="#【例3-8】求下列解线性方程组的解" class="headerlink" title="【例3-8】求下列解线性方程组的解"></a>【例3-8】求下列解线性方程组的解</h5><p>$\begin{cases} 8x_1-3x_2+2x_3=20 \\ 4x_1+11x_2-x_3=33 \\ 6x_1+3x_2+12x_3=36 \\ \end{cases}$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314081359280.png" alt="image-20220314081359280" style="zoom:50%;" /></p>
<ul>
<li><p>算法设计与描述</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314081618780.png" alt="image-20220314081618780" style="zoom: 67%;" /></p>
</li>
<li><p>算法实现（未完待续）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Jacobi</span><span class="params">(<span class="type">double</span> x[], <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = k;</span><br><span class="line">    <span class="type">double</span> x11, x12, x13;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        x11 = (<span class="number">20</span>+<span class="number">3</span>*x[<span class="number">1</span>]<span class="number">-2</span>*x[<span class="number">2</span>])/<span class="number">8</span>;</span><br><span class="line">        x12 = (<span class="number">33</span><span class="number">-4</span>*x[<span class="number">0</span>]+x[<span class="number">2</span>])/<span class="number">11</span>;</span><br><span class="line">        x13 = (<span class="number">36</span><span class="number">-6</span>*x[<span class="number">0</span>]<span class="number">-3</span>*x[<span class="number">1</span>])/<span class="number">12</span>;</span><br><span class="line">        x[<span class="number">0</span>] = x11; x[<span class="number">1</span>] = x12; x[<span class="number">2</span>] = x13;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gauss</span><span class="params">(<span class="type">double</span> x[], <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        x[<span class="number">0</span>] = (<span class="number">20</span> + <span class="number">3</span>*x[<span class="number">1</span>] - <span class="number">2</span>*x[<span class="number">2</span>])/<span class="number">8</span>;</span><br><span class="line">        x[<span class="number">1</span>] = (<span class="number">33</span> - <span class="number">4</span>*x[<span class="number">0</span>] + x[<span class="number">2</span>])/<span class="number">11</span>;</span><br><span class="line">        x[<span class="number">2</span>] = (<span class="number">36</span> - <span class="number">6</span>*x[<span class="number">0</span>] - <span class="number">3</span>*x[<span class="number">1</span>])/<span class="number">12</span>;</span><br><span class="line">        --i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">J_result</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans[] = &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;k = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Jacobi</span>(ans,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">G_result</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans[] = &#123;<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;k = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Gauss</span>(ans,n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">J_result</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">J_result</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">G_result</span>(<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一种超松弛算法</p>
</li>
</ul>
<p>【思考题】求下列线性方程组的解</p>
<script type="math/tex; mode=display">
\begin{cases}
2x_1 - x_2 + x_3 = 0 \\ 
3x_1 + 2x_2 - 5x_3 = 1 \\
x_1 + 3x_2 - 2x_3 = 4 \\
\end{cases}</script><ul>
<li><p>算法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Jacobi</span><span class="params">(<span class="type">double</span> x[], <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = k; <span class="type">double</span> x11, x12, x13;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        x11 = (<span class="number">0</span> + x[<span class="number">1</span>] - x[<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        x12 = (<span class="number">1</span> - <span class="number">3</span>*x[<span class="number">0</span>] + <span class="number">5</span>*x[<span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        x13 = (<span class="number">4</span> - x[<span class="number">0</span>] - <span class="number">3</span>*x[<span class="number">1</span>]) / (<span class="number">-2</span>);</span><br><span class="line">        x[<span class="number">0</span>] = x11; x[<span class="number">1</span>] = x12; x[<span class="number">2</span>] = x13;</span><br><span class="line">        i = i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gauss</span><span class="params">(<span class="type">double</span> x[], <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = k;</span><br><span class="line">    <span class="keyword">while</span> (i) &#123;</span><br><span class="line">        x[<span class="number">0</span>] = (<span class="number">0</span> + x[<span class="number">1</span>] - x[<span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        x[<span class="number">1</span>] = (<span class="number">1</span> - <span class="number">3</span>*x[<span class="number">0</span>] + <span class="number">5</span>*x[<span class="number">2</span>]) / <span class="number">2</span>;</span><br><span class="line">        x[<span class="number">2</span>] = (<span class="number">4</span> - x[<span class="number">0</span>] - <span class="number">3</span>*x[<span class="number">1</span>]) / (<span class="number">-2</span>);</span><br><span class="line">        i -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans[] = &#123;<span class="number">0.46</span>,<span class="number">1.67</span>,<span class="number">0.75</span>&#125;;</span><br><span class="line">    <span class="built_in">Jacobi</span>(ans,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// Gauss(ans,10);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314081836833.png" alt="image-20220314081836833" style="zoom: 50%;" /></p>
<ul>
<li><p>对于第一个线性方程组，是发散的。</p>
<p>直接使用Jacobi或者Gauss-Seidel迭代法不能解这个方程组</p>
<p>（随着迭代次数的增加，迭代结果发散）</p>
<blockquote>
<p>解：$x_1=0.4643,x_2=1.6786,x_3=0.7500$</p>
</blockquote>
</li>
<li><p>对于第二个方程组，是收敛的。</p>
<p>可以直接使用Jacobi或者Gauss-Seidel迭代法</p>
<p><strong>Jacobi</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Jacobi</span><span class="params">(<span class="type">double</span> ans[])</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x11, x12, x13;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        x11 = (<span class="number">-12</span> - <span class="number">2</span>*ans[<span class="number">1</span>] - ans[<span class="number">2</span>]) / <span class="number">5</span>;</span><br><span class="line">        x12 = (<span class="number">20</span> + ans[<span class="number">0</span>] - <span class="number">2</span>*ans[<span class="number">2</span>]) / <span class="number">4</span>;</span><br><span class="line">        x13 = (<span class="number">3</span> - <span class="number">2</span>*ans[<span class="number">0</span>] + <span class="number">3</span>*ans[<span class="number">1</span>]) / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x11-ans[<span class="number">0</span>]) &lt; <span class="number">1e-4</span> &amp;&amp; <span class="built_in">fabs</span>(x12-ans[<span class="number">1</span>]) &lt; <span class="number">1e-4</span> &amp;&amp; <span class="built_in">fabs</span>(x13-ans[<span class="number">2</span>]) &lt; <span class="number">1e-4</span>) <span class="keyword">break</span>;</span><br><span class="line">        ans[<span class="number">0</span>] = x11; ans[<span class="number">1</span>] = x12; ans[<span class="number">2</span>] = x13;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220315163201519.png" alt="image-20220315163201519"></p>
<blockquote>
<p>雅可比迭代结果：$x_1 = -4,x_2 = 3, x_3 = 2$。迭代次数为17次</p>
</blockquote>
</li>
</ul>
<p><strong>Gauss</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Gauss</span><span class="params">(<span class="type">double</span> ans[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="type">double</span> x0 = <span class="number">0.0</span>, x1 = <span class="number">0.0</span>, x2 = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        x0 = ans[<span class="number">0</span>], x1 = ans[<span class="number">1</span>], x2 = ans[<span class="number">2</span>];</span><br><span class="line">        ans[<span class="number">0</span>] = (<span class="number">-12</span> - <span class="number">2</span>*ans[<span class="number">1</span>] - ans[<span class="number">2</span>]) / <span class="number">5</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = (<span class="number">20</span> + ans[<span class="number">0</span>] - <span class="number">2</span>*ans[<span class="number">2</span>]) / <span class="number">4</span>;</span><br><span class="line">        ans[<span class="number">2</span>] = (<span class="number">3</span> - <span class="number">2</span>*ans[<span class="number">0</span>] + <span class="number">3</span>*ans[<span class="number">1</span>]) / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(x0-ans[<span class="number">0</span>]) &lt; <span class="number">1e-4</span> &amp;&amp; <span class="built_in">fabs</span>(x1-ans[<span class="number">1</span>]) &lt; <span class="number">1e-4</span> &amp;&amp; <span class="built_in">fabs</span>(x2-ans[<span class="number">2</span>]) &lt; <span class="number">1e-4</span>) <span class="keyword">break</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220315163709967.png" alt="image-20220315163709967" style="zoom: 80%;" /></p>
<blockquote>
<p>高斯赛德尔迭代结果：$x_1 = -4,x_2 = 3, x_3 = 2$。迭代次数为7次</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第4章 蛮力法</title>
    <url>/algorithm/algorithm-ch4/</url>
    <content><![CDATA[<p><strong>蛮力法（brute force）</strong>：直接基于问题的描述和所涉及的概念定义的进行算法设计，简单而直接。</p>
<p>使用蛮力法：</p>
<ol>
<li>所能解决的问题跨越的领域非常广泛；</li>
<li>对于一些重要的问题，运用蛮力策略可以设计出具备一定实用价值的算法，而且不用限制实例的规模；</li>
<li>当要解决的问题实例不多并且可以接受蛮力法的运算速度时，蛮力法的设计代价通常较为低廉；</li>
<li>蛮力算法可以作为衡量其它算法的准绳，服务于研究或教学</li>
</ol>
<span id="more"></span>
<blockquote>
<p>蛮力法中：</p>
<p>顺序查找的时间复杂度为$O(n)$</p>
<p>BF 算法的时间复杂度为$O(n*m)$</p>
<p>KMP算法的时间复杂度为$O(n)$</p>
<p>选择和冒炮排序的时间复杂性$O(n*n)$                     </p>
<p>0/1背包问题的时间复杂性$O(2^n)$</p>
<p>任务分配问题的时间复杂性$O(n!)$</p>
<p>哈密顿回路的时间复杂性$O(n!)$</p>
<p>TSP问题的时间复杂性$O(n!)$</p>
</blockquote>
<h2 id="4-1-枚举法"><a href="#4-1-枚举法" class="headerlink" title="4.1 枚举法"></a>4.1 枚举法</h2><p>枚举法的<strong>算法框架</strong>可表示如下：</p>
<ul>
<li>(1) 依据问题，设定枚举范围；</li>
<li>(2) 找出约束条件，建立计算模型；</li>
<li>(3) 利用计算模型在枚举范围内搜索可能的解。</li>
</ul>
<blockquote>
<p>枚举范围的设定将决定算法效率</p>
</blockquote>
<h4 id="【例4-1】统计链环数字对"><a href="#【例4-1】统计链环数字对" class="headerlink" title="【例4-1】统计链环数字对"></a>【例4-1】统计链环数字对</h4><p>输入$n$个数字(在$0$与$9$之间)，然后统计出这组数中相邻两个数字组成的链环数字对出现的次数。如：$n=20$,输入为：0 1 5 9 8 7 2 2 2 3 2 7 8 7 8 7 9 6 5 9，则输出为$(7,8)=2, (8,7)=3,(7,2)=1,(2,7)=1,(2,2)=2,(2,3)=1,(3,2)=1$</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311194123070.png" alt="image-20220311194123070" style="zoom: 67%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311194254404.png" alt="image-20220311194254404" style="zoom: 67%;" /></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311194334117.png" alt="image-20220311194334117" style="zoom: 67%;" /></p>
<ul>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311194406005.png" alt="image-20220311194406005" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="type">int</span> ans[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x1, x2; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="comment">// 统计</span></span><br><span class="line">    cin &gt;&gt; x1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x2; ans[x1][x2]++;</span><br><span class="line">        x1 = x2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i][j] &amp;&amp; ans[j][i]) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;pair(&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;):&quot;</span> &lt;&lt; <span class="built_in">min</span>(ans[i][j],ans[j][i]) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">0 1 5 9 8 7 2 2 2 3 2 7 8 7 8 7 9 6 5 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314083452362.png" alt="image-20220314083452362" style="zoom: 80%;" /></p>
</li>
</ul>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311194438312.png" alt="image-20220311194438312"  /></p>
</li>
</ul>
<h4 id="【例4-2】解数字谜："><a href="#【例4-2】解数字谜：" class="headerlink" title="【例4-2】解数字谜："></a>【例4-2】解数字谜：</h4><script type="math/tex; mode=display">
\begin{array}{r}
ABCAB \\
\times \qquad \qquad A \\
\hline 
DDDDDD

\end{array}</script><ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311194931735.png" alt="image-20220311194931735" style="zoom: 67%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311194959093.png" alt="image-20220311194959093" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法设计</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311195030778.png" alt="image-20220311195030778" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, ans; <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30000</span>; i &lt;= <span class="number">99999</span>; i++) &#123;  <span class="comment">// 从30000-99999进行枚举</span></span><br><span class="line">        <span class="keyword">if</span> (i/<span class="number">10000</span> == (i/<span class="number">10</span>)%<span class="number">10</span>) &#123;</span><br><span class="line">            a = i/<span class="number">10000</span>;</span><br><span class="line">            ans = a*i;</span><br><span class="line">            <span class="keyword">if</span> (ans % <span class="number">111111</span> == <span class="number">0</span>)  cout &lt;&lt; i &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">9</span>; i++) &#123;  <span class="comment">// 枚举a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;  <span class="comment">// 枚举b</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++) &#123;  <span class="comment">// 枚举c</span></span><br><span class="line">                ans = i*<span class="number">10010</span> + j*<span class="number">1001</span> + k*<span class="number">100</span>;</span><br><span class="line">                <span class="keyword">if</span> (ans * i % <span class="number">111111</span> == <span class="number">0</span>)  cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; ans*i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;   <span class="comment">// 除法枚举</span></span><br><span class="line">    <span class="type">int</span> a, f[<span class="number">5</span>], sum, ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= <span class="number">9</span>; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (a = <span class="number">3</span>; a &lt;= <span class="number">9</span>; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d*<span class="number">111111</span> % a == <span class="number">0</span> &amp;&amp; d*<span class="number">111111</span> / a &lt; <span class="number">1e5</span>) &#123;</span><br><span class="line">                ans = sum = d*<span class="number">111111</span> / a; <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (sum) &#123;</span><br><span class="line">                    f[index++] = sum % <span class="number">10</span>;</span><br><span class="line">                    sum /= <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (f[<span class="number">0</span>] == f[<span class="number">3</span>] &amp;&amp; f[<span class="number">1</span>] == a &amp;&amp; f[<span class="number">4</span>] == a) cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; d*<span class="number">111111</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fun1</span>();</span><br><span class="line">    <span class="built_in">fun2</span>();</span><br><span class="line">    <span class="built_in">fun3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314084531244.png" alt="img" style="zoom:50%;" /></p>
<ul>
<li><p><strong>算法模型</strong></p>
<ul>
<li><p>通过列举Z、L、T三个人的一条预测，建立学生-名次的二维矩阵。</p>
<p>每个人的预测都有两条，一共有$2^3 = 8$种预测结果。</p>
</li>
<li><p>接下来考虑题目的限制条件来筛选预测结果：①每个人说对了一半；②没有并列名次</p>
</li>
<li><p>因此需要枚举这8种情况，通过3重for循环语句，获得每一种预测结果。</p>
<p>筛选时出现对<strong>同一个学生</strong>的预测或者预测的<strong>成绩相同</strong>时，该种预测结果肯定是错误的，<strong>应当排除</strong>。</p>
</li>
<li><p>对于正确的预测，4个人有3个人都对应着正确的结果。那么一定会<strong>有一个人没有给出名次</strong>。可以通过计算获得这个没有被预测出名次的学生和他的名次。</p>
</li>
</ul>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; stu;	<span class="comment">// 姓名-名次的数对</span></span><br><span class="line">stu res[<span class="number">4</span>][<span class="number">3</span>];	<span class="comment">// 存放Z、L、T的预测结果</span></span><br><span class="line"><span class="type">bool</span> flag[<span class="number">5</span>][<span class="number">5</span>];	<span class="comment">// 学生-名次二维矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++) &#123;</span><br><span class="line">            cin &gt;&gt; res[i][j].first &gt;&gt; res[i][j].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="built_in">sizeof</span>(flag));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;  <span class="comment">// Z的预测</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++) &#123;  <span class="comment">// L的预测</span></span><br><span class="line">            <span class="comment">// 预测相同的人或者相同的名次，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (res[<span class="number">1</span>][i].first == res[<span class="number">2</span>][j].first || res[<span class="number">1</span>][i].second == res[<span class="number">2</span>][j].second) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res[<span class="number">3</span>][k].first == res[<span class="number">2</span>][j].first ||</span><br><span class="line">                    res[<span class="number">3</span>][k].second == res[<span class="number">2</span>][j].second) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (res[<span class="number">3</span>][k].first == res[<span class="number">1</span>][i].first </span><br><span class="line">                    || res[<span class="number">3</span>][k].second == res[<span class="number">1</span>][i].second) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> name = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>, rank = <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>;</span><br><span class="line">                flag[res[<span class="number">1</span>][i].first][res[<span class="number">1</span>][i].second] = <span class="literal">true</span>;</span><br><span class="line">                flag[res[<span class="number">2</span>][j].first][res[<span class="number">2</span>][j].second] = <span class="literal">true</span>;</span><br><span class="line">                flag[res[<span class="number">3</span>][k].first][res[<span class="number">3</span>][k].second] = <span class="literal">true</span>;</span><br><span class="line">                name -= (res[<span class="number">1</span>][i].first + res[<span class="number">2</span>][j].first + res[<span class="number">3</span>][k].first);</span><br><span class="line">                rank -= (res[<span class="number">1</span>][i].second+ res[<span class="number">2</span>][j].second + res[<span class="number">3</span>][k].second);</span><br><span class="line">                flag[name][rank] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">4</span>; a++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt;= <span class="number">4</span>; b++) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,flag[a][b]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cout &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 1 2 3</span></span><br><span class="line"><span class="comment">3 1 4 4</span></span><br><span class="line"><span class="comment">4 2 1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>算法分析</strong></p>
<p>时间复杂度主要来源有两个：输入Z、L、T的预测结果+对预测结果的枚举与结果的输出</p>
<script type="math/tex; mode=display">
T(n) = \sum_{i = 1}^{3} \sum_{j = 1}^{2}c_1 + \sum_{i = 1}^{2} \sum_{j = 1}^{2} \sum_{k = 1}^{2}(c_2+\sum_{a = 1}^{4} \sum_{b = 1}^{4}1)</script><p>显然，时间复杂度与$n$无关，$T(n) = \Theta(1)$，为常数级。</p>
</li>
<li><p><strong>算法测试</strong></p>
<ul>
<li><p>运行结果</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314134334608.png" alt="image-20220314134334608" style="zoom: 80%;" /></p>
<p>|        |  1   |  2   |  3   |  4   |<br>| :——: | :—: | :—: | :—: | :—: |<br>| <strong>甲</strong> |  0   |  0   |  0   |  1   |<br>| <strong>乙</strong> |  0   |  0   |  1   |  0   |<br>| <strong>丙</strong> |  1   |  0   |  0   |  0   |<br>| <strong>丁</strong> |  0   |  1   |  0   |  0   |</p>
<p>从结果来看，<strong>第一名：丙；第二名：丁；第三名：乙；第四名：甲</strong></p>
</li>
<li><p>测试枚举的每一种情况</p>
<ul>
<li><strong>测试代码</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="built_in">sizeof</span>(flag));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i++) &#123;  <span class="comment">// Z的预测</span></span><br><span class="line">    flag[res[<span class="number">1</span>][i].first][res[<span class="number">1</span>][i].second] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; j++) &#123;  <span class="comment">// L的预测</span></span><br><span class="line">        flag[res[<span class="number">2</span>][j].first][res[<span class="number">2</span>][j].second] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;  <span class="comment">// T的预测</span></span><br><span class="line">            flag[res[<span class="number">3</span>][k].first][res[<span class="number">3</span>][k].second] = <span class="literal">true</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;#Case&quot;</span> &lt;&lt; k+(j<span class="number">-1</span>)*<span class="number">2</span>+(i<span class="number">-1</span>)*<span class="number">4</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">4</span>; a++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">1</span>; b &lt;= <span class="number">4</span>; b++) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%2d&quot;</span>,flag[a][b]);</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            flag[res[<span class="number">3</span>][k].first][res[<span class="number">3</span>][k].second] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flag[res[<span class="number">2</span>][j].first][res[<span class="number">2</span>][j].second] = <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    flag[res[<span class="number">1</span>][i].first][res[<span class="number">1</span>][i].second] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>运行截图</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314134935416.png" alt="image-20220314134935416" style="zoom: 80%;" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="【例4-3】输出玫瑰矩阵"><a href="#【例4-3】输出玫瑰矩阵" class="headerlink" title="【例4-3】输出玫瑰矩阵"></a>【例4-3】输出玫瑰矩阵</h4><p>其为n*n的方阵，特征如下所示：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311195234487.png" alt="image-20220311195234487" style="zoom: 80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314090302815.png" alt="image-20220314090302815" style="zoom: 80%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314090959231.png" alt="image-20220314090959231" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314091040317.png" alt="image-20220314091040317"  /></p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> ans[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>, dir = <span class="number">0</span>;   <span class="comment">// 方向：0下，1右，2上，3左</span></span><br><span class="line">    <span class="type">int</span> row = <span class="number">-1</span>, column = <span class="number">0</span>;    <span class="comment">// 行、列</span></span><br><span class="line">    <span class="keyword">while</span> (num &lt; n*n) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (dir) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                ans[++row][column] = ++num;</span><br><span class="line">                <span class="keyword">if</span> (row == n<span class="number">-1</span> || ans[row+<span class="number">1</span>][column] != <span class="number">0</span>) dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                ans[row][++column] = ++num;</span><br><span class="line">                <span class="keyword">if</span> (column == n<span class="number">-1</span> || ans[row][column+<span class="number">1</span>] != <span class="number">0</span>) dir = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                ans[--row][column] = ++num;</span><br><span class="line">                <span class="keyword">if</span> (row == <span class="number">0</span> || ans[row<span class="number">-1</span>][column] != <span class="number">0</span>) dir = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                ans[row][--column] = ++num;</span><br><span class="line">                <span class="keyword">if</span> (column == <span class="number">0</span> || ans[row][column<span class="number">-1</span>] != <span class="number">0</span>) dir = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,ans[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>运行截图</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311214128075.png" alt="image-20220311214128075"></p>
</li>
</ul>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314091337680.png" alt="image-20220314091337680"  /></p>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314091535619.png" alt="img" style="zoom:80%;" /></p>
<ul>
<li><strong>算法实现</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 101</span></span><br><span class="line"><span class="type">int</span> ans[MAXN][MAXN];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> x[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, num = <span class="number">1</span>, i = <span class="number">0</span>, j = <span class="number">0</span>, t = <span class="number">0</span>, nx, ny; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">while</span> (num &lt;= n*n) &#123;</span><br><span class="line">        ans[i][j] = num++;  nx = i+x[t]; ny = j+y[t];	<span class="comment">// 推算下个位置</span></span><br><span class="line">        <span class="keyword">if</span> (ans[nx][ny] != <span class="number">0</span> || nx &lt; <span class="number">0</span> || nx == n || ny &lt; <span class="number">0</span> || ny == n) &#123;	<span class="comment">// 到达边界，更换方向</span></span><br><span class="line">            t = (t+<span class="number">1</span>) % <span class="number">4</span>; nx = i+x[t]; ny = j+y[t];	<span class="comment">// 更新下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        i = nx; j = ny;	<span class="comment">// 赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,ans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行截图</p>
<p>$n = 4$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314142645062.png" alt="image-20220314142645062"  /></p>
<p>$n = 5$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314142724351.png" alt="image-20220314142724351"  /></p>
<h3 id="4-2-穷举查找"><a href="#4-2-穷举查找" class="headerlink" title="4.2 穷举查找"></a>4.2 穷举查找</h3><p>有一些求最优解的问题经过抽象，可以转换为组合优化问题，使用蛮力法来求解是一种简单的方法，称之为穷举查找（exhaustive search）</p>
<h4 id="【例4-4】旅行商问题-traveling-salesman-problem，TSP"><a href="#【例4-4】旅行商问题-traveling-salesman-problem，TSP" class="headerlink" title="【例4-4】旅行商问题(traveling salesman problem，TSP)"></a>【例4-4】旅行商问题(traveling salesman problem，TSP)</h4><p> 有一个旅行商由某市出发，经过所有给定的n个城市后，再回到出发的城市。除了出发的城市外，其它城市只经过一回。这样的回路可能有多个，求其中路径成本最小的回路。</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314092046576.png" alt="image-20220314092046576" style="zoom: 80%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314092431991.png" alt="image-20220314092431991" style="zoom: 80%;" /></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314092517797.png" alt="image-20220314092517797" style="zoom: 50%;" /></p>
<script type="math/tex; mode=display">
\begin{cases}
最优值：最大值 \\
最优解：路径
\end{cases}</script><ul>
<li><p><strong>算法设计与描述</strong></p>
<p>先<strong>生成排列路径</strong>，确定好路径后求路径各边权值构成的总代价，最后根据总代价是否小于最小代价来更新最小代价和对应的最小路径</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314092813381.png" alt="image-20220314092813381" style="zoom:40%;" /></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314093454052.png" alt="image-20220314093454052" style="zoom:40%;" /></p>
<blockquote>
<p>注意：交换产生全排，交换后要回归</p>
</blockquote>
<ul>
<li><strong>算法分析</strong></li>
</ul>
<script type="math/tex; mode=display">
T(n) = \sum_{i = 0}^{n-1}T(i+1) + C \\
= O((n-1)!)</script><p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314093626544.png" alt="image-20220314093626544" style="zoom: 50%;" /></p>
<h4 id="【例4-5】背包问题"><a href="#【例4-5】背包问题" class="headerlink" title="【例4-5】背包问题"></a>【例4-5】背包问题</h4><p>给定$n$个重量为$w_1, w_2,…w_n$，价值为$v_1, v_2,…v_n$的物品和一个承重为$W$的背包，求将这些物品中的某些装入背包中，在不超出重量$W$的情况下，价值最高的装法。</p>
<ul>
<li><strong>问题分析</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314093855273.png" alt="image-20220314093855273" style="zoom: 80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314094239604.png" alt="image-20220314094239604" style="zoom:40%;" /></p>
<ul>
<li><strong>计算模型</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314094352274.png" alt="image-20220314094352274" style="zoom: 50%;" /></p>
<p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> sum_v = <span class="number">0</span>, sum_w = <span class="number">0</span>, W = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r[MAXN] = &#123;<span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">item</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记录当前被选择的物品——当前最优子集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">record</span><span class="params">(<span class="type">int</span> sum_v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 被选择的物品的个数</span></span><br><span class="line">    r[<span class="number">0</span>] = sum_v;   <span class="comment">// r是最优子集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].flag) &#123;    <span class="comment">// 第i个物品被选中</span></span><br><span class="line">            count++;</span><br><span class="line">            r[count] = i;   <span class="comment">// 表示第count个被选择的物品是i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">knaps</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超重终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (sum_w &gt; W) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 记录较优解，最终留下的为最优解</span></span><br><span class="line">    <span class="keyword">if</span> (sum_v &gt; r[<span class="number">0</span>]) &#123;</span><br><span class="line">        cout &lt;&lt; r[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        ans = <span class="built_in">record</span>(sum_v);</span><br><span class="line">        cout &lt;&lt; sum_v &lt;&lt;  <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 加上第i件物品</span></span><br><span class="line">        sum_v += a[i].v;</span><br><span class="line">        sum_w += a[i].w;</span><br><span class="line">        a[i].flag = <span class="number">1</span>;	<span class="comment">// 表明物品被装载</span></span><br><span class="line">        <span class="built_in">knaps</span>(i+<span class="number">1</span>); <span class="comment">// 递归处理下一个物品</span></span><br><span class="line">        <span class="comment">// 减去第i件物品</span></span><br><span class="line">        sum_v -= a[i].v;</span><br><span class="line">        sum_w -= a[i].w;</span><br><span class="line">        a[i].flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; W;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].w &gt;&gt; a[i].v;</span><br><span class="line">        a[i].flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">knaps</span>(<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; r[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; r[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行截图</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220315193217592.png" alt="image-20220315193217592" style="zoom:80%;" /></p>
<p>【参考资料】</p>
<p><a href="https://zhuanlan.zhihu.com/p/345364527">咱就把0-1背包问题讲个通透！</a></p>
<p><a href="https://blog.csdn.net/weixin_42262128/article/details/109912032">算法分析与设计——蛮力法0/1背包</a></p>
<ul>
<li>算法分析</li>
</ul>
<p>时间复杂度：递归树。每次分解为两个子树。$O(2^n)$</p>
<h3 id="4-3-图的搜索"><a href="#4-3-图的搜索" class="headerlink" title="4.3 图的搜索"></a>4.3 图的搜索</h3><ul>
<li><p>深度优先查找</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316081952841.png" alt="image-20220316081952841" style="zoom: 80%;" /></p>
</li>
<li><p>广度优先查找</p>
</li>
</ul>
<h4 id="（1）DFS"><a href="#（1）DFS" class="headerlink" title="（1）DFS"></a>（1）DFS</h4><ul>
<li><p>算法设计与分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316082046492.png" alt="image-20220316082046492"  /></p>
</li>
</ul>
<blockquote>
<p>注：使用邻接表，时间复杂度为$O(n+e)$，使用邻接矩阵则时间复杂度为$O(n^2)$</p>
</blockquote>
<h5 id="【例4-6】迷宫问题"><a href="#【例4-6】迷宫问题" class="headerlink" title="【例4-6】迷宫问题"></a>【例4-6】迷宫问题</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316082913156.png" alt="image-20220316082913156" style="zoom:80%;" /></p>
<blockquote>
<p>加入最外层围墙简化边界判断</p>
</blockquote>
<ul>
<li><p>问题分析</p>
<ul>
<li>迷宫存储</li>
<li>移动</li>
</ul>
</li>
<li><p>计算模型</p>
<p>（1）存储</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316083217729.png" alt="image-20220316083217729" style="zoom:67%;" /></p>
</li>
<li><p>算法设计与描述</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316083401573.png" alt="image-20220316083401573" style="zoom:80%;" /></p>
</li>
<li><p>算法分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316083448041.png" alt="image-20220316083448041" style="zoom: 80%;" /></p>
</li>
</ul>
<h4 id="（2）BFS"><a href="#（2）BFS" class="headerlink" title="（2）BFS"></a>（2）BFS</h4><ul>
<li><p>算法设计与分析</p>
<p>先让顶点入队并置访问标志，判断队列是否为空。队头出队，遍历所有顶点观察是否已被访问。若未被访问则入队</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316083744651.png" alt="image-20220316083744651" style="zoom:67%;" /></p>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316083801855.png" alt="image-20220316083801855" style="zoom:67%;" /></p>
<p>【三壶问题】</p>
<ul>
<li><p>算法实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN[<span class="number">3</span>] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="type">int</span> val[<span class="number">3</span>]; <span class="comment">// 分别表示三个容器</span></span><br><span class="line">    State *pre; <span class="comment">// 保留前驱</span></span><br><span class="line">    <span class="built_in">State</span>(<span class="type">int</span> v0, <span class="type">int</span> v1, <span class="type">int</span> v2) &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">        val[<span class="number">0</span>] = v0; val[<span class="number">1</span>] = v1; val[<span class="number">2</span>] = v2;</span><br><span class="line">        pre = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;State*&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒水，从start转移到end</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">transfer</span><span class="params">(State *state, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// 能够装水的大小（start的储水量和end能装水的量的最小值）</span></span><br><span class="line">    <span class="type">int</span> water = <span class="built_in">min</span>(state-&gt;val[start], (MAXN[end]-state-&gt;val[end]));</span><br><span class="line">    <span class="keyword">if</span> (water == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 容器之间不装水，没有变化</span></span><br><span class="line">    <span class="comment">// 转移水量</span></span><br><span class="line">    state-&gt;val[start] -= water;</span><br><span class="line">    state-&gt;val[end] += water;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    State *init = <span class="keyword">new</span> <span class="built_in">State</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>); <span class="comment">// 初始化起始状态</span></span><br><span class="line">    q.<span class="built_in">push</span>(init);   <span class="comment">// 入队</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        State *node = q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;   <span class="comment">// 检查是否出现结果</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val[i] == <span class="number">4</span>) &#123;    <span class="comment">// BFS找到结果</span></span><br><span class="line">                <span class="keyword">for</span> (State* p = node; p != <span class="literal">nullptr</span>; p = p-&gt;pre) &#123;   <span class="comment">// 顺着前驱链表获得前驱状态</span></span><br><span class="line">                    cout &lt;&lt; p-&gt;val[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;val[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p-&gt;val[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;    <span class="comment">// 出现结果，停止大循环（出口）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;   <span class="comment">// BFS</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;   <span class="comment">// 排除自己给自己装水的情况</span></span><br><span class="line">                State *newnode = <span class="keyword">new</span> <span class="built_in">State</span>(node-&gt;val[<span class="number">0</span>], node-&gt;val[<span class="number">1</span>], node-&gt;val[<span class="number">2</span>]);   <span class="comment">// 继承上一状态</span></span><br><span class="line">                <span class="built_in">transfer</span>(newnode,i,j);  <span class="comment">// 装水</span></span><br><span class="line">                newnode-&gt;pre = node;    <span class="comment">// 设置前驱</span></span><br><span class="line">                q.<span class="built_in">push</span>(newnode);    <span class="comment">// 入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        q.<span class="built_in">pop</span>();    <span class="comment">// 出队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BFS</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316140140233.png" alt="image-20220316140140233" style="zoom:80%;" /></p>
<p>由于按照前驱查找，倒序输出结果。</p>
</li>
</ul>
</li>
</ul>
<p>【广度优先迷宫求解】</p>
<ul>
<li><p>算法实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    pos axis;</span><br><span class="line">    node *pre;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        axis = <span class="built_in">make_pair</span>(x,y);</span><br><span class="line">        pre = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node*&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上、下、左、右</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> fx[] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> fy[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> maze[MAXN][MAXN] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> nextx, nexty;</span><br><span class="line">node *ans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mazesearch_bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="keyword">new</span> <span class="built_in">node</span>(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node *n = Q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (n-&gt;axis.first == <span class="number">8</span> &amp;&amp; n-&gt;axis.second == <span class="number">8</span>) &#123;</span><br><span class="line">            ans = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            nextx = n-&gt;axis.first + fx[i];</span><br><span class="line">            nexty = n-&gt;axis.second + fy[i];</span><br><span class="line">            <span class="keyword">if</span> (maze[nextx][nexty] == <span class="number">0</span>) &#123;</span><br><span class="line">                node *newnode = <span class="keyword">new</span> <span class="built_in">node</span>(nextx, nexty);</span><br><span class="line">                newnode-&gt;pre = n;</span><br><span class="line">                Q.<span class="built_in">push</span>(newnode);</span><br><span class="line">                maze[nextx][nexty] = <span class="number">3</span>; <span class="comment">// 已访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mazesearch_bfs</span>();</span><br><span class="line">    <span class="keyword">while</span> (ans != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; ans-&gt;axis.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans-&gt;axis.second &lt;&lt; endl;</span><br><span class="line">        ans = ans-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220317082233380.png" alt="image-20220317082233380" style="zoom: 80%;" /></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第5章 分治法</title>
    <url>/algorithm/algorithm-ch5/</url>
    <content><![CDATA[<h2 id="5-1-分治法的设计技术"><a href="#5-1-分治法的设计技术" class="headerlink" title="5.1 分治法的设计技术"></a>5.1 分治法的设计技术</h2><ul>
<li>分治思想：把一个较大的问题分解成几个与原问题相似的子问题，找到求出这几个子问题的解法后，再以适当的方法组织，把它们合成求整个问题的解</li>
<li>分治算法求解问题的步骤<ul>
<li><strong>分解</strong>：将要解决的问题划分成若干个规模较小的同类问题；</li>
<li><strong>求解</strong>：当子问题划分得足够小时，用较简单的方法解决；</li>
<li><strong>合并</strong>：按原问题的要求，将子问题的解逐层合并构成原问题的解。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li><p>设计模式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316084611544.png" alt="image-20220316084611544" style="zoom:67%;" /></p>
</li>
<li><p>算法分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316084723387.png" alt="image-20220316084723387" style="zoom:67%;" /></p>
<blockquote>
<p>原问题分为多少个子问题比较合适？每个子问题规模要多大？</p>
</blockquote>
</li>
</ul>
<h2 id="5-2-二分查找"><a href="#5-2-二分查找" class="headerlink" title="5.2 二分查找"></a>5.2 二分查找</h2><p>【例5-1】设有$n$个元素的集合$a[0]-a[n-1]$是有序的，设计算法从这$n$个元素中找出值为$x$的特定元素</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p>思想：将n个元素分成个数大致相同的两半，取a[n/2]与x作比较。如果x=a[n/2]，则找到x，算法终止。如果x&lt;a[n/2]，则在集合的前半部分继续查找，否则在后半部分查找。</p>
</li>
<li><p><strong>计算模型</strong></p>
<p>(1)中间下标为$mid =(left+right)/2$。<br>(2)找到待查数据，即有$x=a[mid]$；<br>(3)暂未查到数，若$x<a[mid], \ right=mid-1; \ x>a[mid], \ 则left=mid+1$。</p>
</li>
<li><p><strong>算法描述</strong></p>
<p>输入：</p>
<p>输出：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316085859965.png" alt="image-20220316085859965" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316085930229.png" alt="image-20220316085930229" style="zoom:80%;" /></p>
</li>
</ul>
<blockquote>
<p>提示：主定理（2）—— 如果$f(n) = \Theta(n^{log_ba})$ , 那么$T(n)=\Theta(n^{log_ba}logn)$</p>
</blockquote>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316090106804.png" alt="image-20220316090106804" style="zoom:67%;" /></p>
<ul>
<li><p><strong>计算模型</strong></p>
<p>锦标赛算法，与归并排序类似。两两一组进行比较，较大的元素进入下一组比较。最终只有一个元素，该元素是数组中的最大元素</p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> a[MAXN], ans = <span class="number">0</span>, maxval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sol</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 当l = r时，mid = l = r，避免死循环</span></span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; maxval) &#123;</span><br><span class="line">        maxval = a[mid];</span><br><span class="line">        ans = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sol</span>(l,mid);</span><br><span class="line">    <span class="built_in">sol</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">rand</span>()%(n*n);</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxval &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">sol</span>(<span class="number">1</span>,n);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxval &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">2 5 3 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p>​    <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220317191718291.png" alt="image-20220317191718291" style="zoom: 67%;" /> </p>
</li>
</ul>
</li>
</ul>
<h2 id="5-3-大整数乘法和Strassen矩阵乘法"><a href="#5-3-大整数乘法和Strassen矩阵乘法" class="headerlink" title="5.3 大整数乘法和Strassen矩阵乘法"></a>5.3 大整数乘法和Strassen矩阵乘法</h2><p>【例5-2】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316090329794.png" alt="image-20220316090329794" style="zoom: 80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<ul>
<li><p>算法1</p>
<p>乘法运算比加法复杂，因此核心运算为乘法</p>
<blockquote>
<p>观察到，每次二分有4次运算：$x_1 \times y_1$ 、$x_1 \times y_0$ 、 $x_0 \times y_1$ 、$x_0 \times y_0$</p>
<p>因此有：$T(n) = 4T( \frac{n}{2})$</p>
</blockquote>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316090545130.png" alt="image-20220316090545130" style="zoom:67%;" /></p>
<ul>
<li><p>算法2</p>
<p>改进之处在于：$x_1 \times y_0 + x_0 \times y_1 = (x_1-x_0) \times (y_1 - y_0) - x_1 \times y_1  - x_0 \times y_0$</p>
<blockquote>
<p>观察到，每次二分有3次乘法运算：$x_1 \times y_0 $ 、$ x_0 \times y_1$ 、$(x_1-x_0) \times (y_1 - y_0)$</p>
<p>因此有：$T(n) = 3T( \frac{n}{2})$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316090709318.png" alt="image-20220316090709318" style="zoom:67%;" /></p>
</li>
</ul>
</li>
<li><p><strong>计算模型</strong></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316091434498.png" alt="image-20220316091434498" style="zoom:67%;" /></p>
<p>【思考题】写出它的算法描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输出：X*Y	输入：X、Y、n</span><br><span class="line"><span class="comment">// 除了当n = 1,每一次乘法都是一次fun()</span></span><br><span class="line">NUMBER <span class="title function_">fun</span><span class="params">(NUMBER x, NUMBER y, <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x*y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        x1 &lt;- x / <span class="built_in">pow</span>(<span class="number">10</span>, n/<span class="number">2</span>);	x0 &lt;- x % <span class="built_in">pow</span>(<span class="number">10</span>, n/<span class="number">2</span>);	<span class="comment">// x的高n/2位和低n/2位</span></span><br><span class="line">        y1 &lt;- y / <span class="built_in">pow</span>(<span class="number">10</span>, n/<span class="number">2</span>); y0 &lt;- y % <span class="built_in">pow</span>(<span class="number">10</span>, n/<span class="number">2</span>);	<span class="comment">// y的高n/2位和低n/2位</span></span><br><span class="line">        xy1 &lt;- fun(x1, y1, n/<span class="number">2</span>); xy0 &lt;- fun(x0, y0, n/<span class="number">2</span>);	<span class="comment">// xi*yi</span></span><br><span class="line">        xy &lt;- fun((x1-x0), (y0-y1), n/<span class="number">2</span>);</span><br><span class="line">    	<span class="keyword">return</span> xy1*<span class="built_in">pow</span>(<span class="number">10</span>, n) + (xy + xy1 + xy0)*<span class="built_in">pow</span>(<span class="number">10</span>, n/<span class="number">2</span>) + xy0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例5-3】对于任意给定的n阶方阵A和B，求 $A \times B$ 的积C</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316091832332.png" alt="image-20220316091832332" style="zoom:67%;" /></p>
<ul>
<li><p>分治策略</p>
<p>每个矩阵分成四个子矩阵</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316092018063.png" alt="image-20220316092018063" style="zoom: 80%;" /></p>
<p>Strassen</p>
<p>把8次乘法变成7次乘法，再使用加减</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316092254010.png" alt="image-20220316092254010" style="zoom:67%;" /></p>
<p>分析——$\Theta (n^{2.81})$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316092518061.png" alt="image-20220316092518061" style="zoom:67%;" /></p>
<blockquote>
<p>最快：$O(2^{2.376})$，但每次运算的复杂性代价越来越高</p>
<p>问题：n不够大，效率并不明显</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316092821936.png" alt="image-20220316092821936" style="zoom:80%;" /></p>
<ul>
<li>划分成四块，每一块为$n/2$</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316092901170.png" alt="image-20220316092901170" style="zoom:67%;" /></p>
<ul>
<li><p>递归计算$m_i$的值</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316093037403.png" alt="image-20220316093037403" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316093214525.png" alt="image-20220316093214525" style="zoom:67%;" /></p>
</li>
<li><p>计算结果子矩阵</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316093148345.png" alt="image-20220316093148345" style="zoom: 80%;" /></p>
</li>
</ul>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316093235753.png" alt="image-20220316093235753" style="zoom:67%;" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="comment">// 矩阵结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line">    <span class="type">int</span> element[MAXN][MAXN];    <span class="comment">// 元素</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 阶</span></span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(element, <span class="number">0</span>, <span class="built_in">sizeof</span>(element));</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(element, <span class="number">0</span>, <span class="built_in">sizeof</span>(element));</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> *matrix, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(element, <span class="number">0</span>, <span class="built_in">sizeof</span>(element));</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)    </span><br><span class="line">                element[i][j] = matrix[i*n+j]; <span class="comment">// 一维数组给矩阵赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载-矩阵加法</span></span><br><span class="line">    Matrix <span class="keyword">operator</span> + (<span class="type">const</span> Matrix &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">        Matrix temp;</span><br><span class="line">        <span class="type">int</span> num = <span class="keyword">this</span>-&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++) </span><br><span class="line">                temp.element[i][j] = <span class="keyword">this</span>-&gt;element[i][j] + x.element[i][j];</span><br><span class="line">        temp.n = num;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载-矩阵减法</span></span><br><span class="line">    Matrix <span class="keyword">operator</span> - (<span class="type">const</span> Matrix &amp;x) <span class="type">const</span> &#123;</span><br><span class="line">        Matrix temp;</span><br><span class="line">        <span class="type">int</span> num = <span class="keyword">this</span>-&gt;n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++) </span><br><span class="line">                temp.element[i][j] = <span class="keyword">this</span>-&gt;element[i][j] - x.element[i][j];</span><br><span class="line">        temp.n = num;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分解成子矩阵</span></span><br><span class="line"><span class="function">Matrix <span class="title">Create</span><span class="params">(Matrix x, <span class="type">int</span> r1, <span class="type">int</span> r2, <span class="type">int</span> c1, <span class="type">int</span> c2)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">temp</span><span class="params">(x.n/<span class="number">2</span>)</span></span>;    <span class="comment">// 子矩阵的阶为一半</span></span><br><span class="line">    <span class="type">int</span> indexr = <span class="number">0</span>, indexc = <span class="number">0</span>; <span class="comment">// 子矩阵的行、列坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r1; i &lt;= r2; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = c1; j &lt;= c2; j++)</span><br><span class="line">            temp.element[indexr][indexc++] = x.element[i][j];</span><br><span class="line">        indexr++; indexc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个子矩阵合并</span></span><br><span class="line"><span class="function">Matrix <span class="title">Merge</span><span class="params">(Matrix x00, Matrix x01, Matrix x10, Matrix x11)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = x00.n;</span><br><span class="line">    <span class="function">Matrix <span class="title">x</span><span class="params">(n*<span class="number">2</span>)</span></span>;  <span class="comment">// 合并后矩阵的阶扩大1倍</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            x.element[i][j] = x00.element[i][j];</span><br><span class="line">            x.element[i][j+n] = x01.element[i][j];</span><br><span class="line">            x.element[i+n][j] = x10.element[i][j];</span><br><span class="line">            x.element[i+n][j+n] = x11.element[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归分治求解矩阵乘法 SQUARE-MATRIX-MULTIPLY-RECURSIVE</span></span><br><span class="line"><span class="function">Matrix <span class="title">SMMR</span><span class="params">(Matrix A, Matrix B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">C</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;   <span class="comment">// 递归出口</span></span><br><span class="line">        C.element[<span class="number">0</span>][<span class="number">0</span>] = (A).element[<span class="number">0</span>][<span class="number">0</span>] * (B).element[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分解矩阵A和B</span></span><br><span class="line">        Matrix A00 = <span class="built_in">Create</span>(A, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>); Matrix B00 = <span class="built_in">Create</span>(B, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">        Matrix A01 = <span class="built_in">Create</span>(A, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>); Matrix B01 = <span class="built_in">Create</span>(B, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">        Matrix A10 = <span class="built_in">Create</span>(A, n/<span class="number">2</span>, n<span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>); Matrix B10 = <span class="built_in">Create</span>(B, n/<span class="number">2</span>, n<span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">        Matrix A11 = <span class="built_in">Create</span>(A, n/<span class="number">2</span>, n<span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>); Matrix B11 = <span class="built_in">Create</span>(B, n/<span class="number">2</span>, n<span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 递归求C的四个子矩阵</span></span><br><span class="line">        Matrix C00 = <span class="built_in">SMMR</span>(A00, B00, n/<span class="number">2</span>) + <span class="built_in">SMMR</span>(A01, B10, n/<span class="number">2</span>);</span><br><span class="line">        Matrix C01 = <span class="built_in">SMMR</span>(A00, B01, n/<span class="number">2</span>) + <span class="built_in">SMMR</span>(A01, B11, n/<span class="number">2</span>);</span><br><span class="line">        Matrix C10 = <span class="built_in">SMMR</span>(A10, B00, n/<span class="number">2</span>) + <span class="built_in">SMMR</span>(A11, B10, n/<span class="number">2</span>);</span><br><span class="line">        Matrix C11 = <span class="built_in">SMMR</span>(A10, B01, n/<span class="number">2</span>) + <span class="built_in">SMMR</span>(A11, B11, n/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 子矩阵合并</span></span><br><span class="line">        C = <span class="built_in">Merge</span>(C00, C01, C10, C11);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Strassen算法</span></span><br><span class="line"><span class="function">Matrix <span class="title">Strassen</span><span class="params">(Matrix A, Matrix B, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">C</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;   <span class="comment">// 递归出口</span></span><br><span class="line">        C.element[<span class="number">0</span>][<span class="number">0</span>] = A.element[<span class="number">0</span>][<span class="number">0</span>] * B.element[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分解矩阵A和B</span></span><br><span class="line">        Matrix A00 = <span class="built_in">Create</span>(A, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>); Matrix B00 = <span class="built_in">Create</span>(B, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">        Matrix A01 = <span class="built_in">Create</span>(A, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>); Matrix B01 = <span class="built_in">Create</span>(B, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">        Matrix A10 = <span class="built_in">Create</span>(A, n/<span class="number">2</span>, n<span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>); Matrix B10 = <span class="built_in">Create</span>(B, n/<span class="number">2</span>, n<span class="number">-1</span>, <span class="number">0</span>, n/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">        Matrix A11 = <span class="built_in">Create</span>(A, n/<span class="number">2</span>, n<span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>); Matrix B11 = <span class="built_in">Create</span>(B, n/<span class="number">2</span>, n<span class="number">-1</span>, n/<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 计算M1-M7</span></span><br><span class="line">        Matrix M1 = <span class="built_in">Strassen</span>((A00+A11), (B00+B11), n/<span class="number">2</span>);</span><br><span class="line">        Matrix M2 = <span class="built_in">Strassen</span>((A10+A11), B00, n/<span class="number">2</span>);</span><br><span class="line">        Matrix M3 = <span class="built_in">Strassen</span>(A00, (B01-B11), n/<span class="number">2</span>);</span><br><span class="line">        Matrix M4 = <span class="built_in">Strassen</span>(A11, (B10-B00), n/<span class="number">2</span>);</span><br><span class="line">        Matrix M5 = <span class="built_in">Strassen</span>((A00+A01), B11, n/<span class="number">2</span>);</span><br><span class="line">        Matrix M6 = <span class="built_in">Strassen</span>((A10-A00), (B00+B01), n/<span class="number">2</span>);</span><br><span class="line">        Matrix M7 = <span class="built_in">Strassen</span>((A01-A11), (B10+B11), n/<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 递归求C的四个子矩阵</span></span><br><span class="line">        Matrix C00 = M1 + M4 - M5 + M7;</span><br><span class="line">        Matrix C01 = M3 + M5;</span><br><span class="line">        Matrix C10 = M2 + M4;</span><br><span class="line">        Matrix C11 = M1 + M3 - M2 + M6;</span><br><span class="line">        <span class="comment">// 子矩阵合并</span></span><br><span class="line">        C = <span class="built_in">Merge</span>(C00, C01, C10, C11);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出矩阵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(Matrix c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c.n; j++) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,c.element[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> matrixA[] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> matrixB[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function">Matrix <span class="title">A</span><span class="params">(matrixA,<span class="number">4</span>)</span>, <span class="title">B</span><span class="params">(matrixB,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">output</span>(A);</span><br><span class="line">    <span class="built_in">output</span>(B);</span><br><span class="line">    </span><br><span class="line">    Matrix C = <span class="built_in">SMMR</span>(A, B, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">output</span>(C);</span><br><span class="line"></span><br><span class="line">    Matrix D = <span class="built_in">Strassen</span>(A,B,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">output</span>(D);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320082913953.png" alt="image-20220320082913953" style="zoom:80%;" /></p>
</li>
<li><p>比较算法效率</p>
<p>对于分治矩阵乘法</p>
<blockquote>
<p>$T(n) = 8T(n/2) + \Theta(n^2)$</p>
<p>a = 8, b = 2</p>
<p>由主定理第一条，$f(n) = O(n^{log_28-1})= O(n^2)$(取$\epsilon = 1$)</p>
<p>$T(n) = \Theta(n^{log_28}) = \Theta(n^3)$</p>
</blockquote>
<p>对于Strassen方法</p>
<blockquote>
<p>$T(n) = 7T(n/2) + \Theta(n^2)$</p>
<p>a = 7, b = 2</p>
<p>由主定理第一条（与上文分治算法同理）</p>
<p>$T(n) = \Theta(n^{log_27}) = \Theta(n^{2.807})$</p>
</blockquote>
<p>因此Strassen算法在时间复杂度上优于分治算法</p>
</li>
</ul>
<h2 id="5-4-棋盘覆盖问题"><a href="#5-4-棋盘覆盖问题" class="headerlink" title="5.4 棋盘覆盖问题"></a>5.4 棋盘覆盖问题</h2><p>【例5-4】残缺棋盘</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316093414320.png" alt="image-20220316093414320" style="zoom:67%;" /></p>
<ul>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316094018761.png" alt="image-20220316094018761" style="zoom:80%;" /></p>
</li>
<li><p><strong>计算过程</strong></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316094258495.png" alt="image-20220316094258495" style="zoom: 80%;" /></p>
<ul>
<li><p><strong>算法设计与描述</strong></p>
<ul>
<li>输入：棋盘和坏格子坐标、输出：覆盖后的棋盘</li>
<li>创建函数CBCover，参数为棋盘、棋盘左上角方格坐标、坏格子坐标、棋盘边长</li>
<li>由于每次在左上角，进入if语句后先递归左上棋盘，覆盖左上棋盘，最后覆盖其他部分</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321083230696.png" alt="image-20220321083230696" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321083308912.png" alt="image-20220321083308912" style="zoom:67%;" /></p>
</li>
</ul>
<h2 id="5-5-选择性问题"><a href="#5-5-选择性问题" class="headerlink" title="5.5 选择性问题"></a>5.5 选择性问题</h2><p>选择性问题：选最大值、最小值、选中位数、选第二大值</p>
<p>【例】选第k小值</p>
<p>设A是含有n个元素的集合，从A中选出第k小的元素，其中1≤k≤n。这里的第k小是指当A中元素从小到大排序之后，第k个位置的元素，当k=1时，选出的是A中的最小值，当k=n时，选出的就是最大值</p>
<ul>
<li><p><strong>问题分析</strong></p>
<blockquote>
<p>最直接的方法：排序</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320205052169.png" alt="image-20220320205052169" style="zoom:67%;" /></p>
<blockquote>
<p>考虑k&gt;2的时候如何完成——快速排序</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320205117509.png" alt="image-20220320205117509" style="zoom:67%;" /></p>
<blockquote>
<p>快速排序是集合划分的过程。每一次划分，比pivot小的放在左边，比pivot大的放在右边。</p>
<p>选第k小值就是确保前k-1小的元素都在左边</p>
<p>每一次划分都是把问题规模缩小：</p>
<ul>
<li>对于（1），已找到</li>
<li>对于（2），对应元素过大，往左找</li>
<li>对于（3），对应元素过小 ，往右找（对于下一轮，直接从pivot的下一个元素开始找。左边已经找到了left个小元素）</li>
</ul>
</blockquote>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320205155232.png" alt="image-20220320205155232" style="zoom:67%;" /></p>
<p>最坏情况下退化为直接查找（冒泡排序），变成蛮力法</p>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320205356957.png" alt="image-20220320205356957" style="zoom:80%;" /></p>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321085332567.png" alt="image-20220321085332567" style="zoom: 80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p>我对于题目的理解：把所有的负元素放到正元素之前，并且不改变元素之间的相对位置</p>
<p>因此在排序时，除了需要按正负号排序，还需要考虑稳定性。因此不宜使用快速排序、选择排序。</p>
<p>为了兼顾时间效率和空间效率，选择归并排序。</p>
</li>
<li><p><strong>计算模型</strong></p>
<p>数据结构上，使用两个double型的数组a[ ]和b[ ]，分别存储源数据和排序时的辅助数组</p>
<p>l, m, r分别标记数组的左界、中间、右界。</p>
<p>每一次将集合划分为两个大小相等的子集合，先进行排序，然后进行合并。</p>
<p>合并时：先把两个区间内的负元素存入辅助数组b[ ]中，然后将正元素存入b[ ]。最后把b[ ]中的元素全部赋给a[ ]。</p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑排序的稳定性，使用归并排序，空间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> b[], <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = m;</span><br><span class="line">    <span class="type">int</span> k = l;</span><br><span class="line">    <span class="comment">// 左区间负元素存入辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= mid; i++) </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) </span><br><span class="line">            b[k++] = a[i];</span><br><span class="line">    <span class="comment">// 右区间负元素存入辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = mid+<span class="number">1</span>; j &lt;= r; j++) </span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; <span class="number">0</span>) </span><br><span class="line">            b[k++] = a[j];</span><br><span class="line">    <span class="comment">// 左区间正元素存入辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= mid; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>) </span><br><span class="line">            b[k++] = a[i];</span><br><span class="line">    <span class="comment">// 右区间正元素存入辅助数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = mid+<span class="number">1</span>; j &lt;= r; j++)</span><br><span class="line">        <span class="keyword">if</span> (a[j] &gt;= <span class="number">0</span>)</span><br><span class="line">            b[k++] = a[j];</span><br><span class="line">    <span class="comment">// 辅助数组元素放回a</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">double</span> a[], <span class="type">double</span> b[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 对左右两个子区间进行划分</span></span><br><span class="line">        <span class="built_in">MergeSort</span>(a,b,l,mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(a,b,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="comment">// 对左右两个子区间合并</span></span><br><span class="line">        <span class="built_in">Merge</span>(a,b,l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322202127872.png" alt="image-20220322202127872"></p>
</li>
</ul>
</li>
<li><p><strong>算法分析</strong></p>
<p>每次划分都分成了长度相等的两部分。</p>
<p>合并过程中四次遍历数组获得b中元素，加上一次遍历从b写入a。</p>
<script type="math/tex; mode=display">
T(n) = 2T(n/2) + f(n) \\
f(n) = \Theta(5n)</script><p>由主定理，a = b = 2。$f(n) = \Theta(n^{log_22})$，则$T(n) = \Theta(n^{log_22}logn) = \Theta(nlogn)$</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321085412863.png" alt="image-20220321085412863" style="zoom: 80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<blockquote>
<p>使用分治法，每次划分为两个子集合。那么会出现2种情况：</p>
<p>（1）最大字段和对应的数列只在左集合或者只在右集合</p>
<p>（2）最大字段和对应的数列跨越左右两个集合</p>
<p>因此需要分治的同时考虑第（2）种情况</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<p>将数列存入数组a[ ]中，l和r分别为选取数列的左右界</p>
<p>每次选择数列中间的值mid，将数列进一步划分为左右两个子区间，比较两个区间的最大值，取大者。</p>
<p>从mid开始向左右进行扩张，直到到达左、右界结束。取连续数列和的最大值，分别存入maxdoublel和maxdoubler中。</p>
<p>最后将左右连续区间数列和相加成maxdouble，与左右区间最大值进行比较，更新结果。</p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[]的下标从1开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxBsum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 出口，只剩下一个元素，考虑负数取0</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> a[l] &gt; <span class="number">0</span> ? a[l] : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归获得左右两个区间的最大字段和</span></span><br><span class="line">    <span class="type">int</span> maxleft = <span class="built_in">maxBsum</span>(a,l,mid);</span><br><span class="line">    <span class="type">int</span> maxright = <span class="built_in">maxBsum</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">// 取左区间和右区间的最大值</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">max</span>(maxleft, maxright);</span><br><span class="line">    <span class="comment">// 考虑最大值在中间的情况，从中间向两端扩张</span></span><br><span class="line">    <span class="type">int</span> maxdoublel = <span class="number">0</span>, maxdoubler = <span class="number">0</span>, maxdouble = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 向左扩展</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid; i &gt;= l; i--) &#123;</span><br><span class="line">        left += a[i];</span><br><span class="line">        maxdoublel = <span class="built_in">max</span>(maxdoublel, left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向右扩展</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = mid+<span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        right += a[i];</span><br><span class="line">        maxdoubler = <span class="built_in">max</span>(maxdoubler, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中间区间和</span></span><br><span class="line">    maxdouble = maxdoublel + maxdoubler;</span><br><span class="line">    <span class="comment">// 更新结果</span></span><br><span class="line">    ans = <span class="built_in">max</span>(ans, maxdouble);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>算法分析</strong></p>
<p>每次分治为两个大小相等的子序列，同时后续左右扩张数列处理时，规模与当前数组长度有关。</p>
<script type="math/tex; mode=display">
T(n) = 2T(n/2) + \Theta(n)</script><p>由主定理，可以得到：$T(n) = \Theta(n*logn)$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第7章 贪心法</title>
    <url>/algorithm/algorithm-ch7/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>贪心算法的设计思想与技术</li>
<li>用贪心法求问题的解</li>
<li>近似贪心问题</li>
</ul>
<p><strong>正确性证明是贪心法的难点</strong></p>
<span id="more"></span>
<h2 id="7-1-贪心算法的设计思想与技术"><a href="#7-1-贪心算法的设计思想与技术" class="headerlink" title="7.1 贪心算法的设计思想与技术"></a>7.1 贪心算法的设计思想与技术</h2><p>贪心算法是通过求解该问题的每一个子问题的<strong>局部最优解从而逐步得到全局最优解</strong>。</p>
<p><strong>贪心算法设计技术</strong></p>
<ul>
<li>每一步的判断都是当前最优的抉择，这个抉择计算设计的好坏，决定了算法的成败；</li>
<li>多步判断过程，最终的判断序列对应于问题的最优解；</li>
<li>适用于能够由<strong>局部最优达到全局最优</strong>的优化问题；</li>
<li>需要对具体的贪心算法的正确性进行必要的证明——数学归纳法。</li>
</ul>
<blockquote>
<p>贪心——最优化</p>
<p>但是局部最优解不一定能够达到全局最优解</p>
<p>难点在于贪心算法正确性的证明</p>
</blockquote>
<h2 id="7-2-用贪心法求问题的解"><a href="#7-2-用贪心法求问题的解" class="headerlink" title="7.2 用贪心法求问题的解"></a>7.2 用贪心法求问题的解</h2><h3 id="【例7-1】安排活动"><a href="#【例7-1】安排活动" class="headerlink" title="【例7-1】安排活动"></a>【例7-1】安排活动</h3><p>学生有n项活动申请使用某一个会议室，每项活动都有一个开始时间和一个结束时间。任何两个活动都不能同时使用这个会议室。问如何安排这些活动，使得被安排活动的数量达到最多？</p>
<ul>
<li><p><strong>问题分析</strong></p>
<blockquote>
<p>活动$i$和活动$j$相容$\Leftrightarrow s_i \geq f_j \vee s_j \geq f_i, \ i \neq j$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327210019518.png" alt="image-20220327210019518" style="zoom: 67%;" /></p>
<blockquote>
<p>按照结束时间从小到大选择可以得到最优解</p>
</blockquote>
</li>
<li><p><strong>正确性证明</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327210113102.png" alt="image-20220327210113102" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327210150790.png" alt="image-20220327210150790" style="zoom: 67%;" /></p>
<blockquote>
<p>整理证明的思路：</p>
<p>数学归纳法。需要证明S是A的最优解，并且S={$i_1, i_2, … , i_m$}</p>
<p>①证明k=1时，活动1包含在最优解中。</p>
<p>——使用反证法，在S是最优解的前提下，用1替换$i_1$(不等于1)。</p>
<p>由于1的结束时间比$i_1$早，1和$i_2,…,i_m$均相容。为了保证S最优解的条件，用1替换$i_1$，仍为最优解。</p>
<p>②假设前k步选择了k个活动，推出第k+1步的选择。</p>
<p>——首先构造全局最优解，包含前k步选择的活动：$S = \{i_1, i_2, …, i_k \} \cup B $。假设$S’ = \{j|S_j \geq e_{i_k}, j \in S\}$是S中剩下的与前k个相容的活动构成的集合。（集合中的元素之间可能不相容）。</p>
<p>——然后证明B一定是S’的一个最优解。（如果B不是最优解，假设为B’则包含B‘活动数比B多，最后总活动数比S多，与S是最优解矛盾）</p>
<p>——在S’中，第一个元素为$i_{k+1}$。由①，第一个活动包含在某一个最优解$B^<em>$中（$B^</em>$和B中元素个数相等），因此$i_{k+1}$被选中。把$i_{k+1}$放到前半个集合中。得到$S’’ = \{i_1,…,i_k,i_{k+1} \} \cup \{B-\{i_{k+1}\}\}$仍为最优解。此时完成k+1个活动的选择。</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p>存储结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Active</span> &#123;</span><br><span class="line">	startTime s;	<span class="comment">// 活动开始时间</span></span><br><span class="line">	endTime e;	<span class="comment">// 活动结束时间</span></span><br><span class="line">	selectflag f;	<span class="comment">// 选标识</span></span><br><span class="line">&#125; A[n];</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<ol>
<li><p>计算</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327210414746.png" alt="image-20220327210414746" style="zoom:67%;" /></p>
</li>
</ol>
<ul>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327210626469.png" alt="image-20220327210626469" style="zoom:67%;" /></p>
<blockquote>
<p>排序可以选择任何高效的排序方法，需要按结束时间升序排列。</p>
</blockquote>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Active</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; <span class="comment">// 活动开始时间</span></span><br><span class="line">    <span class="type">int</span> e; <span class="comment">// 活动结束时间</span></span><br><span class="line">    <span class="type">bool</span> f; <span class="comment">// 选标识</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (Active x, Active y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.e &lt; y.e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GreedySelect</span><span class="params">(Active A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j = <span class="number">1</span>, count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        A[i].f = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(A+<span class="number">1</span>,A+<span class="number">1</span>+n);	<span class="comment">// 按照结束时间排序</span></span><br><span class="line">    A[<span class="number">1</span>].f = <span class="number">1</span>; count = <span class="number">1</span>;	<span class="comment">// 结束时间最早的为第一个被选中的活动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i].s &gt;= A[j].e) &#123;		<span class="comment">// 实现相容，被选中</span></span><br><span class="line">            A[i].f = <span class="number">1</span>;</span><br><span class="line">            j = i;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the count is %d\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i].f) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case#%d is selected, start at: %d, end at: %d\n&quot;</span>,i,A[i].s,A[i].e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Active A[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;A[i].s,&amp;A[i].e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GreedySelect</span>(A,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 8</span></span><br><span class="line"><span class="comment">7 10</span></span><br><span class="line"><span class="comment">9 15</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329161955692.png" alt="image-20220329161955692" style="zoom:80%;" /></p>
</li>
</ul>
<ul>
<li><p><strong>算法分析</strong></p>
<ol>
<li><p>问题的输入规模为n；</p>
</li>
<li><p>初始化需要循环n次；</p>
</li>
<li><p>按结束时间排序算法的时间复杂度为$O(nlogn)$；</p>
</li>
<li><p>用贪心算法选择最多安排的活动数目需要循环n次；</p>
</li>
<li><p>依据定理2.2可得，$T(n) = O(nlogn)$</p>
<blockquote>
<p>运算是并行的，满足加法原理，时间复杂度选其中最高的。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="【例7-2】数列极差"><a href="#【例7-2】数列极差" class="headerlink" title="【例7-2】数列极差"></a>【例7-2】数列极差</h3><p>给定含有n个正整数的数列a，做如下两步操作：</p>
<p><strong>(1)</strong> 每一次删除其中的两个数$a_i$和$a_j$;</p>
<p><strong>(2)</strong> 在数列中加入一个数$a_i×a_j+1$， 循环执行步骤(1)(2)直到集合中只剩下一个元素为止。</p>
<p>设计算法求得数列中剩余的数为最大值$max$和最小值$min$，则该数列的极差为$M=max-min$。</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327211000972.png" alt="image-20220327211000972" style="zoom:67%;" /></p>
<blockquote>
<p>两个最小的数相乘，结果最大；</p>
<p>两个最大的数相乘，结果最小。</p>
</blockquote>
</li>
<li><p><strong>正确性证明</strong></p>
<blockquote>
<p>先用k=3的情况尝试一下。</p>
<p>设$a = \{ a_1, a_2, a_3 \}$，且$a_1 &lt; a_2 &lt; a_3$。</p>
<p>三种组合为：</p>
<p>$\begin{cases} (a_1 \times a_2 + 1) \times a_3 + 1 = a_1 \times a_2 \times a_3 + a_3 + 1 \\ (a_1 \times a_3 + 1) \times a_2 + 1 = a_1 \times a_2 \times a_3 + a_2 + 1 \\ (a_2 \times a_3 + 1) \times a_1 + 1 = a_1 \times a_2 \times a_3 + a_1 + 1 \\ \end{cases}$</p>
<p>显然命题成立。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327211209245.png" alt="image-20220327211209245" style="zoom:67%;" /></p>
<blockquote>
<p>推广到k = n的情况</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327211447844.png" alt="image-20220327211447844" style="zoom:67%;" /></p>
<blockquote>
<p>证明引理</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327211602006.png" alt="image-20220327211602006" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327211650509.png" alt="image-20220327211650509" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327211712445.png" alt="image-20220327211712445" style="zoom:67%;" /></p>
<blockquote>
<p>整理证明思路：</p>
<p>数学归纳法：</p>
<p>①k=3时，经过简单的推导可证</p>
<p>②假设k=n时成立，证明k=n+1的情况。</p>
<p>——先证明引理成立。假设$a_i$和$a_j$的关系，从左边开始对$a_i$进行代换，最后得到右式加上一个正数，得到左&gt;右。</p>
<p>对引理推广，把[A]推广到{A}</p>
<p>——然后证明新加入的元素$a_{n+1}$按照数列最小值优先组合的规则，仍可以得到最大值。假设第$i$步变换后，数列中剩余元素均大于$a_{n+1}$。选取最小的元素$a_k &gt; a_{n+1}$，数列中的剩余元素集合表示为$A_j$。由前面证明过的引理，$[[A_i],a_{n+1},\{A_j\},a_k] &gt; [[A_i],a_k,\{A_j\},a_{n+1}]$成立，得到最大值，则k=n+1时命题成立。</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p>存储：用数组<code>a[n]</code>存储数列</p>
</li>
<li><p>计算：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327212022890.png" alt="image-20220327212022890" style="zoom:80%;" /></p>
</li>
</ol>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327212129556.png" alt="image-20220327212129556" style="zoom:80%;" /></p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> a[MAXN];    <span class="comment">// 存储序列元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;	<span class="comment">// 降序排序的比较函数</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求数列的极大值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculation_max</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);    <span class="comment">// 从小到大排序</span></span><br><span class="line">        <span class="comment">// 第一小和第二小</span></span><br><span class="line">        a[<span class="number">1</span>] = a[<span class="number">1</span>]*a[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = a[n]; <span class="comment">// 用最后一个值覆盖旧值</span></span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">1</span>]*a[<span class="number">2</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求数列的极小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculation_min</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);    <span class="comment">// 从大到小排序</span></span><br><span class="line">        a[<span class="number">1</span>] = a[<span class="number">1</span>]*a[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">2</span>] = a[n];</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">1</span>]*a[<span class="number">2</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min of array:&quot;</span> &lt;&lt; <span class="built_in">calculation_min</span>(b,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> c[] = &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max of array:&quot;</span> &lt;&lt; <span class="built_in">calculation_max</span>(c,<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329163500497.png" alt="image-20220329163500497" style="zoom:80%;" /></p>
</li>
</ul>
<ul>
<li><p><strong>算法分析</strong></p>
<ol>
<li>问题的输入规模为n；</li>
<li>计算极值循环n-2次；</li>
<li>若使用堆排序方法，选择第1，2小/大值：$T(n) = logn + log(n-1)$；</li>
<li>综合（2）和（3），可得：$T(n) = (n-2)(logn+log(n-1)) = O(nlogn)$</li>
</ol>
<blockquote>
<p>贪心：每次都选择极值（最大or最小）</p>
</blockquote>
</li>
</ul>
<h3 id="【例7-3】最优装载"><a href="#【例7-3】最优装载" class="headerlink" title="【例7-3】最优装载"></a>【例7-3】最优装载</h3><p>有一批集装箱准备装上轮船，编号依次为$1, 2, …, n$，其中集装箱$i$的重量是$w_i，i=1, 2,…, n$。已知轮船最多装载量是$C$，每个集装箱的重量$w_i \leq C$，且对集装箱无体积限制，设计算法求如何选择能够使得装上的集装箱个数最多。</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327212828019.png" alt="image-20220327212828019" style="zoom:67%;" /></p>
<blockquote>
<p><strong>贪心策略：</strong>轻者优先</p>
</blockquote>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327212923334.png" alt="image-20220327212923334" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法分析</strong></p>
<ol>
<li>问题的输入规模为n；</li>
<li>选择集装箱是主要工作，时间渐近复杂度：$T(n) = n$；</li>
<li>排序最快的时间复杂度为：$T(n) = O(nlogn)$；</li>
<li>上述（2）和（3）并列执行的，按照第2章的定理2.2（加法定理）可知本例的时间渐近复杂度为$T(n) = O(nlogn)$</li>
</ol>
<blockquote>
<p>这个问题仍为NP问题，涉及选择树</p>
</blockquote>
</li>
</ul>
<h3 id="【例7-4】整数变换"><a href="#【例7-4】整数变换" class="headerlink" title="【例7-4】整数变换"></a>【例7-4】整数变换</h3><p>键盘输入一个高精度的正整数N，去掉其中任意 S个数字后剩下的数字按原左右次序将组成一个新的正整数。</p>
<p>对给于定的N和S，寻找一种方案使得剩下的数字组成的新数最小。</p>
<p>输出：包括所去掉数字的位置和组成的新正整数。</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327213714939.png" alt="image-20220327213714939" style="zoom:80%;" /></p>
<blockquote>
<p><strong>删除策略</strong>：</p>
<p>对于$n_2$：高位的大数没有删除干净——删除一个高位数字后需要回溯继续删除，才能保证把大数字删干净；</p>
<p>对于$n_3$：当大数都在后面时，直接从后面的数字开始删除；</p>
<p>对于$n_4$：需要把前面多余的0删掉。</p>
<p><strong>物理删除</strong>：</p>
<p>后面的数字把前面的数字覆盖</p>
<p><strong>注意</strong>：</p>
<p>需要最优值和最优解（删除后的结果和删除的位置）</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p>存储</p>
<p><code>a[]</code>存储字数N，<code>data[]</code>记录删除的元素在原数字中的位置；</p>
<p>存在一位回溯的操作，设置变量<code>j1</code>来记住上一次删除的位置。</p>
</li>
<li><p>计算</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327214040361.png" alt="image-20220327214040361" style="zoom: 80%;" /></p>
</li>
</ol>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327214130757.png" alt="image-20220327214130757" style="zoom: 80%;" /></p>
<blockquote>
<p>注意使用了语言上的特色：C语言字符串末尾的’\0’是在ASCII中为0，最小。j不再增长，应对例子中的$n_3$情况。</p>
</blockquote>
</li>
</ul>
<h2 id="7-2-近似贪心问题"><a href="#7-2-近似贪心问题" class="headerlink" title="7.2 近似贪心问题"></a>7.2 近似贪心问题</h2><p>引入随机，使算法变快，提高算法效率。</p>
<h3 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327214312092.png" alt="image-20220327214312092" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第6章 回溯法与分支限界法</title>
    <url>/algorithm/algorithm-ch6/</url>
    <content><![CDATA[<p>回溯和蛮力法的区别：回溯法在求解过程中进行剪枝；蛮力法在计算之前优化</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>回溯法的设计技术</li>
<li>回溯法的经典例题</li>
<li>分支限界法的设计技术</li>
<li>分支限界法的经典例题</li>
</ul>
<span id="more"></span>
<h2 id="6-1-回溯法"><a href="#6-1-回溯法" class="headerlink" title="6.1 回溯法"></a>6.1 回溯法</h2><ul>
<li><p><strong>回溯法(Back Tracking  Algorithm)</strong>：在约束条件下对解空间树进行深度优先搜索的过程，并在搜索过程中剪去那些不满足条件的分支</p>
</li>
<li><p><strong>问题的解</strong>：为n元组$(X_1,…,X_i,…X_n)$，其中$X_i$选自有限集$S$，当选出一组值$X=(x_1,…,x_i,…x_n)$能够使评价函数$P(x_1,…,x_i,…x_n) $满足问题的某种约束条件或到达极值</p>
</li>
<li><p><strong>基本策略</strong>：每次只考虑一个分量，逐次扩大建立n元组，并随时用<strong>评价函数</strong>$P_i(X_1,…,X_i,…X_n)$去判断正在形成的n元组是否有成功的希望，一旦确定部分元组$(X_1, … ,X_i)$不能求出解时，则立即停止这种搜索，“剪掉”以当前结点为根的分枝，并逐次向上一个分量回溯，然后向其它分支继续探索。</p>
</li>
<li><p><strong>算法框架</strong></p>
<ul>
<li>(1) 开始结点是一个活结点，也是一个扩展结点；</li>
<li>(2) 如果能从当前的扩展结点移动到一个新的结点，那么这个新结点将变成一个活结点和可扩展结点，旧的扩展结点仍是一个活结点。</li>
<li>(3) 如果不能移动到一个新结点(已经找到一个解或违反约束的情况)，当前的扩展结点就变成了一个死结点，便只能返回到最近被考察的活结点<strong>(回溯)</strong>,这个活结点就变成了新的扩展结点。</li>
<li>(4) 当找到了最优解或者没有活结点的时候（回溯尽了所有的活结点），搜索过程结束。</li>
</ul>
<blockquote>
<p>关注活结点、扩展结点和死结点的变化规律</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320210108433.png" alt="image-20220320210108433" style="zoom:67%;" /></p>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321091821748.png" alt="image-20220321091821748" style="zoom: 80%;" /></p>
<blockquote>
<p>（1）不唯一，是n元组</p>
<p>（2）使用死结点回退至活结点，建立新的可扩展结点进行剪枝</p>
</blockquote>
<ul>
<li><p>回溯算法的适用条件——<strong>多米诺性质</strong></p>
<p>求解过程中，下一个解包含之前的解</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320210155001.png" alt="image-20220320210155001" style="zoom: 67%;" /></p>
<blockquote>
<p>若不满足多米诺性质，则可能会丢解</p>
</blockquote>
</li>
</ul>
<h3 id="【例6-1】求满足下列不等式的所有整数解"><a href="#【例6-1】求满足下列不等式的所有整数解" class="headerlink" title="【例6-1】求满足下列不等式的所有整数解"></a>【例6-1】求满足下列不等式的所有整数解</h3><p>求满足下列不等式的所有整数解：$5x_1+4x_2-x_3≤10 , \ \ 1≤x_i≤3 , \ \ i=1, 2, 3$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320210354554.png" alt="image-20220320210354554" style="zoom: 67%;" /></p>
<blockquote>
<p>对于原约束条件，当$x_1 = 1, x_2 = 1$时不满足约束条件，被剪去，不考虑$x_3$的情况，违反了多米诺性质。但是由于是$-x_3$，当$x_3 = 3$时是满足约束条件的，因此丢解。</p>
</blockquote>
<h3 id="【例6-2】装载问题"><a href="#【例6-2】装载问题" class="headerlink" title="【例6-2】装载问题"></a>【例6-2】装载问题</h3><p>有$n$个集装箱要装上一艘载重量为$c$的轮船，其中，集装箱$i$的重量为$w_i$。找出一种最优装载方案，让轮船尽可能多装集装箱，即在装载体积不受限制的情况下，尽可能使轮船满载。</p>
<ul>
<li><p>问题分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320210526008.png" alt="image-20220320210526008" style="zoom: 67%;" /></p>
</li>
</ul>
<p>  <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320210556584.png" alt="image-20220320210556584" style="zoom: 67%;" /></p>
<ul>
<li><p>计算模型</p>
<ol>
<li><p>数据结构定义</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320210658174.png" alt="image-20220320210658174" style="zoom: 67%;" /></p>
</li>
<li><p>迭代公式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320210731000.png" alt="image-20220320210731000" style="zoom: 67%;" /></p>
</li>
</ol>
</li>
<li><p>算法设计与描述</p>
<blockquote>
<p>i &gt; n时，已经出来一组解。当nowc &gt; maxc时，进行更新</p>
<p>回溯条件：当前装载的容量加上之前装载的容量大于最大载重量</p>
<p>左子树：取当前集装箱；</p>
<p>右子树（之前装载的容量加上当前集装箱的重量超过最大载重量）：不取当前集装箱。同时判断当前分支是否为最优解</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320211935582.png" alt="image-20220320211935582" style="zoom:67%;" /></p>
</li>
<li><p>算法分析</p>
<p>需要考察层数</p>
<blockquote>
<p>1, 2, 4, 8, … , $2^{n-1}$</p>
</blockquote>
<p>时间复杂度$O(2^n)$</p>
</li>
</ul>
<h3 id="【例6-3】n皇后问题"><a href="#【例6-3】n皇后问题" class="headerlink" title="【例6-3】n皇后问题"></a>【例6-3】n皇后问题</h3><p>在$n*n$的棋盘上放置相互攻击不到的$n$个皇后。</p>
<blockquote>
<p>国际象棋规则：任意两个皇后之间不能处在同一行、同一列和同一斜线上，否则皇后间就可以相互攻击。</p>
</blockquote>
<p>请给出满足条件的所有方案。</p>
<ul>
<li><p>问题分析</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320212850861.png" alt="image-20220320212850861" style="zoom: 50%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>数据结构</strong></p>
<blockquote>
<p>皇后数量为n；sum为可行解的数量。<br>x[ ]记录皇后的摆放位置，下标为皇后所在行，值为列。</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<blockquote>
<p>（1）考虑$n\times n$棋盘都要覆盖到</p>
<p>（2）对行和列约束</p>
<p>（3）判断是否在对角线的约束条件</p>
<p>后两个涉及剪枝，是评价函数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213114940.png" alt="image-20220320213114940" style="zoom:67%;" /></p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>算法设计与描述</strong></p>
<blockquote>
<p>在ok函数中，需要判断前i-1个已经摆放好位置的皇后与摆放的位置是否冲突</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213142313.png" alt="image-20220320213142313" style="zoom:67%;" /></p>
</li>
</ul>
<ul>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断当前格局是否满足约束</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ok</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x[i] == x[j] || (<span class="built_in">abs</span>(x[i] - x[j]) == <span class="built_in">abs</span>(i - j))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queen</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到可行解</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        ++sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        x[i] = j;</span><br><span class="line">        <span class="comment">// 满足约束</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ok</span>(i)) &#123;</span><br><span class="line">            <span class="built_in">queen</span>(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>算法分析</strong></p>
<p>在解空间树中，每一层的层数表示皇后摆放的所在行。</p>
<blockquote>
<p>1, n, $n^2$, … , $n^n$</p>
</blockquote>
<p>还要考虑ok函数的时间复杂度</p>
<blockquote>
<p>1, 2, 3, 4, … , n = $(n+1)*n / 2$</p>
</blockquote>
<p>时间复杂度为：$T(n) = O(2n^n \times n(n+1)/2) = O(n^{n+2})$</p>
</li>
</ul>
<h3 id="【例6-4】0-1背包问题"><a href="#【例6-4】0-1背包问题" class="headerlink" title="【例6-4】0-1背包问题"></a>【例6-4】0-1背包问题</h3><p>已知有$n$件物品，物品$i$的重量为$w_i$、价值为$p_i$。现从中选取一部分物品装入一个背包内，背包最多可容纳的总重量是$m$，如何选择才能使得物品的总价值最大？</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213511029.png" alt="image-20220320213511029" style="zoom:67%;" /></p>
</li>
<li><p><strong>数学模型</strong></p>
<blockquote>
<p>目标函数：$p_i$：第$i$个物品的价值；$x_i$：第$i$个物品是否被选中</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213531394.png" alt="image-20220320213531394" style="zoom: 67%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>数据结构</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213601774.png" alt="image-20220320213601774" style="zoom: 67%;" /></p>
</li>
<li><p><strong>迭代公式</strong></p>
<blockquote>
<p>右支：判断剩余物品总价值和当前已装入物品的总价值之和是否小于最大值。小于则剪掉（肯定找不到最优解）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213623691.png" alt="image-20220320213623691" style="zoom: 67%;" /></p>
</li>
</ol>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213648620.png" alt="image-20220320213648620" style="zoom: 67%;" /></p>
</li>
<li><p><strong>算法实现</strong></p>
</li>
</ul>
<ul>
<li><p><strong>算法分析</strong></p>
<p>n个物品的选择树，其结点数为：</p>
<script type="math/tex; mode=display">
1+2+2^2+...+2^n \ = \ 2^{n+1}-1 \leq 2 \times 2^n \ = \ O(2^n)</script></li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323083748401.png" alt="image-20220323083748401" style="zoom:80%;" /></p>
<p>都形成了递归树，每次两支</p>
<p>区别在于是否对右子树进行剪枝。时间渐进复杂度没有太大区别，均为$O(2^n)$</p>
<h3 id="【例6-5】旅行商问题（TSP）"><a href="#【例6-5】旅行商问题（TSP）" class="headerlink" title="【例6-5】旅行商问题（TSP）"></a>【例6-5】旅行商问题（TSP）</h3><ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213921767.png" alt="image-20220320213921767" style="zoom: 67%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>数据结构</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320213950679.png" alt="image-20220320213950679" style="zoom:67%;" /></p>
</li>
<li><p><strong>迭代公式</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320214010571.png" alt="image-20220320214010571" style="zoom:67%;" /></p>
</li>
</ol>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320214103371.png" alt="image-20220320214103371" style="zoom: 50%;" /></p>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220320214126497.png" alt="image-20220320214126497" style="zoom:67%;" /></p>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323084555758.png" alt="image-20220323084555758" style="zoom: 80%;" /></p>
<p>回溯法增加了剪枝的操作</p>
<p>蛮力法与回溯法的时间渐进复杂度均为$O((n-1)!)$</p>
<h2 id="6-2-分支限界法"><a href="#6-2-分支限界法" class="headerlink" title="6.2 分支限界法"></a>6.2 分支限界法</h2><ul>
<li>分支限界法：增加约束条件，<strong>剪掉解空间中更多分支</strong>，加快算法的执行速度</li>
<li>约束条件<ul>
<li>（1）<strong>上界函数</strong>：用来求得以当前结点为根的可行性解<strong>可能达到的极值</strong>。<em>（预测）</em></li>
<li>（2）<strong>限界值</strong>：搜索到某一结点时，<strong>已经得到</strong>可行解或可能包含可行性解的<strong>最优值</strong>。</li>
<li>（3）<strong>评价函数</strong>：判定当前所获得路径或值是否为解的函数。</li>
</ul>
</li>
<li>剪枝<ul>
<li>（1）该结点的上界小于限界值，即再往下搜索也不可能有更优的值。</li>
<li>（2）该结点无法代表任何可行解，因为它已经违反了问题的约束，不能满足评价函数。</li>
<li>（3）该结点代表的可行解的子集只包含一个单独的点。</li>
</ul>
</li>
<li>分支限界法的设计步骤<ul>
<li>（1）建立上界函数，函数值是以该结点为根的搜索树中的所有可行解在目标函数上求得值的上/下界。</li>
<li>（2）求得限界值，即当前巳经得到的可行解的目标函数的最大值。</li>
<li>（3）依据剪枝条件，停止分支的搜索，向上回溯到父结点。</li>
<li>（4）限界值的更新：当得到的可行解的目标函数值大于/小于当前限界值时，更新之。</li>
</ul>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323090228485.png" alt="image-20220323090228485" style="zoom:80%;" /></p>
<h3 id="【例6-6】装载问题"><a href="#【例6-6】装载问题" class="headerlink" title="【例6-6】装载问题"></a>【例6-6】装载问题</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322163643589.png" alt="image-20220322163643589" style="zoom:67%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<ul>
<li>目标函数和约束条件（与例6-3相同）</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322163722711.png" alt="image-20220322163722711" style="zoom:67%;" /></p>
<ul>
<li><p>解空间树（与例6-3相同）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322163832040.png" alt="image-20220322163832040" style="zoom:67%;" /></p>
</li>
<li><p>考虑限界值</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322163947384.png" alt="image-20220322163947384" style="zoom:67%;" /></p>
<blockquote>
<p>限界值：当前最优值</p>
<p>评价函数：是否超过限制（是否能继续递归）</p>
<p>上界函数：最优值是否更新</p>
</blockquote>
<p>基于评价函数和上界函数的剪枝——使用队列</p>
<blockquote>
<p>BFS</p>
<p>0为分层标志</p>
<p>对于一个结点，出队，先考察评价函数（不超过最大载重量），再考察上界函数（已装入+剩余 &gt; 当前最大值，则可能取得最大值，可以继续。否则不可能，退出）</p>
<p><strong>bestw是限界值</strong></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164103359.png" alt="image-20220322164103359" style="zoom: 80%;" /></p>
</li>
</ul>
</li>
<li><p><strong>计算模型</strong></p>
<ul>
<li><p><strong>结点的构造</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164216783.png" alt="image-20220322164216783" style="zoom: 80%;" /></p>
</li>
<li><p><strong>评价函数</strong>：$lw + w[i] &lt; c$</p>
</li>
<li><p><strong>上界函数</strong>：$s + lw &gt; c$</p>
</li>
</ul>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164354810.png" alt="image-20220322164354810" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164433362.png" alt="image-20220322164433362" style="zoom:67%;" /></p>
</li>
<li><p><strong>算法实现</strong></p>
<ul>
<li><code>Queue.h</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __QUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __QUEUE_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Queue</span>() &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; element)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(T&amp; element)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;T&gt; Q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Queue&lt;T&gt;::<span class="built_in">Add</span>(<span class="type">const</span> T&amp; element) &#123;</span><br><span class="line">    Q.<span class="built_in">push</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Queue&lt;T&gt;::<span class="built_in">Delete</span>(T&amp; element) &#123;</span><br><span class="line">    element = Q.<span class="built_in">front</span>();</span><br><span class="line">    Q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否为空</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> Queue&lt;T&gt;::<span class="built_in">IsEmpty</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> Q.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>核心算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Queue.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类模板和函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">QType</span>&gt; <span class="keyword">class</span> <span class="title class_">QNode</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">int</span> <span class="title">EnQueue</span><span class="params">(Queue&lt;QNode&lt;T&gt;*&gt; &amp;Q, T pw, <span class="type">int</span> i, <span class="type">int</span> n, T bestw, QNode&lt;T&gt; *E, QNode&lt;T&gt; *&amp;bestE, <span class="type">int</span> bestv[], <span class="type">bool</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt; Type <span class="title">MaxLoading</span><span class="params">(Type w[], Type c, <span class="type">int</span> n, <span class="type">int</span> bestv[])</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">QType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="comment">// 使用友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; </span></span><br><span class="line"><span class="function">    <span class="keyword">friend</span> <span class="type">int</span> <span class="title">EnQueue</span><span class="params">(Queue&lt;QNode&lt;T&gt;*&gt; &amp;Q, T pw, <span class="type">int</span> i, <span class="type">int</span> n, T bestw, QNode&lt;T&gt; *E, QNode&lt;T&gt; *&amp;bestE, <span class="type">int</span> bestv[], <span class="type">bool</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Type&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">friend</span> Type <span class="title">MaxLoading</span><span class="params">(Type w[], Type c, <span class="type">int</span> n, <span class="type">int</span> bestv[])</span></span>;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QNode *parent;  <span class="comment">// 父结点</span></span><br><span class="line">    <span class="type">bool</span> LChild;    <span class="comment">// 左孩子标志，1-左，0-右</span></span><br><span class="line">    QType weight;   <span class="comment">// 结点权值</span></span><br><span class="line">    <span class="built_in">QNode</span>(QType pw, QNode *E, <span class="type">bool</span> x) &#123; <span class="comment">// 构造函数，给结点权值、父结点、左孩子标志赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = E;</span><br><span class="line">        <span class="keyword">this</span>-&gt;LChild = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = pw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的内容</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 求最大载重量</span></span><br><span class="line"><span class="comment"> * @param &#123;w&#125; 集装箱重量集合</span></span><br><span class="line"><span class="comment"> * @param &#123;c&#125; 船的载重量</span></span><br><span class="line"><span class="comment"> * @param &#123;n&#125; 集装箱总个数</span></span><br><span class="line"><span class="comment"> * @param &#123;bestv&#125; 装船最优值</span></span><br><span class="line"><span class="comment"> * @return &#123;最大装船值&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Type <span class="title">MaxLoading</span><span class="params">(Type w[], Type c, <span class="type">int</span> n, <span class="type">int</span> bestv[])</span> </span>&#123;</span><br><span class="line">    Queue&lt;QNode&lt;Type&gt;*&gt; Q;</span><br><span class="line">    Q.<span class="built_in">Add</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">// 层数，每一层代表递归至层数对应的物品</span></span><br><span class="line">    <span class="comment">// lw已装船总重量，bestw当前装船最优值，s剩余总重量</span></span><br><span class="line">    Type lw = <span class="number">0</span>, bestw = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) s += w[j]; <span class="comment">// 初始化s</span></span><br><span class="line">    QNode&lt;Type&gt; *E = <span class="literal">nullptr</span>, *bestE;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Type pw = lw + w[i]; <span class="comment">// 预装重量</span></span><br><span class="line">        <span class="keyword">if</span> (pw &lt;= c) &#123;  <span class="comment">// 预装重量在载重量范围内</span></span><br><span class="line">            <span class="keyword">if</span> (pw &gt; bestw) &#123; <span class="comment">// 获得更优的值</span></span><br><span class="line">                bestw = pw; <span class="comment">///更新最优值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q,pw,i,n,bestw,E,bestE,bestv,<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lw + s &gt;= bestw) &#123; <span class="comment">// 不满足上界函数，剪枝</span></span><br><span class="line">            <span class="comment">// 向队列Q加入右结点，不选择集装箱</span></span><br><span class="line">            <span class="built_in">EnQueue</span>(Q,lw,i,n,bestw,E,bestE,bestv,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Q.<span class="built_in">Delete</span>(E);  <span class="comment">// 取出Q队头元素，赋给E</span></span><br><span class="line">        <span class="keyword">if</span> (!E) &#123; </span><br><span class="line">            <span class="keyword">if</span> (Q.<span class="built_in">IsEmpty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            Q.<span class="built_in">Add</span>(<span class="literal">nullptr</span>);  <span class="comment">// 加入分层结点</span></span><br><span class="line">            Q.<span class="built_in">Delete</span>(E);</span><br><span class="line">            i++;</span><br><span class="line">            s -= w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        lw = E-&gt;weight; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定取最优值的集装箱装载情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = n<span class="number">-1</span>; j &gt; <span class="number">0</span>; --j) &#123;</span><br><span class="line">        bestv[j] = bestE-&gt;LChild;</span><br><span class="line">        bestE = bestE-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 入队操作</span></span><br><span class="line"><span class="comment"> * @param &#123;Q&#125; 用于分支限界的队列</span></span><br><span class="line"><span class="comment"> * @param &#123;pw&#125; 当前已装入货物的总重量</span></span><br><span class="line"><span class="comment"> * @param &#123;i&#125; 当前为第i件集装箱</span></span><br><span class="line"><span class="comment"> * @param &#123;n&#125; 集装箱总个数</span></span><br><span class="line"><span class="comment"> * @param &#123;bestw&#125; 当前装船的最优值</span></span><br><span class="line"><span class="comment"> * @param &#123;E&#125; 当前货物结点的父结点，作为一个中间量，连接parent和child</span></span><br><span class="line"><span class="comment"> * @param &#123;bestE&#125; 指向最优解的叶子节点，然后通过bestE-&gt;parent找到装入了哪些物品</span></span><br><span class="line"><span class="comment"> * @param &#123;bestv&#125; 最优值对应选取货物的集合（1-取，0-未取）</span></span><br><span class="line"><span class="comment"> * @param &#123;x&#125; 左孩子标志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">EnQueue</span><span class="params">(Queue&lt;QNode&lt;Type&gt;*&gt; &amp;Q, Type pw, <span class="type">int</span> i, <span class="type">int</span> n, Type bestw, QNode&lt;Type&gt; *E, QNode&lt;Type&gt; *&amp;bestE, <span class="type">int</span> bestv[], <span class="type">bool</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n) &#123;   <span class="comment">// 到达叶结点</span></span><br><span class="line">        <span class="keyword">if</span> (pw == bestw) &#123;  <span class="comment">// 找到最优值</span></span><br><span class="line">            bestE = E;</span><br><span class="line">            bestv[n] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QNode&lt;Type&gt; *b = <span class="keyword">new</span> <span class="built_in">QNode</span>&lt;Type&gt;(pw,E,x);</span><br><span class="line">    Q.<span class="built_in">Add</span>(b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> N = <span class="number">4</span>;</span><br><span class="line">    <span class="type">double</span> w[] = &#123;<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x[N+<span class="number">1</span>];</span><br><span class="line">    <span class="type">double</span> bestw;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;weight of ship is &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;weight of goods: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)	cout &lt;&lt; w[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    bestw = <span class="built_in">MaxLoading</span>(w,c,N,x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;result is: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)	cout &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;best weight is: &quot;</span> &lt;&lt; bestw &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323133553532.png" alt="image-20220323133553532"></p>
</li>
</ul>
<p>【思考题】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323093725306.png" alt="image-20220323093725306" style="zoom:80%;" /></p>
<p>分支限界法相较于回溯法省略了更多的分支，效率更高。</p>
<p>从算法实现的角度，分支限界法使用bfs（利用队列），回溯法采用dfs</p>
<h3 id="【例6-7】-完全背包问题"><a href="#【例6-7】-完全背包问题" class="headerlink" title="【例6-7】 完全背包问题"></a>【例6-7】 完全背包问题</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164542720.png" alt="image-20220322164542720" style="zoom: 80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164616642.png" alt="image-20220322164616642" style="zoom:80%;" /></p>
<blockquote>
<p>子树扩展</p>
<p>A对应6个分支：0, 1, 2, 3, 4, 5</p>
<p>C对应3个分支：0, 1, 2</p>
<p>在满足评估函数的前提下，上界函数：以C为例，$(m-\sum_{i = 1}^{2})\frac{4}{5}$</p>
<p><strong>限界值的选取</strong>：把物品粉碎，按照每单元价值$\times$剩余单元数，计算得到理想值——剩余单位空间*单位价值</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164646016.png" alt="image-20220322164646016" style="zoom:67%;" /></p>
<p>若一个物品都无法装入，k &gt; 0的情况直接回溯，k = 0的情况继续该分支，装下一个物品。</p>
<p>更新限界值</p>
<blockquote>
<p>剪枝：</p>
<p>①物品能否可以装入——剪当前分支的子分支</p>
<p>②是否满足上界函数——剪当前整个分支</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>数据结构</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164715530.png" alt="image-20220322164715530" style="zoom: 67%;" /></p>
</li>
<li><p><strong>递归出口</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322164946783.png" alt="image-20220322164946783" style="zoom: 80%;" /></p>
<blockquote>
<p>每一个物品都考虑过了，i == n。此时需要更新最优解</p>
<p>最优总价值bestV&gt;当前分支的上界ULimit。需要更新最优总价值</p>
</blockquote>
</li>
<li><p><strong>迭代公式</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322165033528.png" alt="image-20220322165033528" style="zoom: 80%;" /></p>
</li>
</ol>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322165151321.png" alt="image-20220322165151321" style="zoom:80%;" /></p>
<blockquote>
<p>maxG：当前分支考虑的子分支个数</p>
<p>注意背包装满后，把后面的装载物品置为0（不选这些物品）</p>
<p>与蛮力法和回溯法一样，都需要在递归后恢复</p>
</blockquote>
</li>
</ul>
<h3 id="【例6-8】旅行商问题"><a href="#【例6-8】旅行商问题" class="headerlink" title="【例6-8】旅行商问题"></a>【例6-8】旅行商问题</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322165230536.png" alt="image-20220322165230536" style="zoom: 80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322165305657.png" alt="image-20220322165305657" style="zoom:80%;" /></p>
<blockquote>
<p>贪心策略：每次找与未访问顶点的最短路。——找到上界</p>
<p>不考虑每个城市逗留一次的条件，找最短的路径——下届</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220328083919421.png" alt="image-20220328083919421" style="zoom: 80%;" /></p>
<blockquote>
<p>求解界函数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322165344938.png" alt="image-20220322165344938" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322165515919.png" alt="image-20220322165515919" style="zoom:80%;" /></p>
<blockquote>
<p>使用优先队列</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173340996.png" alt="image-20220322173340996" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173443533.png" alt="image-20220322173443533" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173613696.png" alt="image-20220322173613696" style="zoom: 80%;" /></p>
<blockquote>
<p>代码级优化：</p>
<p>①向上取整（+1）</p>
<p>②出现第一个解，发现正好等于上界，停止算法（找不到更优的解了）</p>
</blockquote>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>数据结构</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173707452.png" alt="image-20220322173707452" style="zoom:80%;" /></p>
</li>
<li><p><strong>贪心算法初始化TSP问题的上界</strong><code>up</code></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173737173.png" alt="image-20220322173737173" style="zoom:80%;" /></p>
</li>
<li><p><strong>求TSP问题的下界</strong><code>low</code></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173800540.png" alt="image-20220322173800540" style="zoom:80%;" /></p>
</li>
<li><p><strong>每个分支的下界</strong><code>lb</code></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173828412.png" alt="image-20220322173828412" style="zoom:80%;" /></p>
</li>
<li><p><strong>计算方法</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173914894.png" alt="image-20220322173914894" style="zoom: 80%;" /></p>
</li>
</ol>
</li>
<li><p><strong>算法设计与描述</strong></p>
<blockquote>
<p>优化：重载小于</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322173955499.png" alt="image-20220322173955499" style="zoom:80%;" /></p>
<ul>
<li>求由p引导的分支的下界和进入并离开每个未遍历城市的最小成本</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322174102069.png" alt="image-20220322174102069" style="zoom: 80%;" /></p>
<ul>
<li>使用优先队列，进行dfs。计算上下界</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322174229023.png" alt="image-20220322174229023" style="zoom:80%;" /></p>
<ul>
<li><p>求解过程</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322174435695.png" alt="image-20220322174435695" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322174512703.png" alt="image-20220322174512703" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第8章 动态规划</title>
    <url>/algorithm/algorithm-ch8/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>动态规划的设计技术</li>
<li>投资分配问题</li>
<li>背包问题</li>
<li>矩阵连乘问题</li>
<li>最大子段和问题</li>
<li>最长公共子序列问题</li>
</ul>
<blockquote>
<p>主要讲解前三个问题</p>
<p>难点：</p>
<p>①最优解特征分析与阶段划分</p>
<p>②计算模型的建立</p>
</blockquote>
<span id="more"></span>
<h2 id="8-1-动态规划的设计技术"><a href="#8-1-动态规划的设计技术" class="headerlink" title="8.1 动态规划的设计技术"></a>8.1 动态规划的设计技术</h2><p><strong>动态规划的基本设计思想</strong></p>
<p>将待求解问题分解成若干个子问题，分阶段求解子问题，前一阶段子问题的解成为求后续阶段子问题的解的计算信息，最后用这些子问题的最优解构造出原问题的最优解。</p>
<blockquote>
<p>子结构通常要求各自独立</p>
</blockquote>
<p><strong>适合用动态规划求解的问题的特点</strong></p>
<p>整个问题的求解过程可以划分为若干阶段</p>
<p><strong>动态规划算法的基本性质</strong></p>
<ol>
<li><p><strong>子问题的重叠性</strong></p>
<ul>
<li>子问题重复</li>
<li>子问题的解在下一阶段决策中延续并可能多次使用</li>
</ul>
</li>
<li><p><strong>最优子结构</strong></p>
<p>一个问题的最优解包含着它的子问题的最优解</p>
</li>
</ol>
<h3 id="【例8-1】数塔"><a href="#【例8-1】数塔" class="headerlink" title="【例8-1】数塔"></a>【例8-1】数塔</h3><blockquote>
<p>按照贪心策略，自顶向下或者自底向上都没有得到最优解</p>
<p>动态规划的策略：自底向上，更新计算各层各个顶点的累加和的最大值，一层一层淘汰</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404082011666.png" alt="image-20220404082011666" style="zoom: 80%;" /></p>
<p>核心问题：阶段如何划分？子集合如何划分？接下来再考虑子集合状态的转移</p>
<ul>
<li><p><strong>问题分析</strong></p>
<p>考虑列坐标的偏移量（取值为0或1），存入<code>path[][]</code>中</p>
<blockquote>
<p>$path[i][j]$表示第$i$阶段第$j$列的元素对应第$i+1$行最优解的元素的偏移量</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404082034208.png" alt="image-20220404082034208" style="zoom:67%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>存储结构</strong></p>
<p><code>data[n][n]</code>存储原始数据信息；</p>
<p><code>r[n][n]</code>存储每一阶段的路径的计算结果；</p>
<p><code>path[n][n]</code>存储下一步最优结点列坐标。</p>
</li>
<li><p><strong>计算</strong>：</p>
<p><strong>阶段性最优</strong>：</p>
<script type="math/tex; mode=display">
r[i][j] = max\{r[i+1][j],r[i+1][j+1]\}+data[i][j] \quad i = n-2,...,1; \ j \leq i</script><p><strong>下一最优子结点的列坐标</strong>：</p>
<script type="math/tex; mode=display">
path[i][j] = 
\begin{cases}
0 \quad if \ r[i+1][j] \geq r[i+1][j+1] \ and \ 0 < i < n, \ 0 < j \leq i \\
1 \quad if \ r[i+1][j] < r[i+1][j+1] \ and \ 0 < i < n, \ 0 < j \leq i \\
\end{cases}</script><p><strong>最优解</strong>：</p>
<p>$data[1][1] \to data[2][1+path[1][1]] \to … \to data[i][j] \to … \quad, j = j+path[i][j]$</p>
<p><strong>最优值</strong>：</p>
<p>$data[1][1]$</p>
</li>
</ol>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DataTower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data[MAXN][MAXN] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 用二维数组存储数据</span></span><br><span class="line">    <span class="type">int</span> r[MAXN][MAXN] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 存储运算结果</span></span><br><span class="line">    <span class="type">int</span> path[MAXN][MAXN] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 存储路径结点</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">// 数塔的层数</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            cin &gt;&gt; data[i][j];  <span class="comment">// 输入数塔</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        r[n][j] = data[n][j];   <span class="comment">// 最下层的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) &#123;    <span class="comment">// 阶段，按层划分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;  <span class="comment">// 阶段最优值解</span></span><br><span class="line">            <span class="keyword">if</span> (r[i+<span class="number">1</span>][j] &gt; r[i+<span class="number">1</span>][j+<span class="number">1</span>]) &#123;</span><br><span class="line">                r[i][j] = r[i+<span class="number">1</span>][j] + data[i][j];</span><br><span class="line">                path[i][j] = <span class="number">0</span>; <span class="comment">// 列坐标偏移量为0，表示最优解在下一行同一列的位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r[i][j] = r[i+<span class="number">1</span>][j+<span class="number">1</span>] + data[i][j];</span><br><span class="line">                path[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最大权值及权值最大的路径</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max value of the tower is &quot;</span> &lt;&lt; r[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt;  data[i][j] &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> ;</span><br><span class="line">        j = j + path[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; data[i][j] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DataTower</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">11 14</span></span><br><span class="line"><span class="comment">10 5 8</span></span><br><span class="line"><span class="comment">3 17 9 4</span></span><br><span class="line"><span class="comment">18 7 12 6 16</span></span><br><span class="line"><span class="comment">*</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220403093303626.png" alt="image-20220403093303626" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<h2 id="8-2-投资分配问题"><a href="#8-2-投资分配问题" class="headerlink" title="8.2 投资分配问题"></a>8.2 投资分配问题</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404085706004.png" alt="image-20220404085706004" style="zoom:80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404085517278.png" alt="image-20220404085517278" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404085533286.png" alt="image-20220404085533286" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404085549374.png" alt="image-20220404085549374" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404085609535.png" alt="image-20220404085609535" style="zoom:67%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>递推方程</strong></p>
<p>设k为阶段变量，$0 \leq k \leq m$有问题分析可得递推方程和边界条件：</p>
<script type="math/tex; mode=display">
\begin{cases}
g_1(x) = f_1(x) \\
g_k(0) = 0 \qquad k = 1,2,...,m \\
g_k(x) = \max_{0 \leq x_j \leq x} \{ f_k(x) + g_{k-1}(x-x_i) \}
\qquad k = 2,3,...,m

\end{cases}</script></li>
<li><p><strong>存储</strong></p>
<blockquote>
<p><code>t[]</code>存储中间值</p>
<p><code>g[]</code>存储每一阶段运算过后的最优方案</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404085635693.png" alt="image-20220404085635693" style="zoom:67%;" /></p>
</li>
<li><p><strong>求解最优方案</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412154832228.png" alt="image-20220412154832228" style="zoom: 67%;" /></p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DynamicInvest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a[][]表示在某阶段获利最大的情况下分配给某个项目的资金</span></span><br><span class="line">    <span class="comment">// f[]存储某项目初始投资所获得的利润</span></span><br><span class="line">    <span class="comment">// t[]存储当前投资额的最大利润</span></span><br><span class="line">    <span class="comment">// g[]存储每一阶段的最优方案</span></span><br><span class="line">    <span class="comment">// gain[]存储整个投资的最优分配方案</span></span><br><span class="line">    <span class="type">int</span> a[MAXN][MAXN], g[MAXN], f[MAXN], t[MAXN];</span><br><span class="line">    <span class="type">int</span> i, j, rest, n, m, k, gain[MAXN];</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;  <span class="comment">// 项目数、总投资额</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input project#1 profit: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        cin &gt;&gt; f[j];    <span class="comment">// 第一组收益</span></span><br><span class="line">        g[j] = f[j];    <span class="comment">// 第一阶段</span></span><br><span class="line">        a[<span class="number">1</span>][j] = j;    <span class="comment">// 第一阶段最优配额</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">2</span>; k &lt;= m; k++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;input project#&quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot; profit: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 输入第二组收益</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            t[i] = g[i];</span><br><span class="line">            cin &gt;&gt; f[i];    <span class="comment">// 当前项目的收益</span></span><br><span class="line">            a[k][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp计算最优解</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 第i阶段，项目数为i的情况，考虑拆分获得最优</span></span><br><span class="line">            <span class="comment">// 最优解存入t[i]</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j] + g[i-j] &gt; t[i]) &#123; <span class="comment">// 计算当前最优值</span></span><br><span class="line">                    t[i] = f[j] + g[i-j];</span><br><span class="line">                    a[k][i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            g[i] = t[i];    <span class="comment">// 更新该阶段的最大利益</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算投资分配情况</span></span><br><span class="line">    rest = n;</span><br><span class="line">    <span class="keyword">for</span> (i = m; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        gain[i] = a[i][rest];</span><br><span class="line">        rest = rest - gain[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;project#&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; profit: &quot;</span> &lt;&lt; gain[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;maxium is :&quot;</span> &lt;&lt; g[n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DynamicInvest</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">0 11 13 15 21 24</span></span><br><span class="line"><span class="comment">0 12 16 21 23 25</span></span><br><span class="line"><span class="comment">0 8 12 20 24 26</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>运行截图</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220403104305078.png" alt="image-20220403104305078" style="zoom: 80%;" /></p>
</li>
</ul>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155016690.png" alt="image-20220412155016690" style="zoom:80%;" /></p>
</li>
</ul>
<h2 id="8-3-背包问题"><a href="#8-3-背包问题" class="headerlink" title="8.3 背包问题"></a>8.3 背包问题</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155032936.png" alt="image-20220412155032936" style="zoom:80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155059229.png" alt="image-20220412155059229" style="zoom:80%;" /></p>
<ul>
<li><p><strong>最优子结构的证明</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155613063.png" alt="image-20220412155613063" style="zoom:80%;" /></p>
</li>
<li><p><strong>求解的过程</strong></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155545995.png" alt="image-20220412155545995" style="zoom: 80%;" /></p>
</li>
<li><p><strong>计算模型</strong></p>
<ol>
<li><p><strong>递推方程</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155122579.png" alt="image-20220412155122579" style="zoom: 80%;" /></p>
</li>
<li><p><strong>存储</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155152510.png" alt="image-20220412155152510" style="zoom:80%;" /></p>
</li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404092934181.png" alt="image-20220404092934181" style="zoom: 67%;" /></p>
<blockquote>
<p>装不下则维持原判。在算法实现中的优化——jmax</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;n&#125; 物品数量</span></span><br><span class="line"><span class="comment"> * @param &#123;W&#125; 背包最大载重量</span></span><br><span class="line"><span class="comment"> * @param &#123;w&#125; 物品重量</span></span><br><span class="line"><span class="comment"> * @param &#123;v&#125; 物品价值</span></span><br><span class="line"><span class="comment"> * @param &#123;x&#125; 物品的选取状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KnapSack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> w[], <span class="type">int</span> v[], <span class="type">int</span> x[], <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="type">int</span> i, j, jmax = <span class="built_in">min</span>(w[<span class="number">1</span>]<span class="number">-1</span>, W);</span><br><span class="line">    <span class="comment">// 新增第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= jmax; j++) &#123;</span><br><span class="line">        f[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = w[<span class="number">1</span>]; j &lt;= W; j++) &#123;</span><br><span class="line">        f[<span class="number">1</span>][j] = v[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行dp</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        jmax = <span class="built_in">min</span>(w[i]<span class="number">-1</span>, W);    <span class="comment">// 配额小于物品i重量</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= jmax; j++) &#123;   <span class="comment">// 只能取上一次的最优</span></span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = w[i]; j &lt;= W; j++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断哪些物品被选中</span></span><br><span class="line">    j = W;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i][j] &gt; f[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">             x[i] = <span class="number">1</span>;</span><br><span class="line">             j = j - w[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;select item: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> f[n][W]; <span class="comment">// 返回最优值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> w[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">int</span> v[] = &#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">15</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">5</span>];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">KnapSack</span>(<span class="number">4</span>,w,v,x,<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行截图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220403110208212.png" alt="image-20220403110208212" style="zoom:80%;" /></p>
</li>
</ul>
</li>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404093812227.png" alt="image-20220404093812227" style="zoom:80%;" /></p>
</li>
</ul>
<h3 id="【思考题】动态规划求解完全背包问题"><a href="#【思考题】动态规划求解完全背包问题" class="headerlink" title="【思考题】动态规划求解完全背包问题"></a>【<strong>思考题</strong>】动态规划求解完全背包问题</h3><ul>
<li><strong>计算模型</strong></li>
</ul>
<p>递推方程与0-1背包类似，不同点在于状态转移方程中，由于每个阶段的物品可以装入多个，与当前阶段作比较。</p>
<p>W为背包最大承载量；$w_k$表示背包承重量划分为子集后，第k个限重等级</p>
<script type="math/tex; mode=display">
\begin{cases} 
f_0(w_k) = 0 \qquad 0 \leq w_l \leq W \\
f_i(0) = 0 \qquad 0 \leq i \leq n \\
f_i(w_k) = \max\{ f_{i-1}(w_k) , f_{i}(w_k - w_i) + v_i \} \qquad 0 \leq w_i \leq W \\
f_i(w_k) = f_{i-1} (w_k) \qquad 0 \leq w_k \leq w_i \\
\end{cases}</script><ul>
<li><strong>算法描述</strong>（实现）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;n&#125; 物品数量</span></span><br><span class="line"><span class="comment"> * @param &#123;W&#125; 背包最大载重量</span></span><br><span class="line"><span class="comment"> * @param &#123;w&#125; 物品重量</span></span><br><span class="line"><span class="comment"> * @param &#123;v&#125; 物品价值</span></span><br><span class="line"><span class="comment"> * @param &#123;x&#125; 物品的选取状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">KnapSack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> w[], <span class="type">int</span> v[], <span class="type">int</span> x[], <span class="type">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="type">int</span> i, j, jmax = <span class="built_in">min</span>(w[<span class="number">1</span>]<span class="number">-1</span>, W);</span><br><span class="line">    <span class="comment">// 新增第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= jmax; j++) &#123;</span><br><span class="line">        f[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = w[<span class="number">1</span>]; j &lt;= W; j++) &#123;</span><br><span class="line">        f[<span class="number">1</span>][j] = v[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行dp</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        jmax = <span class="built_in">min</span>(w[i]<span class="number">-1</span>, W);    <span class="comment">// 配额小于物品i重量</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= jmax; j++) &#123;   <span class="comment">// 只能取上一次的最优</span></span><br><span class="line">            f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = w[i]; j &lt;= W; j++) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j], f[i][j-w[i]] + v[i]);	<span class="comment">// 可以重复装入第i个物品</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断哪些物品被选中</span></span><br><span class="line">    j = W;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (f[i][j] == f[i][j-w[i]] + v[i]) &#123;</span><br><span class="line">            x[i]++;</span><br><span class="line">            j = j - w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;select item: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> f[n][W]; <span class="comment">// 返回最优值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int w[] = &#123;0,2,1,3,2&#125;;</span></span><br><span class="line">    <span class="comment">// int v[] = &#123;0,12,10,20,15&#125;;</span></span><br><span class="line">    <span class="comment">// int x[5];</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; KnapSack(4,w,v,x,5) &lt;&lt; endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> w[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> v[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">5</span>];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">KnapSack</span>(<span class="number">4</span>,w,v,x,<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>运行截图</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220409173221837.png" alt="image-20220409173221837"></p>
<ul>
<li><strong>算法分析</strong></li>
</ul>
<p>与0-1背包相比，只改动了状态转移方程的一个下标，不影响时间复杂度</p>
<script type="math/tex; mode=display">
\begin{eqnarray}
T(n) = W + (n-1)(W+1) + n \\
= n \times W + 2 \times n - 1 \\
= \Theta(n \times W)
\end{eqnarray}</script><h2 id="8-4-矩阵连乘问题"><a href="#8-4-矩阵连乘问题" class="headerlink" title="8.4 矩阵连乘问题"></a>8.4 矩阵连乘问题</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220404094126026.png" alt="image-20220404094126026" style="zoom:80%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155749207.png" alt="image-20220412155749207" style="zoom:80%;" /></p>
<ul>
<li><p><strong>阶段划分</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155820942.png" alt="image-20220412155820942" style="zoom:80%;" /></p>
</li>
<li><p><strong>阶段决策</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155843006.png" alt="image-20220412155843006" style="zoom: 80%;" /></p>
</li>
</ul>
</li>
<li><p><strong>数学模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155919139.png" alt="image-20220412155919139" style="zoom: 80%;" /></p>
</li>
<li><p><strong>算法设计与分析</strong></p>
<ol>
<li><p><strong>递归算法</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406083938982.png" alt="image-20220406083938982" style="zoom: 50%;" /></p>
</li>
<li><p><strong>改进递归算法</strong></p>
<p>使用二维数组<code>m[][]</code>存储中间计算次数的结果，若需要使用，直接访问。否则进行递归运算</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412155943921.png" alt="image-20220412155943921" style="zoom:80%;" /></p>
</li>
<li><p><strong>非递归算法</strong></p>
<blockquote>
<p>具有阶段性的特点</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412160017441.png" alt="image-20220412160017441" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412160030850.png" alt="image-20220412160030850" style="zoom:80%;" /></p>
</li>
</ol>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> p[MAXN];    <span class="comment">// 矩阵链的行列信息</span></span><br><span class="line"><span class="type">int</span> m[MAXN][MAXN];  <span class="comment">// 矩阵链的最优值</span></span><br><span class="line"><span class="type">int</span> com[MAXN][MAXN];  <span class="comment">// 矩阵链的分段位置</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MatrixChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t, k;</span><br><span class="line">    <span class="type">int</span> r;  <span class="comment">// 划分的阶段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        m[i][i] = <span class="number">0</span>;    <span class="comment">// 第1阶段一个矩阵</span></span><br><span class="line">        m[i][i+<span class="number">1</span>] = p[i]*p[i+<span class="number">1</span>]*p[i+<span class="number">2</span>];</span><br><span class="line">        com[i][i+<span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    m[n][n] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 矩阵个数从三个开始递增，即第三阶段</span></span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">2</span>; r &lt;= n<span class="number">-1</span>; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n-r+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            j = i + r;</span><br><span class="line">            <span class="comment">// 从i到j矩阵连乘的次数</span></span><br><span class="line">            m[i][j] = m[i][j] + m[i+<span class="number">1</span>][j] + p[i]*p[i+<span class="number">1</span>]*p[j+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 矩阵连乘的分段点的位置</span></span><br><span class="line">            com[i][j] = i;</span><br><span class="line">            <span class="comment">// 寻找矩阵最优分段位置，矩阵连乘次数的最小值，修改m数组和断开的位置com数组</span></span><br><span class="line">            <span class="keyword">for</span> (k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i]*p[k+<span class="number">1</span>]*p[j+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (t &lt; m[i][j]) &#123;  <span class="comment">// 发现更小的值，更新</span></span><br><span class="line">                    m[i][j] = t;</span><br><span class="line">                    com[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="built_in">sizeof</span>(m));</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(com, <span class="number">0</span>, <span class="built_in">sizeof</span>(com));</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MatrixChain</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d &quot;</span>,m[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, com[i][j]);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">30 35 15 5 10 20 30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>算法分析</strong></p>
<p>对于非递归算法，时间复杂度为$O(n^3)$，空间复杂度为$O(n^2)$</p>
</li>
</ul>
<h3 id="【思考题】从com-还原最优解"><a href="#【思考题】从com-还原最优解" class="headerlink" title="【思考题】从com[][]还原最优解"></a>【<strong>思考题</strong>】从<code>com[][]</code>还原最优解</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220409205218126.png" alt="image-20220409205218126" style="zoom:80%;" /></p>
<p>如图，<code>m[1][n]</code>为矩阵连乘的最优解。</p>
<p>一层一层的划分是从左上向右下的。</p>
<p>对于整个矩阵连乘式，<code>s[1][n]</code>指示最外层断点——3</p>
<p>下面来到第3层，即[1,3,3,5]这一斜行，指示了下一层的断点为1和5</p>
<p>最后得到结果：$((A_1(A_2A_3))((A_4A_5)(A_6))$</p>
<h3 id="【思考题】机器分配问题（类似投资分配问题）"><a href="#【思考题】机器分配问题（类似投资分配问题）" class="headerlink" title="【思考题】机器分配问题（类似投资分配问题）"></a>【<strong>思考题</strong>】机器分配问题（类似投资分配问题）</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406084753695.png" alt="image-20220406084753695" style="zoom: 67%;" /></p>
<ul>
<li><p><strong>问题分析</strong></p>
<p>本题解法与投资问题相同。$f_i(x_i)$表示将$x_i$个机器投入第$i$个工厂为国家产生的效益。</p>
<p><strong>目标方程</strong>：$\max \sum_{i=1}^m f_i(x_i)$</p>
<p><strong>约束条件</strong>：$\begin{cases} \sum_{i = 1}^m x_i = 5 \qquad x_i \leq 5 \\ x_i \geq 0 \qquad i = 1,2,3 \end{cases}$</p>
</li>
<li><p><strong>算法描述</strong>（实现）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="type">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="type">int</span> t[MAXN];</span><br><span class="line"><span class="type">int</span> g[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; m &gt;&gt; n;    <span class="comment">// 机器数和工厂数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        cin &gt;&gt; f[i];</span><br><span class="line">        g[i] = f[i];</span><br><span class="line">        a[<span class="number">1</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            t[i] = g[i];</span><br><span class="line">            cin &gt;&gt; f[i];</span><br><span class="line">            a[k][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[j] + g[i-j] &gt; t[i]) &#123;</span><br><span class="line">                    t[i] = f[j] + g[i-j];</span><br><span class="line">                    a[k][i] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            g[i] = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rest = m;</span><br><span class="line">    <span class="type">int</span> gain[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        gain[i] = a[i][rest];</span><br><span class="line">        rest = rest - gain[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;project#&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; profit: &quot;</span> &lt;&lt; gain[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;maxium is :&quot;</span> &lt;&lt; g[m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="built_in">sizeof</span>(t));</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 3</span></span><br><span class="line"><span class="comment">0 3 7 9 12 13</span></span><br><span class="line"><span class="comment">0 5 10 11 11 11</span></span><br><span class="line"><span class="comment">0 4 6 11 12 12</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><strong>运行截图</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220409211831725.png" alt="image-20220409211831725"  /></p>
<ul>
<li><p><strong>算法分析</strong></p>
<p>问题的输入规模为$m \times n$</p>
<p>分阶段求解，时间复杂度计算：</p>
<script type="math/tex; mode=display">
\begin{align}
T(n) = \sum_{k=2}^m(\sum_{i=0}^nC_1 + \sum_{i=0}^n\sum_{j=0}^iC_2 + \sum_{i=0}^nC_3) \\
=(m-1) \times (C_2 \times (n+2) \times (n+1) / 2 + (C_1 + C_3) \times (n+1)))\\
=O(m\times n^2)
\end{align}</script></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li><p>投资分配问题</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406084934574.png" alt="image-20220406084934574" style="zoom: 80%;" /></p>
</li>
<li><p>背包问题</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406084948556.png" alt="image-20220406084948556" style="zoom: 80%;" /></p>
</li>
<li><p>矩阵连乘</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406085155949.png" alt="image-20220406085155949" style="zoom: 80%;" /></p>
</li>
</ol>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析：第9章 随机算法</title>
    <url>/algorithm/algorithm-ch9/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>随机数</li>
<li>蒙特卡罗算法</li>
<li>舍伍德算法</li>
<li>拉斯维加斯算法</li>
</ul>
<h2 id="9-1-随机数（需要知道概念、定义）"><a href="#9-1-随机数（需要知道概念、定义）" class="headerlink" title="9.1 随机数（需要知道概念、定义）"></a>9.1 随机数（需要知道概念、定义）</h2><blockquote>
<p>目标：利用数据序列的随机性和概率分布等特点，设计解决问题的算法或提高已有算法的效率。</p>
</blockquote>
<ul>
<li><strong>随机性与随机序列</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411073810342.png" alt="image-20220411073810342" style="zoom: 80%;" /></p>
<ul>
<li><strong>随机数的数学方法要求与线性同余法</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411073834912.png" alt="image-20220411073834912" style="zoom:80%;" /></p>
<blockquote>
<p>对比：</p>
<p>第一组$\begin{cases} a_0 = 1 \\ a_n = (5a_{n-1}+1) \ mod \ 10 \quad n=1,2,…  \end{cases}$</p>
<p>第二组$\begin{cases} a_0=1 \\ a_n = (5a_{n-1}+1) \ mod \ 8 \quad n = 1,2,… \end{cases}$</p>
<p>第一组的序列为{1,6,1,6,1,6,1,6,…}；第二组的序列为{1,6,7,4,5,2,3,0,1,…}</p>
</blockquote>
<h3 id="【例9-1】用线性同余法生成一个随机序列"><a href="#【例9-1】用线性同余法生成一个随机序列" class="headerlink" title="【例9-1】用线性同余法生成一个随机序列"></a>【例9-1】用线性同余法生成一个随机序列</h3><ul>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411074328275.png" alt="image-20220411074328275" style="zoom:80%;" /></p>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411074407904.png" alt="image-20220411074407904" style="zoom:80%;" /></p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> b = <span class="number">1194211693L</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> c = <span class="number">12345L</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> rand_seed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mysrand</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seed)</span> </span>&#123;</span><br><span class="line">    rand_seed = seed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">myrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rand_seed = (rand_seed*b+c) % ((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> rand_seed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">myrandf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rand_seed = (<span class="type">double</span>)(rand_seed*b+c) / ((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> rand_seed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">mysrand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">myrand</span>()%<span class="number">100</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-2-蒙特卡罗算法"><a href="#9-2-蒙特卡罗算法" class="headerlink" title="9.2 蒙特卡罗算法"></a>9.2 蒙特卡罗算法</h2><blockquote>
<p>蒙特卡罗算法(Monte Carlo，MC)：它将所求解的问题同一定的概率模型相联系，用计算机实现统计模拟或抽样，以获得问题的解。</p>
</blockquote>
<h3 id="统计模拟"><a href="#统计模拟" class="headerlink" title="统计模拟"></a>统计模拟</h3><p><strong>偏真(true-biased)算法</strong>：当MC是求解判定问题的算法，算法MC返回true时解总是正确的，当它返回false不一定错误。反之称为偏假(flase-biased)算法。</p>
<ol>
<li><p><strong>数值计算</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509221832510.png" alt="image-20220509221832510" style="zoom: 33%;" /></p>
</li>
<li><p><strong>素数测试</strong></p>
<ul>
<li>算法1</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222025170.png" alt="image-20220509222025170" style="zoom:33%;" /></p>
<ul>
<li><p>算法2</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222103148.png" alt="image-20220509222103148" style="zoom:33%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222136613.png" alt="image-20220509222136613" style="zoom:33%;" /></p>
</li>
<li><p>算法3</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222219492.png" alt="image-20220509222219492" style="zoom:33%;" /></p>
<blockquote>
<p>这是一个偏假的算法</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222328268.png" alt="image-20220509222328268" style="zoom:33%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222350524.png" alt="image-20220509222350524" style="zoom:33%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222447186.png" alt="image-20220509222447186" style="zoom:33%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222536773.png" alt="image-20220509222536773" style="zoom: 45%;" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">unsigned</span> a, <span class="type">unsigned</span> m, <span class="type">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> y = <span class="number">1</span>, z = a;</span><br><span class="line">    <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = z;</span><br><span class="line">            z = z * z % n;</span><br><span class="line">            m = m / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((z == <span class="number">1</span>) &amp;&amp; (x != <span class="number">1</span>) &amp;&amp; (x != n<span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --m;</span><br><span class="line">        y = y * z % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prime</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">rand</span>() % n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">power</span>(a,n<span class="number">-1</span>,n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;是否为质数：&quot;</span> &lt;&lt; <span class="built_in">prime</span>(i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="9-3-舍伍德算法"><a href="#9-3-舍伍德算法" class="headerlink" title="9.3 舍伍德算法"></a>9.3 舍伍德算法</h2><p>通过随机阻断最坏情况</p>
<ol>
<li><p><strong>Sherwood基本思想</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222731465.png" alt="image-20220509222731465" style="zoom: 33%;" /></p>
</li>
<li><p><strong>【例9-5】求第k小的元素</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222801462.png" alt="image-20220509222801462" style="zoom:33%;" /></p>
<ul>
<li><p><strong>计算模型</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222829467.png" alt="image-20220509222829467" style="zoom:33%;" /></p>
</li>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222911597.png" alt="image-20220509222911597" style="zoom:43%;" /></p>
</li>
<li><p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, pivot, t;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> a[left];</span><br><span class="line">    i = left;</span><br><span class="line">    <span class="comment">// 舍伍德随机数</span></span><br><span class="line">    j = left + <span class="built_in">rand</span>() % (right-left);</span><br><span class="line">    <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    pivot = a[left];</span><br><span class="line">    j = right+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; pivot);</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j - left == k<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = a[j];</span><br><span class="line">    a[j] = pivot;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j - left &lt; k<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">select</span>(a,j+<span class="number">1</span>,right,k<span class="number">-1</span>-(j-left));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">select</span>(a,left,j<span class="number">-1</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>算法分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509222939606.png" alt="image-20220509222939606" style="zoom: 50%;" /></p>
</li>
</ul>
<h2 id="9-4-拉斯维加斯算法"><a href="#9-4-拉斯维加斯算法" class="headerlink" title="9.4 拉斯维加斯算法"></a>9.4 拉斯维加斯算法</h2><blockquote>
<p>随机生成答案并检测——拉斯维加斯算法</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509223104313.png" alt="image-20220509223104313" style="zoom:33%;" /></p>
<p>【例9-6】n皇后问题</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509223141254.png" alt="image-20220509223141254" style="zoom:33%;" /></p>
<ul>
<li><p><strong>算法设计与描述</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220509223222208.png" alt="image-20220509223222208" style="zoom: 33%;" /></p>
</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>算法设计与分析</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理：第1章 计算机系统概论</title>
    <url>/computer_organization/computer-organization-ch1/</url>
    <content><![CDATA[<h1 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h1><h2 id="一、计算机的软硬件概念"><a href="#一、计算机的软硬件概念" class="headerlink" title="一、计算机的软硬件概念"></a>一、计算机的软硬件概念</h2><h3 id="1-计算机系统"><a href="#1-计算机系统" class="headerlink" title="1.计算机系统"></a>1.计算机系统</h3><script type="math/tex; mode=display">
计算机系统
\begin{cases}
\color{red}{硬件} \quad \color{black}{计算机的实体（主机、外设等）}\\
\color{red}{软件} \quad \color{black}{由具有各类特殊功能的信息（程序）组成}\\
\end{cases}</script><script type="math/tex; mode=display">
软件
\begin{cases}
\color{red}{系统软件} \quad \color{black}{用来管理整个计算机系统}\\
\qquad \qquad \qquad 语言处理程序\\
\qquad \qquad \qquad 操作系统\\
\qquad \qquad \qquad 服务性程序\\
\qquad \qquad \qquad 数据库管理系统\\
\qquad \qquad \qquad 网络软件\\
\color{red}{应用软件} \quad \color{black}{按任务需要编制成的各种程序}\\
\end{cases}</script><span id="more"></span>
<h3 id="2-计算机的解题过程"><a href="#2-计算机的解题过程" class="headerlink" title="2.计算机的解题过程"></a>2.计算机的解题过程</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221202042609.png" alt="image-20220221202042609" style="zoom: 67%;" /></p>
<h2 id="二、计算机系统的层次结构"><a href="#二、计算机系统的层次结构" class="headerlink" title="二、计算机系统的层次结构"></a>二、计算机系统的层次结构</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221202241077.png" alt="image-20220221202241077" style="zoom:67%;" /></p>
<p>实际机器$M_1$和微程序机器$M_0$构成硬件。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221202406326.png" alt="image-20220221202406326" style="zoom:67%;" /></p>
<h2 id="三、计算机体系结构和计算机组成"><a href="#三、计算机体系结构和计算机组成" class="headerlink" title="三、计算机体系结构和计算机组成"></a>三、计算机体系结构和计算机组成</h2><p>相关资料：<a href="https://blog.csdn.net/xifengw/article/details/99717216">微机原理、计算机组成原理与计算机体系结构之间的关系</a></p>
<ul>
<li><p>体系结构关注：计算机有哪些功能？</p>
</li>
<li><p>组成原理关注：计算机的功能如何实现？</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221202446815.png" alt="image-20220221202446815" style="zoom:67%;" /></p>
<h1 id="1-2-计算机系统组成"><a href="#1-2-计算机系统组成" class="headerlink" title="1.2 计算机系统组成"></a>1.2 计算机系统组成</h1><h2 id="一、冯·诺依曼计算机的特点"><a href="#一、冯·诺依曼计算机的特点" class="headerlink" title="一、冯·诺依曼计算机的特点"></a>一、冯·诺依曼计算机的特点</h2><ol>
<li>计算机由五大部件组成：<strong>存储器、运算器、控制器、输入设备、输出设备</strong></li>
<li>指令和数据以同等地位存于<code>存储器</code>，可按地址寻访</li>
<li>指令和数据用二进制表示</li>
<li>指令由<code>操作码</code>和<code>地址码</code>组成——具体内容详见ch7</li>
<li>存储程序：指令在存储器内按顺序存放。指令通常<strong>按顺序执行</strong>，在特定条件下可根据运算结果或设定的条件改变执行顺序</li>
<li>以<code>运算器</code>为中心：I/O设备与存储器间的数据传送通过运算器完成</li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221203119436.png" alt="image-20220221203119436" style="zoom:67%;" /></p>
<p>注：</p>
<ol>
<li>运算器：<strong>算术运算和逻辑运算</strong>。将中间结果暂存在运算器内</li>
<li>存储器：存放数据和程序</li>
<li>控制器：控制、<strong>指挥</strong>程序和数据的输入、运行以及处理运算结果</li>
<li>输入设备（键鼠）：转化为机器能够识别的信息形式</li>
<li>输出设备（打印机输出、显示器输出）：将运算结果转化为人们熟悉的信息形式</li>
</ol>
<h2 id="二、计算机硬件框图"><a href="#二、计算机硬件框图" class="headerlink" title="二、计算机硬件框图"></a>二、计算机硬件框图</h2><h3 id="1-以存储器为中心的计算机硬件框图"><a href="#1-以存储器为中心的计算机硬件框图" class="headerlink" title="1.以存储器为中心的计算机硬件框图"></a>1.以存储器为中心的计算机硬件框图</h3><script type="math/tex; mode=display">
\rightarrow \quad 控制线 \\
\dashrightarrow \quad 反馈线 \\
\Rightarrow \quad 数据线 \\</script><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221203951631.png" alt="image-20220221203951631" style="zoom:67%;" /></p>
<h3 id="2-现代计算机硬件框图"><a href="#2-现代计算机硬件框图" class="headerlink" title="2.现代计算机硬件框图"></a>2.现代计算机硬件框图</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221204027723.png" alt="image-20220221204027723" style="zoom:67%;" /></p>
<ul>
<li>CPU（中央处理器）：Central Processing Unit。计算机核心部件，由<strong>运算器</strong>和<strong>控制器</strong>组成</li>
<li>ALU（算逻部件/算术逻辑单元）：Arithmetic &amp; Logical Unit。运算器核心部件，<strong>进行逻辑运算和算术运算</strong></li>
<li>CU（控制单元）：Control Unit。控制器核心部件，产生微操作命令序列。<strong>用来解释存储器中的指令，发出各种操作命令来执行指令</strong></li>
<li>I/O设备：Input/Output Equipment。</li>
</ul>
<h2 id="三、计算机的工作步骤"><a href="#三、计算机的工作步骤" class="headerlink" title="三、计算机的工作步骤"></a>三、计算机的工作步骤</h2><h3 id="1-上机前的准备"><a href="#1-上机前的准备" class="headerlink" title="1.上机前的准备"></a>1.上机前的准备</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221205318632.png" alt="image-20220221205318632" style="zoom:67%;" /></p>
<h4 id="编程举例"><a href="#编程举例" class="headerlink" title="编程举例"></a>编程举例</h4><ul>
<li>运算：取被操作数、运算操作、暂存中间结果</li>
<li>存储器：存储运算结果</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221205352807.png" alt="image-20220221205352807" style="zoom:67%;" /></p>
<h4 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h4><p>详见ch7。寻址、特征位、不同格式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221205704580.png" alt="img" style="zoom:67%;" /></p>
<p>注：打印机的打印操作需要多条指令</p>
<p>参考资料：<a href="https://blog.csdn.net/weixin_34112181/article/details/89566814">打印机主流的指令类型（ESC命令集+CPCL命令集+TSPL命令集）</a></p>
<h4 id="计算-ax-2-bx-c-程序清单"><a href="#计算-ax-2-bx-c-程序清单" class="headerlink" title="计算$ax^2+bx+c$程序清单"></a>计算$ax^2+bx+c$程序清单</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221210015842.png" alt="image-20220221210015842" style="zoom:67%;" /></p>
<h3 id="2-计算机的解题过程-1"><a href="#2-计算机的解题过程-1" class="headerlink" title="2.计算机的解题过程"></a>2.计算机的解题过程</h3><h4 id="（1）存储器的基本组成"><a href="#（1）存储器的基本组成" class="headerlink" title="（1）存储器的基本组成"></a>（1）存储器的基本组成</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221210124089.png" alt="image-20220221210124089" style="zoom:67%;" /></p>
<ul>
<li>MAR（存储器地址寄存器）：Memory Address Register</li>
<li>MDR（主存数据寄存器）：Memory Data Register </li>
<li>数据总线、读写控制</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221210629442.png" alt="image-20220221210629442" style="zoom:67%;" /></p>
<script type="math/tex; mode=display">
计算过程： \\
由MAR = 4位，存储单元的个数 = 2^4 = 16 \\
由MDR = 8位，存储字长 = 8 \\</script><h4 id="（2）运算器的基本组成及操作过程"><a href="#（2）运算器的基本组成及操作过程" class="headerlink" title="（2）运算器的基本组成及操作过程"></a>（2）运算器的基本组成及操作过程</h4><p>规定动作的处理</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221210828885.png" alt="image-20220221210828885" style="zoom:67%;" /></p>
<ul>
<li><p>ACC（累加器）：Accumulator。一种<strong>寄存器</strong>，能<strong>存放运算前被操作数</strong>，也能<strong>储存计算产生的中间结果</strong>。</p>
<blockquote>
<p>如果没有像累加器这样的寄存器，那么在每次计算 (加法，乘法，移位等等) 后就必须要把结果写回到<a href="https://baike.baidu.com/item/内存">内存</a>，也许马上就得读回来。然而存取主存的速度是比从<a href="https://baike.baidu.com/item/算术逻辑单元">算术逻辑单元</a>(ALU)到有直接路径的累加器存取更慢。</p>
</blockquote>
</li>
<li><p>MQ（乘商寄存器）：Multiple-Quotient Register。负责数据的乘法与除法运算并可<strong>保存运算结果</strong>，是运算器的基本组成部分。<strong>也可保存运算结果的低位</strong></p>
</li>
</ul>
<p>注：上图缺少了F寄存器（状态/标志寄存器）</p>
<ul>
<li><p>FR（标志寄存器）：Flags Register</p>
<p>具有<strong>条件标志：进位、奇偶、辅助进位、零、符号、溢出标志</strong>，<strong>控制标记：跟踪、中断、方向标记</strong></p>
</li>
</ul>
<p>参考资料：</p>
<p><a href="https://zhuanlan.zhihu.com/p/256470714">标志寄存器</a></p>
<p><a href="https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/5757541#:~:text=%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%88%E7%A7%B0%20%E7%A8%8B%E5%BA%8F%E7%8A%B6%E6%80%81%E5%AD%97%20%EF%BC%88%E5%A4%96%E8%AF%AD%E7%BC%A9%E5%86%99%EF%BC%9APSW%E3%80%81%E5%A4%96%E8%AF%AD%E5%85%A8%E7%A7%B0%EF%BC%9AProgram,Status%20Word%EF%BC%89%E3%80%82%20%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA16%E4%BD%8D%E7%9A%84%E5%AD%98%E6%94%BE%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97%E3%80%81%E6%8E%A7%E5%88%B6%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E5%8F%8D%E6%98%A0%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8CALU%E8%BF%90%E7%AE%97%E7%BB%93%E6%9E%9C%E7%9A%84%E6%9F%90%E4%BA%9B%E7%89%B9%E5%BE%81%E5%8F%8A%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E3%80%82">标志寄存器-百度百科</a></p>
<h5 id="①加法操作过程"><a href="#①加法操作过程" class="headerlink" title="①加法操作过程"></a>①加法操作过程</h5><p>[ACC]看作被加数。</p>
<p>从主存中取M地址号单元内的加数[M]，送至X寄存器中。</p>
<p>将被加数[ACC]与加数[X]相加，结果（和）保留在ACC中。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221211851184.png" alt="image-20220221211851184" style="zoom:67%;" /></p>
<h5 id="②减法操作过程"><a href="#②减法操作过程" class="headerlink" title="②减法操作过程"></a>②减法操作过程</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221211932915.png" alt="image-20220221211932915" style="zoom:67%;" /></p>
<h5 id="③乘法操作过程"><a href="#③乘法操作过程" class="headerlink" title="③乘法操作过程"></a>③乘法操作过程</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221212003668.png" alt="image-20220221212003668" style="zoom:67%;" /></p>
<h5 id="④除法操作过程"><a href="#④除法操作过程" class="headerlink" title="④除法操作过程"></a>④除法操作过程</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221212038827.png" alt="image-20220221212038827" style="zoom:67%;" /></p>
<h4 id="（3）控制器的基本组成"><a href="#（3）控制器的基本组成" class="headerlink" title="（3）控制器的基本组成"></a>（3）控制器的基本组成</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221212108592.png" alt="image-20220221212108592" style="zoom:67%;" /></p>
<ul>
<li>PC（程序计数器）：Program Counter。存放<strong>欲执行的指令的地址</strong>，并可自动<strong>生成下一条指令地址</strong></li>
<li>IR（指令寄存器）：Instruction Register。存放当前<strong>正在执行的指令</strong></li>
<li>CU（控制单元）：Control Unit。控制器核心部件，产生微操作命令序列。<strong>用来解释存储器中的指令，发出各种操作命令来执行指令</strong></li>
</ul>
<h4 id="（4）主机完成一条指令的过程"><a href="#（4）主机完成一条指令的过程" class="headerlink" title="（4）主机完成一条指令的过程"></a>（4）主机完成一条指令的过程</h4><h5 id="以取数指令为例"><a href="#以取数指令为例" class="headerlink" title="以取数指令为例"></a>以取数指令为例</h5><ol>
<li>程序计数器获得指令地址的初始值，</li>
<li>MAR从存储体中获得指令地址对应的指令，通过地址总线送到MAR</li>
<li>进入读取周期，把指令送至MDR</li>
<li>通过数据总线送达指令至IR</li>
<li>开始执行周期：进入CU，分析指令</li>
<li>开始执行指令，指令寄存器进入MAR，给出数据地址</li>
<li>通过MAR读取数据地址</li>
<li>读周期，读取数据</li>
<li>送达CPU的ACC中，修改PC</li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223212632134.png" alt="img" style="zoom: 50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221212204068.png" alt="image-20220221212204068" style="zoom:67%;" /></p>
<h5 id="以存数指令为例"><a href="#以存数指令为例" class="headerlink" title="以存数指令为例"></a>以存数指令为例</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220221212232671.png" alt="image-20220221212232671" style="zoom:67%;" /></p>
<p>ch4详细讨论</p>
<p>一个CPU（运算器+控制器） + 存储器 + I/O系统 + 总线</p>
<p>完成指令</p>
<h4 id="（5）程序的运行过程"><a href="#（5）程序的运行过程" class="headerlink" title="（5）程序的运行过程"></a>（5）程序的运行过程</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223162855834.png" alt="image-20220223162855834" style="zoom:67%;" /></p>
<ul>
<li>PC地址加法器</li>
</ul>
<h1 id="1-3-计算机硬件的主要技术指标"><a href="#1-3-计算机硬件的主要技术指标" class="headerlink" title="1.3 计算机硬件的主要技术指标"></a>1.3 计算机硬件的主要技术指标</h1><h3 id="1-机器字长"><a href="#1-机器字长" class="headerlink" title="1.机器字长"></a>1.机器字长</h3><p>机器字长：CPU <strong>一次</strong>能处理数据的<strong>位数</strong>。与CPU中的<strong>寄存器位数</strong>有关</p>
<ul>
<li><p>影响精度</p>
<blockquote>
<p>字长越长，数的表示范围越大，精度越高</p>
</blockquote>
</li>
<li><p>影响运算速度</p>
<blockquote>
<p>若：CPU字长较短，又要运算位数较多的数据，需要经过多次运算才能完成，影响机器的运算速度</p>
</blockquote>
</li>
<li><p>影响硬件的造价</p>
<blockquote>
<p>直接影响加法器（或ALU）、数据总线以及存储字长的位数</p>
</blockquote>
</li>
</ul>
<h3 id="2-运算速度"><a href="#2-运算速度" class="headerlink" title="2.运算速度"></a>2.运算速度</h3><ul>
<li><p>主频：计算机工作统一步调，时钟周期的倒数</p>
<p>晶振产生波形，与工作频率相同</p>
</li>
<li><p>（测试的方法）吉布森法</p>
</li>
<li><p>MIPS（每秒钟执行百万条指令）：Million Instructions Per Second</p>
</li>
</ul>
<ul>
<li><p>CPI （执行一条指令所需时钟周期数）：Clock Cycle Per Instruction</p>
<p>一条指令对应波形的节拍数</p>
</li>
<li><p>FLOPS（每秒浮点运算次数）：Floating-point Operations Per Second</p>
<p>浮点数的加法和乘法速度不同</p>
</li>
</ul>
<h3 id="3-存储容量"><a href="#3-存储容量" class="headerlink" title="3.存储容量"></a>3.存储容量</h3><p>存放二进制信息的总位数</p>
<p><strong>主存容量</strong>：主存中存放二进制代码的总位数。、</p>
<p><strong>MAR的位数反映存储单元的个数（$2^N$​​），MDR的位数反映存储字长（$M$​）</strong></p>
<ol>
<li><p>存储单元个数$\times$​存储字长</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223163918172.png" alt="image-20220223163918172"></p>
</li>
<li><p>字节数——1个字节被定义为8位二进制代码</p>
</li>
</ol>
<p><strong>辅存容量</strong>——字节数</p>
<p>80GB，1GB = $2^{30}$B</p>
<h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><p>1、冯·诺伊曼计算机的特点（5条）</p>
<p>2、计算机如何区分存储器内的指令和数据</p>
<ul>
<li><p>通过<strong>不同的时间段</strong>来区分指令和数据</p>
<p><u>取指令阶段</u>——指令；</p>
<p><u>执行指令阶段</u>——数据。</p>
</li>
<li><p>通过<strong>地址来源</strong>区分</p>
<p><u>PC（程序计数器）</u>提供的存储地址取出——指令；</p>
<p><u>指令地址码</u>提供的存储地址取出——数据。</p>
</li>
</ul>
<p>3、计算机硬件组成框图，各部件作用，计算机硬件主要及技术指标</p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>computer organization</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理：第3章 系统总线</title>
    <url>/computer_organization/computer-organization-ch3/</url>
    <content><![CDATA[<h1 id="关于本课程"><a href="#关于本课程" class="headerlink" title="关于本课程"></a>关于本课程</h1><p>计算机源头：主频——晶振（1个）</p>
<p>计组的难点和重点：<strong>运算器、存储器、控制器、中断方式</strong></p>
<p>计算机系统</p>
<ul>
<li>逻辑正确</li>
<li>时序正确：内存（读、写）、输入输出、中断工作（中断周期）、存储器直接存取周期（DMA周期）</li>
<li>负载能力</li>
<li>可靠性：抗干扰、工作环境</li>
</ul>
<p>本课程重点是<strong>逻辑和时序，考虑一些负载能力</strong></p>
<span id="more"></span>
<h1 id="3-1-总线的基本概念"><a href="#3-1-总线的基本概念" class="headerlink" title="3.1 总线的基本概念"></a>3.1 总线的基本概念</h1><h2 id="一、为什么要用总线"><a href="#一、为什么要用总线" class="headerlink" title="一、为什么要用总线"></a>一、为什么要用总线</h2><p>冯诺依曼计算机结构：运算、控制、存储、输入、输出</p>
<p>至少包括三大部分，现代计算机更加复杂。需要把各个部件连接起来才能组成系统，协同工作。</p>
<p>计算机如何连接：</p>
<ul>
<li><p>①分散连接（早期）</p>
<blockquote>
<p>以运算器为中心，内部连线复杂，I/O设备与存储器交换信息都需经过运算器，致使运算器停运，影响CPU工作效率。</p>
<p>改进为以存储器为中心，I/O设备与存储器交换信息可以经过运算器，引入中断、DMA等技术，CPU效率提升，仍无法解决I/O设备和主机连接之间的灵活性。</p>
</blockquote>
<p><strong>如果设备很多，两两连接的制作成本高、难度大。而且设备之间的接口占用大量空间。</strong></p>
</li>
<li><p>②为了解决分散连接的问题，引入总线</p>
<p><strong>将各部件连到一组公共信息传输线上，称为总线连接</strong></p>
</li>
</ul>
<h2 id="二、什么是总线"><a href="#二、什么是总线" class="headerlink" title="二、什么是总线"></a>二、什么是总线</h2><blockquote>
<p>总线是连接各个部件的信息传输线，是<strong>各个部件共享的传输介质</strong></p>
</blockquote>
<ul>
<li>结构简单，可控性好</li>
</ul>
<h2 id="三、总线上信息的传送"><a href="#三、总线上信息的传送" class="headerlink" title="三、总线上信息的传送"></a>三、总线上信息的传送</h2><ul>
<li>串行：传输距离长（设备之间），一次只能传输一个信号，速度慢</li>
<li>并行：传输距离短（集中于机箱内部），一次传输多个信号，速度快</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/lKQvA54JcfjV6Er.png" alt="image-20220112101628214" style="zoom:50%;" /></p>
<h2 id="四、总线结构的计算机"><a href="#四、总线结构的计算机" class="headerlink" title="四、总线结构的计算机"></a>四、总线结构的计算机</h2><ul>
<li>在某一时刻，<strong>只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息</strong></li>
<li>总线<strong>由许多传输线或通路组成</strong>，每条线可一位一位传输二进制代码。</li>
</ul>
<h3 id="1-面向-CPU-的双总线结构框图"><a href="#1-面向-CPU-的双总线结构框图" class="headerlink" title="1. 面向 CPU 的双总线结构框图"></a>1. 面向 CPU 的双总线结构框图</h3><blockquote>
<p>面向CPU的双总线结构：<strong>以CPU为核心，延展出两条总线：一条M总线连接主存；I/O总线连接I/O设备。</strong></p>
<p>CPU与主存之间的信息传输比较繁忙，使用M总线提供信息传输服务。</p>
<p>I/O设备与主存之间没有直接的信息通路，只能以CPU作为媒介。一旦外部设备与主存进行信息传输，CPU的运算任务重，还是有可能被打断。</p>
</blockquote>
<p>I/O接口把不同的设备进行转换（220V与5V）</p>
<p>好处：</p>
<ul>
<li><p>把慢速的设备通过设备总线送过来</p>
</li>
<li><p>CPU和主存通过M总线高速传输指令</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/n97htaETFsq8ijy.png" alt="image-20220112102902317" style="zoom: 67%;" /></p>
<h3 id="2-单总线结构框图"><a href="#2-单总线结构框图" class="headerlink" title="2. 单总线结构框图"></a>2. 单总线结构框图</h3><p>如何分配总线，避免冲突？——总线使用规则，硬件设计应考虑</p>
<p>使用<strong>三态门</strong>：数据双向，地址单向</p>
<ul>
<li>主设备（总线）发出者（控制者），同一时刻只能有一个</li>
<li>从设备（信息来源）接收者，可以有多个</li>
</ul>
<p>没有芯片的快和慢的区分，<strong>总线的效率很低</strong></p>
<blockquote>
<p>单总线结构：所有设备连接到一条系统总线上</p>
<p>任何时候只能由一个设备使用总线。</p>
<p>如果某一个 I/O 设备与主存通过 I/O 接口进行数据传输，占用 CPU。则主存和 CPU 之间无法进行数据传输。会严重影响 CPU 设备的运行效率。并且如果设备较多，总线较长，向远端设备读或写的延迟大。会发生总线的征用。</p>
<p><strong>解决思路</strong>:引入多条总线，让数据并行传输</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/eLNS8o2EnHXCyfd.png" alt="image-20220112102154648" style="zoom: 67%;" /></p>
<h3 id="3-以存储器为中心的双总线结构框图"><a href="#3-以存储器为中心的双总线结构框图" class="headerlink" title="3. 以存储器为中心的双总线结构框图"></a>3. 以存储器为中心的双总线结构框图</h3><p>将1和2结合起来</p>
<blockquote>
<p>在单总线基础上又开辟出的一条CPU与主存之间的总线，称为<strong>存储总线</strong></p>
<p>把CPU、主存、外部设备都挂在系统总线上；<strong>CPU和主存之间存储总线进行数据传输</strong></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/FZu58AsqfDSoT6y.png" alt="image-20220112103055281" style="zoom: 67%;" /></p>
<h1 id="3-2-总线的分类（重点内容）"><a href="#3-2-总线的分类（重点内容）" class="headerlink" title="3.2 总线的分类（重点内容）"></a>3.2 总线的分类（重点内容）</h1><p>（重点内容）</p>
<ul>
<li><p>总线按<strong>数据传送方式</strong>可以分为：并行传输总线 和 串行传输总线。</p>
<p>并行传输总线中，又可按传输数据宽度分为：8位、16位、32位、64位等传输总线。</p>
</li>
<li><p>按<strong>总线的使用范围</strong>划分，又有计算机（包括外设）总线、测控总线、网络通信总线等</p>
</li>
<li><p>按<strong>连接部件</strong>不同，分为：片内总线、系统总线和通信总线</p>
<p>系统总线按<strong>传输信息</strong>不同，分为：数据总线、地址总线、控制总线</p>
</li>
</ul>
<h2 id="1-片内总线"><a href="#1-片内总线" class="headerlink" title="1.片内总线"></a>1.片内总线</h2><p><strong>芯片内部</strong>的总线</p>
<blockquote>
<p>CPU内的运算器和控制器之间的连线</p>
<p>寄存器之间</p>
<p>寄存器与算逻单元ALU之间</p>
</blockquote>
<h2 id="2-系统总线"><a href="#2-系统总线" class="headerlink" title="2.系统总线"></a>2.系统总线</h2><p><strong>计算机各部件之间</strong>（CPU、主存、I/O设备（通过I/O接口））的信息传输线</p>
<ul>
<li><p><u>数据总线：传输各部件之间的数据信息</u></p>
<p><strong>双向</strong>，与<strong>机器字长、存储字长</strong>有关</p>
<p>n位计算机：$D_{n-1}…D_2D_1D_0$​（一般为8、16、32位）</p>
<p><strong>数据总线的位数称为数据总线宽度</strong>，衡量系统性能的一个重要参数</p>
<blockquote>
<p>如果数据总线的宽度为8位，指令字长为16位，那么CPU在<strong>取指阶段</strong>必须<strong>两次访问主存</strong></p>
</blockquote>
</li>
<li><p><u>地址总线：指出<strong>数据总线上的源数据或目的数据</strong>在主存储单元的地址或I/O设备的地址</u></p>
<p>由CPU输出，<strong>单向</strong>，与<strong>存储单元的个数</strong>（存储地址、 I/O地址）有关。决定内存单元的个数，I/O地址个数</p>
<p>指示地址，字节的整数倍</p>
<p>$A_{m}…A_2A_1A_0$​</p>
<p><strong>地址线的位数与存储单元的个数有关</strong></p>
<blockquote>
<p>地址线为20根，则对应的存储单元的个数为$2^{20}$</p>
</blockquote>
</li>
<li><p><u>控制总线：用来发出各种控制信号的传输线</u></p>
<ul>
<li><p>对于CPU而言，<strong>有出 有入</strong></p>
<p>单CPU：CPU+DMA具有控制权。DMA需要申请、归还</p>
</li>
<li><p>发出控制信号</p>
<p>（存储器的读和写（互斥）、总线允许、中断确认）</p>
<blockquote>
<p>常见的控制信号：</p>
<p><strong>时钟、复位、总线请求、总线允许、中断请求、中断响应、存储器写、存储器读、I/O读、I/O写、传输响应</strong></p>
</blockquote>
<p>MEMR：存储器读——将指定<strong>存储单元</strong>的数据读取到<strong>数据总线</strong>上</p>
<p>MEMW：存储器写——将<strong>数据总线上的数据</strong>写入到<strong>存储器的指定地址单元</strong>内</p>
<p>IOR：（读）输入——从指定的<strong>I/O端口</strong>将数据读到<strong>数据总线</strong>上</p>
<p>IOW：（写）输出——将<strong>数据总线</strong>上的数据输出到指定的<strong>I/O端口</strong>内</p>
</li>
<li><p>多数为低电平有效</p>
</li>
<li><p>对于任一控制线而言，传输为<strong>单向</strong>。对于控制总线整体可认为是双向的</p>
</li>
<li><p>起到监视各部件状态的作用</p>
<blockquote>
<p>查询设备“忙”or“闲”，是否出错</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="3-通信总线"><a href="#3-通信总线" class="headerlink" title="3.通信总线"></a>3.通信总线</h2><p>（了解即可）</p>
<p>用于 <strong>计算机系统之间</strong> 或 <strong>计算机系统与其他系统（如控制仪表、移动通信等）之间</strong>的通信</p>
<p>传输方式：串行、并行</p>
<h1 id="3-3-总线特性及性能指标"><a href="#3-3-总线特性及性能指标" class="headerlink" title="3.3 总线特性及性能指标"></a>3.3 总线特性及性能指标</h1><h2 id="一、总线物理实现"><a href="#一、总线物理实现" class="headerlink" title="一、总线物理实现"></a>一、总线物理实现</h2><p>从物理角度，总线由许多导线直接印制在电路板上，延伸到各个部件。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220223171231125.png" alt="image-20220223171231125" style="zoom:67%;" /></p>
<h2 id="二、总线特性"><a href="#二、总线特性" class="headerlink" title="二、总线特性"></a>二、总线特性</h2><ol>
<li><p><strong>机械特性</strong>：<strong>尺寸</strong>、形状、<strong>管脚数</strong>及<strong>排列顺序</strong></p>
</li>
<li><p><strong>电气特性</strong>：<strong>传输方向</strong>和有效的<strong>电平</strong>范围</p>
<p>规定由CPU发出的信号称为输出信号，送入CPU为输入信号</p>
<blockquote>
<p>地址总线单向输出线、数据总线双向传输线——高1低0</p>
<p>控制总线单向。整体上有入、有出</p>
</blockquote>
</li>
<li><p><strong>功能特性</strong>：每根传输线的<strong>功能</strong></p>
<ul>
<li><p>地址总线：地址码</p>
</li>
<li><p>数据总线：传递数据</p>
</li>
<li><p>控制总线：发出控制信号</p>
</li>
</ul>
<blockquote>
<p>CPU发出——存储器读/写、I/O设备读/写</p>
<p>I/O向CPU发来——中断请求、DMA请求</p>
</blockquote>
</li>
<li><p><strong>时间特性</strong>：信号的<strong>时序</strong>关系</p>
<p>总线中的任一根线在什么时间内有效</p>
</li>
</ol>
<h2 id="三、总线的性能指标"><a href="#三、总线的性能指标" class="headerlink" title="三、总线的性能指标"></a>三、总线的性能指标</h2><p>1.<strong>总线宽度</strong></p>
<p><strong>数据总线</strong>的根数（16根、32根、64根，与传输位数有关）</p>
<p>用<strong>bit（位）</strong>表示</p>
<p>2.<strong>标准传输率</strong></p>
<p>单位时间内总线传送数据的字节数。每秒传输的最大字节数（<strong>MBps</strong>每秒传输的兆字节）</p>
<p>总线<strong>带宽</strong>，单位时间内总线上传输数据的<strong>位数</strong></p>
<p><u>与总线的宽度（数据线的根数）和时钟频率有关</u></p>
<blockquote>
<p>例如，总线上工作频率位33MHz，总线宽度为32位（4B），则总线带宽为$33 \times (32 \div 8) = 132$MBps</p>
</blockquote>
<p>3.<strong>时钟同步/异步</strong></p>
<p>总线上数据与时钟<strong>同步</strong>/<strong>不同步</strong>工作</p>
<p>4.<strong>总线复用</strong></p>
<p><u>一条信号线上<strong>分时</strong>传送两种信号</u></p>
<blockquote>
<p>将地址总线和数据总线共用一组物理线路，分时传输地址信号和数据信号，即为总线的多路复用</p>
</blockquote>
<p><strong>地址线</strong>与<strong>数据线</strong>复用（8086，为了减少芯片的管脚数，减少封装体积）</p>
<p>5.<strong>信号线数</strong></p>
<p>地址线、数据线和控制线的<strong>总和</strong></p>
<p>6.<strong>总线控制方式</strong></p>
<p>总线使用权的分配</p>
<p>突发工作、自动配置、仲裁方式、逻辑方式、计数方式</p>
<p>7.<strong>其他指标</strong></p>
<p><strong>负载能力</strong>、电源电压（5V or 3.3V）、总线的宽度能否扩展</p>
<p>负载能力即驱动能力：总线<strong>接上负载</strong>后，总线<strong>输入输出的逻辑电平</strong>能否<strong>保持在正常的额定范围</strong>内。</p>
<h2 id="四、总线标准（重要）"><a href="#四、总线标准（重要）" class="headerlink" title="四、总线标准（重要）"></a>四、总线标准（重要）</h2><h3 id="什么是总线标准？"><a href="#什么是总线标准？" class="headerlink" title="什么是总线标准？"></a>什么是总线标准？</h3><blockquote>
<p>总线标准，可视为系统与各模块、模块与模块之间的一个互连的<strong>标准界面</strong>。</p>
<p>这个界面对它两端的模块都是透明的，即界面的任一方只需根据总线标准的要求完成自身一方接口的功能要求，而无须了解对方接口与总线的连接要求。</p>
</blockquote>
<h3 id="为什么要设置总线标准？"><a href="#为什么要设置总线标准？" class="headerlink" title="为什么要设置总线标准？"></a>为什么要设置总线标准？</h3><blockquote>
<p>采用总线标准可以为计算机接口的软硬件设计<strong>提供方便</strong>。</p>
<p>对硬件设计而言，使各个模块的<strong>接口芯片设计</strong>相对<strong>独立</strong>；</p>
<p>对软件设计而言，更有利于<strong>接口软件</strong>的<strong>模块化</strong>设计。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225205744813.png" alt="image-20220225205744813" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225205811812.png" alt="image-20220225205811812" style="zoom:67%;" /></p>
<p><strong>注：串行不一定比并行慢</strong></p>
<p>需要了解名称及特点（信号管脚、哪些管脚定义、有效电平）</p>
<h3 id="1-ISA总线"><a href="#1-ISA总线" class="headerlink" title="1.ISA总线"></a>1.ISA总线</h3><blockquote>
<p>Industrial Standard Architecture</p>
<p>用于早期计算机</p>
</blockquote>
<ul>
<li>IBM为了采用全16位CPU而推出，又称<strong>AT总线</strong></li>
<li>使用<strong>独立于CPU的总线时钟</strong>，因此<strong>CPU可以采用比总线频率更高的时钟</strong>，有利于CPU性能提升</li>
<li><u>时钟频率<strong>8MHz</strong>，最大传输率<strong>16MBps</strong>，数据线为<strong>16位</strong>，地址线为<strong>24位</strong>。</u></li>
</ul>
<h3 id="2-EISA总线"><a href="#2-EISA总线" class="headerlink" title="2.EISA总线"></a>2.EISA总线</h3><blockquote>
<p>Extended Industrial Standard Architecture</p>
</blockquote>
<ul>
<li>在ISA基础上扩充开放的总线标准，<strong>与ISA可以完全兼容</strong></li>
<li>从CPU中<strong>分离出了总线控制权</strong>，是一种具有智能化的总线</li>
<li><p>能支持<strong>多个总线主控器</strong>和<strong>突发方式</strong>（总线上可以进行<strong>成块</strong>的数据传送）的传输</p>
</li>
<li><p><u>时钟频率<strong>8MHz</strong>，最大传输率<strong>33MBps</strong>，数据总线为<strong>32位</strong>，地址总线为<strong>32位</strong>，扩充DMA访问范围达$2^{32}$</u></p>
</li>
</ul>
<h3 id="3-VESA-VL-BUS-总线"><a href="#3-VESA-VL-BUS-总线" class="headerlink" title="3.VESA(VL-BUS)总线"></a>3.VESA(VL-BUS)总线</h3><blockquote>
<p>Video Electronic Standard Association 视频电子标准协会</p>
</blockquote>
<ul>
<li><p><strong>局部总线</strong>标准，又称VL-BUS(Local BUS)总线</p>
<p>局部总线：在<strong>系统外</strong>为<strong>两个以上的模块</strong>提供<strong>高速信息传输通道</strong></p>
</li>
<li><p>VL-BUS由CPU总线演化而来</p>
</li>
<li><p>通过<strong>局部控制器</strong>，<strong>将高速I/O设备直接挂在CPU上</strong>，实现CPU与高速I/O设备之间的高速数据交换</p>
</li>
<li><p><u>CPU时钟频率为<strong>33MHz</strong>，最大传输率<strong>133MBps</strong>，数据线为<strong>32位</strong>，可通过扩展槽<strong>扩展到64位</strong>，配有<strong>局部控制器</strong></u></p>
</li>
</ul>
<h3 id="4-PCI总线"><a href="#4-PCI总线" class="headerlink" title="4.PCI总线"></a>4.PCI总线</h3><blockquote>
<p>Peripheral Component Interconnect  外围部件互连</p>
<p>1991, Intel</p>
<p>图形用户接口和多媒体技术在PC系统中广泛应用，ISA总线和EISA总线由于受带宽的限制，已不能适应系统工作的要求，成为整个系统的主要瓶颈。因此对总线提出更高的性能要求</p>
<p>现代计算机普遍采用的标准</p>
</blockquote>
<p>参考资料：<a href="https://blog.csdn.net/fzhykx/article/details/79718744">PCI总线协议（一）</a></p>
<p>1、<strong>高性能</strong></p>
<ul>
<li>PCI总线是<strong>不依附于某个具体处理器</strong>的<strong>局部总线</strong></li>
<li>为系统提供高速的数据传输通道，<strong>与CPU时钟频率无关</strong>，<u>自身采用<strong>33MHz</strong>和<strong>66MHz</strong>频率的<strong>总线时钟</strong></u></li>
<li><u>数据线为<strong>32位</strong>，<strong>可扩展到64位</strong></u></li>
<li><u>传输速率从<strong>132MBps</strong>（33MHz时钟，32位数据通路）可升级到<strong>528MBps</strong>（66MHz，64位数据通路）</u></li>
<li>支持<strong>突发工作方式</strong>——若被传送的数据在主存中<strong>连续存放</strong>，则只需给出第一个数据的地址，不需要给出所有数据的地址信息（给第一个地址占一个时钟周期，其后每一个数据传送占一个时钟周期，提升传输速率）</li>
</ul>
<p>2、<strong>良好的兼容性</strong></p>
<ul>
<li><strong>PCI总线部件和接口插件相对于处理器独立</strong>，支持所有目前和将来不同结构的处理器，<strong>具有相当长的生命周期</strong></li>
<li>PCI总线与ISA和EISA总线均可<strong>兼容</strong>，可以<strong>转换</strong>为标准的ISA、EISA</li>
</ul>
<p>3、<strong>支持 即插即用(Plug and Play)</strong></p>
<ul>
<li>扩展卡只要<strong>插入系统便可工作</strong></li>
<li>PCI设备中配有<strong>存放设备具体信息</strong>的<strong>寄存器</strong>，这些信息可供<strong>BIOS（基本输入输出系统）和操作系统层的软件自动配置PCI总线部件和插件</strong>，使系统使用方便，无需手动配置</li>
</ul>
<p>4、<strong>支持 多主设备 能力</strong></p>
<ul>
<li>允许任何主设备和从设备之间实现<strong>点到点对等存取</strong>，体现了接纳设备的高度灵活性</li>
<li>主设备：一次总线传输期间，对总线有控制权的设备</li>
<li>从设备：一次总线传输期间，对总线没有控制权的设备</li>
</ul>
<p>5、<strong>具有与 处理器和存储器子系统 完全并行操作 的能力</strong></p>
<ul>
<li>PCI总线可视为CPU与外设之间的一个<strong>中间层</strong>，通过PCI桥路（PCI控制器）与CPU相连</li>
<li>PCI桥路有<strong>多级缓存</strong>，可把<strong>一批数据快速写入缓冲器中</strong>，在数据写入PCI设备过程中，可真正实现处理器/存储器子系统的安全并发工作。</li>
</ul>
<p>6、<strong>提供数据和地址 奇偶校验功能，保证数据的完整和准确</strong></p>
<p>7、<strong>支持两种电压标准：5V和3.3V</strong></p>
<ul>
<li>3.3~5V的组件技术可以使电压平滑过渡</li>
<li>3.3V电压的PCI总线技术可用于便携式微型计算机中</li>
</ul>
<p>8、<strong>可扩充性好</strong></p>
<ul>
<li>当PCI总线驱动能力不足时，可以采用多层结构</li>
</ul>
<p>9、<strong>软件兼容性好</strong></p>
<ul>
<li>PCI部件可以完全兼容现有的驱动程序和应用程序</li>
<li>设备驱动程序可被移植到各类平台上</li>
</ul>
<p>10、<strong>采用 多路复用技术，减少了总线引脚个数</strong></p>
<h3 id="5-AGP总线"><a href="#5-AGP总线" class="headerlink" title="5.AGP总线"></a>5.AGP总线</h3><blockquote>
<p>Accelerated Graphics Port 加速图形端口</p>
<p>用于处理三维数据，需有更宽广的数据传输带宽，PCI总线成为传输瓶颈</p>
</blockquote>
<ul>
<li><p>基于PCI 2.1，采用点对点通道方式</p>
</li>
<li><p>以<strong>66.7MHz</strong>的频率直接与主存联系，以主存作为帧缓冲器，实现了高速存取。</p>
</li>
<li><p>最大传输率<strong>266MBps</strong>，数据宽度位<strong>32位</strong>——传统PCI总线带宽的2倍</p>
</li>
<li><p>“双激励”(Double Pumping)传输技术：在一个时钟的上、下沿双向传递数据</p>
<p>传输频率为<strong>66.7MHz×2，即133MHz</strong>，最大传输率<strong>533MBps</strong></p>
<p>后来版本数据传输速率可达2.1GBps</p>
</li>
</ul>
<h3 id="6-RS-232C总线"><a href="#6-RS-232C总线" class="headerlink" title="6.RS-232C总线"></a>6.RS-232C总线</h3><blockquote>
<p>RS: Recommended Standard，232标识号，C 修改次数</p>
<p>RS-232：仪器仪表（飞机、键盘）系统标准（220V等，温度、湿度、压力），可接距离远</p>
</blockquote>
<ul>
<li><p>一种<strong>串行通信总线标准</strong></p>
</li>
<li><p>应用于串行二进制交换的<strong>数据终端设备（DTE, Data Terminal Equipment）</strong>（计算机）和<strong>数据通信设备（DCE, Data Communication Equipment）</strong>（调制解调器）之间的标准接口</p>
</li>
<li><p>规定的<strong>逻辑电平</strong>与计算机系统中TTL和MOS电平不同</p>
<p><strong>低电平表示逻辑“1”，并要求低电平为-15~-3V</strong></p>
<p><strong>高电平表示逻辑“0”，并要求高电平为+3~+15V</strong></p>
</li>
</ul>
<blockquote>
<p>随着计算机网络发展，现代计算机之间的远距离通信可直接由网卡经网线（8根，双绞线）传输</p>
</blockquote>
<h3 id="7-USB总线"><a href="#7-USB总线" class="headerlink" title="7.USB总线"></a>7.USB总线</h3><blockquote>
<p>Universal Serial Bus 通用串行总线</p>
<p>1994 七大公司联合开发计算机串行接口总线标准</p>
<p>1996.1 USB 1.0 通用连接技术</p>
</blockquote>
<p><strong>具有真正的即插即用特征</strong></p>
<ul>
<li>不关机情况下对外设实行安装和拆卸</li>
</ul>
<p><strong>具有很强的连接能力</strong></p>
<ul>
<li>使用USB HUB（USB集线器）实现系统扩展，最多可链式连接127个外设到同一系统</li>
</ul>
<p><strong>数据传输率</strong>（USB1.0版）</p>
<ul>
<li><strong>普通无屏蔽双绞线：1.5Mbps</strong></li>
<li><strong>带屏蔽双绞线：12Mbps</strong></li>
<li>USB 2.0版：<strong>480Mbps</strong></li>
</ul>
<p><strong>标准统一</strong></p>
<ul>
<li>减轻了对目前PC中所有标准接口的需求</li>
</ul>
<p><strong>连接电缆轻巧，电源体积缩小</strong></p>
<ul>
<li>USB使用4芯电缆。2条用于信号连接，2条用于电源/地（为外设提供+5V直流电源）</li>
</ul>
<p><strong>生命力强</strong></p>
<ul>
<li>开放性、不具有专利版权的工业标准</li>
<li>USB规范具有强大生命力</li>
</ul>
<h1 id="3-4-总线结构（了解即可）"><a href="#3-4-总线结构（了解即可）" class="headerlink" title="3.4 总线结构（了解即可）"></a>3.4 总线结构（了解即可）</h1><p>（了解即可）</p>
<p>通常可分为单总线结构和多总线结构</p>
<h2 id="一、单总线结构"><a href="#一、单总线结构" class="headerlink" title="一、单总线结构"></a>一、单总线结构</h2><p>特点：</p>
<ul>
<li><p>效率低</p>
</li>
<li><p>结构简单</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212054042.png" alt="image-20220225212054042" style="zoom:67%;" /></p>
<h2 id="二、多总线结构"><a href="#二、多总线结构" class="headerlink" title="二、多总线结构"></a>二、多总线结构</h2><ol>
<li><p><strong>双总线结构</strong></p>
<p>通道控制器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212127403.png" alt="image-20220225212127403" style="zoom:67%;" /></p>
</li>
<li><p><strong>三总线结构</strong></p>
<ul>
<li><p>I/O总线（慢）</p>
</li>
<li><p>主存总线</p>
</li>
<li><p>DMA总线（存储器直接存取）：直接管理主存和外设之间的信息交换</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212154222.png" alt="image-20220225212154222" style="zoom:67%;" /></p>
</li>
</ul>
</li>
<li><p><strong>三总线结构的又一形式</strong></p>
<ul>
<li><p>局部总线：提升CPU和主存速度不匹配</p>
</li>
<li><p>系统总线</p>
</li>
<li><p>扩展总线</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212215082.png" alt="image-20220225212215082" style="zoom:67%;" /></p>
</li>
</ul>
</li>
<li><p><strong>四总线结构</strong></p>
<ul>
<li><p>局部总线</p>
</li>
<li><p>系统总线</p>
</li>
<li><p>高速总线</p>
</li>
<li><p>扩展总线：将慢速设备划分并管理起来</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212240661.png" alt="image-20220225212240661" style="zoom:67%;" /></p>
</li>
</ol>
<h2 id="三、总线结构距离"><a href="#三、总线结构距离" class="headerlink" title="三、总线结构距离"></a>三、总线结构距离</h2><ol>
<li><strong>传统微型机总线结构</strong></li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212312246.png" alt="image-20220225212312246" style="zoom:67%;" /></p>
<ol>
<li><strong>VL-BUS局部总线结构</strong></li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212329275.png" alt="image-20220225212329275" style="zoom:67%;" /></p>
<ol>
<li><p><strong>PCI 总线结构</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212351878.png" alt="image-20220225212351878" style="zoom:67%;" /></p>
</li>
<li><p><strong>多层 PCI 总线结构</strong></p>
<p>桥联，连接多级总线</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225212418731.png" alt="image-20220225212418731" style="zoom:67%;" /></p>
</li>
</ol>
<h1 id="3-5-总线控制（重点内容）"><a href="#3-5-总线控制（重点内容）" class="headerlink" title="3.5 总线控制（重点内容）"></a>3.5 总线控制（重点内容）</h1><p>（重点内容）</p>
<blockquote>
<p>总线控制器统一管理总线上连接着的多个部件：</p>
<p>什么时候由哪个部件发送信息、如何给信息传送定时、如何放置信息丢失、如何避免多个部件同时发送、如何规定接收信息的部件</p>
</blockquote>
<p>总线控制主要包括</p>
<ul>
<li><p><strong>判优控制（仲裁逻辑）</strong>：多个设备可能同时发出占用总线的请求，但总线在同一时刻只能有一个设备占用</p>
</li>
<li><p><strong>通信控制</strong>：如何完成通讯过程，保证通讯过程的正确性</p>
</li>
</ul>
<h2 id="一、总线判优控制（要掌握的内容）"><a href="#一、总线判优控制（要掌握的内容）" class="headerlink" title="一、总线判优控制（要掌握的内容）"></a>一、总线判优控制（要掌握的内容）</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul>
<li><p>主设备（模块）：对总线有<strong>控制权</strong>——送信息：传输出去、准确；读信息：把从设备提供的信息取到主设备</p>
<p>CPU、DMA</p>
<p>I/O设备发出控制信号</p>
<blockquote>
<p>总线（主模块）——周期（时间段）决定传输的快和慢</p>
<p>①控制线决定命令性质（由控制信号指出）：$\begin{cases} I \\ O \end{cases}$</p>
<p>②地址线寻址——找到从模块</p>
<p>③数据线——内容</p>
<p>​            $\Downarrow$</p>
<p>总线规则：从设备“唯一”寻址</p>
<p>被选中的模块打开三态门（总线驱动器），接通</p>
<p>其他未选中的三态门关上</p>
<p>使用三态门还可以起到隔离的作用（对于故障的设备——系统可检测出溢出）</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>从设备（模块）：<strong>响应</strong>主设备发来的总线命令</p>
<p>存储器、I/O接口地址</p>
</li>
<li><p>总线判优控制$\begin{cases} 集中式 \begin{cases} 链式查询 \\ 计数器定时查询 \\ 独立请求方式 \\  \end{cases} \\ 分布式 \\ \end{cases}$​</p>
<p>集中式（有总线控制器/部件）：一个核内的协调</p>
<p>分布式：独立的计算机/服务器阵列</p>
</li>
</ul>
<h3 id="2-链式查询方式"><a href="#2-链式查询方式" class="headerlink" title="2.链式查询方式"></a>2.链式查询方式</h3><p>链式查询方式：用于微型计算机、简单的嵌入式系统</p>
<blockquote>
<p>CPU/DMA挂在I/O接口上，作为控制器。带“圈”，低电平有效</p>
<p>请求：高电平有效；回答：低电平有效</p>
<p>总线控制部件分配</p>
<p>触发器：BS占用置1，未使用置0</p>
<p>BG信号未到达的设备处于等待状态</p>
</blockquote>
<p>判优方式：<strong>离总线控制器越近的部件，其优先级越高</strong></p>
<p>优点：①结构简单，只需要3根控制线；②增删设备容易；③可靠性设计容易实现</p>
<p>缺点：①对电路故障特别敏感（BS、BR、BG都很关键，一条出故障导致电路故障）；②当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线（<strong>优先级不够灵活</strong>）；③速度慢</p>
<blockquote>
<p>控制总线中有3根线用于总线控制（BS总线忙、BR总线请求、BG总线同意）</p>
<p>总线同意信号BG串行地从一个I/O接口送到下一个I/O接口。如果BG到达的接口<strong>有总线请求</strong>，<strong>BG信号就不再往下传</strong>，意味该接口获得总线使用权，并<strong>建立总线忙BS信号</strong>，表示它占用了总线</p>
<p>进入总线传输周期</p>
<p>使用结束</p>
<p>触发器让BS强行置0，总线释放</p>
<p>BG已经过的设备不能分得总线控制权，只能等待下一轮循环</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220112112254188.png" alt="image-20220112112254188" style="zoom: 67%;" /></p>
<h3 id="3-计数器定时查询方式"><a href="#3-计数器定时查询方式" class="headerlink" title="3.计数器定时查询方式"></a>3.计数器定时查询方式</h3><p>判优方式：总线控制部件中有计数器</p>
<p>$n$​台设备需要$log_2n$​​（向上取整）根控制总线</p>
<p><strong>特点</strong></p>
<ul>
<li>对电路故障不如链式查询方式敏感（但BS、BR的问题仍存在）</li>
<li>增加了控制线（设备地址）数，控制也较复杂</li>
</ul>
<blockquote>
<p>多了一组设备地址线，少了一根总线同意线BG。</p>
<p>总线控制部件接到由BR送来的总线请求信号后，在总线未被使用（$BS = 0$）的情况下，总线控制部件中的计数器开始计数，并通过设备地址线，向各设备发送一组地址信号。</p>
<p>当某个请求占用总线的设备地址与计数值一致时（接收BS应答信号），便获得总线使用权，此时中止计数查询。</p>
<p>结束使用</p>
<p>BS总线忙置零，计数器继续计数，在该轮循环中找之后的申请的设备。</p>
<p>例如，当1使用完，0若申请则只能等下一轮循环才可以使用</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220112112948908.png" alt="image-20220112112948908" style="zoom: 67%;" /></p>
<h3 id="4-独立请求方式"><a href="#4-独立请求方式" class="headerlink" title="4.独立请求方式"></a>4.独立请求方式</h3><p>任何一个I/O接口都添加了两条线</p>
<p>$n$​台设备需要$2n$​根控制线</p>
<p>总线控制器可以给CPU</p>
<p>各个设备的优先级相同</p>
<p><strong>特点</strong></p>
<ul>
<li>响应速度快，优先次序控制灵活（通过程序改变）</li>
<li>控制线数量多，总线控制更复杂</li>
<li>不存在线路敏感的问题（对比前两种）</li>
</ul>
<blockquote>
<p>每台设备均有一对总线请求线$BR_i$​和总线同意线$BG_i$​</p>
<p>总线控制部件中有排队器，可以根据优先次序确认响应哪一台设备的请求</p>
<p>总线控制权一般不允许嵌套（ch5，中断方式允许嵌套），不会出现打断</p>
<p>排队器——硬件（ch5，ch8）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220112113806812.png" style="zoom: 67%;" /></p>
<h2 id="二、总线通信控制"><a href="#二、总线通信控制" class="headerlink" title="二、总线通信控制"></a>二、总线通信控制</h2><ul>
<li><p>目的：解决通信双方<strong>协调配合</strong>问题</p>
</li>
<li><p>总线传输周期</p>
<ul>
<li><strong>申请分配阶段</strong>：<strong>主模块申请</strong>，总线仲裁决定</li>
<li><strong>寻址阶段</strong>：主模块向从模块<strong>给出地址</strong>和<strong>命令</strong></li>
<li><strong>传输阶段</strong>：主模块和从模块经数据总线<strong>交换数据</strong></li>
<li><strong>结束阶段</strong>：主模块从系统总线<strong>撤销有关信息</strong>，让出总线使用权</li>
</ul>
<p>对于CPU，只有两个阶段，传输周期减少，速度变快</p>
</li>
<li><p>总线通信的四种方式</p>
<ul>
<li><p>同步通信：由<strong>统一时标</strong>控制数据传送</p>
<blockquote>
<p>对于CPU，是主频——与内存进行通信</p>
</blockquote>
</li>
<li><p>异步通信：采用<strong>应答方式</strong>，没有公共时钟标准</p>
<blockquote>
<p>握手的方式，高速和低速</p>
</blockquote>
</li>
<li><p>半同步通信：<strong>同步、异步结合</strong></p>
<blockquote>
<p>有的时候可以采用同一频率工作，有时不能——如，乘法运算（允许增加节拍的整数倍）</p>
</blockquote>
</li>
<li><p>分离式通信：充分<strong>挖掘</strong>系统<strong>总线每个瞬间</strong>的潜力，发挥最大效能</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-目的"><a href="#1-目的" class="headerlink" title="1.目的"></a>1.目的</h3><p>解决通信双方<strong>协调配合</strong>问题</p>
<h3 id="2-总线传输周期"><a href="#2-总线传输周期" class="headerlink" title="2.总线传输周期"></a>2.总线传输周期</h3><script type="math/tex; mode=display">
\begin{cases}
申请分配阶段——主模块申请，总线仲裁决定 \\
寻址阶段——主模块向从模块给出地址和命令 \\
传数阶段——主模块和从模块交换数据 \\
结束阶段——主模块撤销有关信息 \\
\end{cases}</script><ul>
<li>申请分配阶段：<strong>主模块申请</strong>，总线仲裁决定</li>
<li>寻址阶段：主模块向从模块<strong>给出地址</strong>和<strong>命令</strong></li>
<li>传数阶段：主模块和从模块经数据总线<strong>交换数据</strong></li>
<li>结束阶段：主模块从系统总线<strong>撤销有关信息</strong>，让出总线使用权</li>
</ul>
<p>对于CPU，只有两个阶段，传输周期减少，速度变快</p>
<h3 id="3-总线通信的四种方式"><a href="#3-总线通信的四种方式" class="headerlink" title="3.总线通信的四种方式"></a>3.总线通信的四种方式</h3><script type="math/tex; mode=display">
\begin{cases}
同步通信——由统一时标控制数据传送 \\
异步通信——采用应答方式，没有公共时钟标准 \\
半同步通信——同步、异步结合 \\
分离式通信——充分发掘系统总线每个瞬间的潜力 \\
\end{cases}</script><h4 id="（1）同步式数据输入"><a href="#（1）同步式数据输入" class="headerlink" title="（1）同步式数据输入"></a>（1）同步式数据输入</h4><p>定宽、定距的时钟控制整个过程。</p>
<p>固定的时间点给出固定的操作。</p>
<blockquote>
<p>$T_1$​​​的上升沿，主设备CPU<strong>给出地址信号</strong>；——如，指令“MOV ACC, (20H)”中的十六进制数(20H)，相应的地址信号变化，调整到对应的地址码上（依照指令）。</p>
<p>$T_2$​​​上升沿​，CPU<strong>给出读命令信号</strong>；——此时数据总线上可以有数，但不是指定的正确的数，因为还没传数，不是正确地址驱动。</p>
<p>与地址信号相符合的<strong>输入设备进行一系列内部操作</strong>，且必须<strong>在$T_3$​上升沿到来之前</strong>将CPU所需的<strong>数据送到数据总线</strong>上；——相应地址驱动一直保持（送数据并锁定）</p>
<p>地址不变，读命令一直有效，数据稳定</p>
<p>$T_3$​​上升沿，从设备给出数据信号，通过数据总线；——采样点，被采样的数据应稳定保持一段时间。</p>
<p>CPU在$T_3$​时钟期间内<strong>将数据总线上的信息送到其内部寄存器</strong>中；</p>
<p>$T_4$​上升沿，<strong>CPU撤销读命令</strong>。数据信号和控制信号撤销，结束后地址信号撤销。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220228131731765.png" alt="image-20220228131731765" style="zoom:67%;" /></p>
<blockquote>
<p>图中：斜坡表示电平发生变化（0$\leftrightarrow$​1）</p>
<p>$T_4$上升沿的数据应保持一段时间</p>
<p>$T_1$：主模块发地址</p>
<p>$T_2$：主模块发读命令</p>
<p>$T_3$：从模块提供数据</p>
<p>$T_4$​：主模块撤销读命令，从模块撤销数据</p>
<p>后面是下一个总线传输周期</p>
</blockquote>
<h4 id="（2）同步式数据输出"><a href="#（2）同步式数据输出" class="headerlink" title="（2）同步式数据输出"></a>（2）同步式数据输出</h4><blockquote>
<p>例如，”MOV (22H) A5H”，$\overline{MEMW}$</p>
<p>命令慢，等地址和数据</p>
<p>$T_1$上升沿：地址信号调整，保持稳定、有效</p>
<p>$T_{1.5}$：数据信号调整到对应位置</p>
<p>$T_2$：写命令，写，等待命令翻转，控制器控制采样。命令信号应前移，采样时应保持控制命令、地址、数据信号稳定</p>
<p>$T_4$​​：三态门关闭，<strong>地址先撤掉</strong></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220228131812640.png" alt="image-20220228131812640" style="zoom:67%;" /></p>
<blockquote>
<p>$T_1$​：主模块发地址</p>
<p>$T_{1.5}$：主模块提供数据</p>
<p>$T_2$​：主模块发写命令，从模块接到写命令后，必须在规定时间内将数据总线上的数据写到地址总线所指明的单元中</p>
<p>$T_4$：主模块撤销读命令，从模块撤销数据</p>
</blockquote>
<h4 id="（3）异步通信"><a href="#（3）异步通信" class="headerlink" title="（3）异步通信"></a>（3）异步通信</h4><p>采用<strong>应答方式</strong>，即：当主模块发出请求信号时，一直等待从模块反馈回来会打信号后才开始通信。</p>
<p>异步通信的应答方式分为：<strong>不互锁</strong>、<strong>半互锁</strong>和<strong>全互锁</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220228131835118.png" alt="image-20220228131835118" style="zoom:67%;" /></p>
<p>①<strong>不互锁</strong></p>
<blockquote>
<p><strong>主模块</strong>发出请求信号后，<strong>不必等待接到从模块的回答信号</strong>。经过一段时间，确认从模块已收到请求信号后，撤销其请求信号。</p>
</blockquote>
<p>“主设备不负责任”</p>
<p>优点：简单</p>
<p>缺点：从设备可能会接收不到请求信号</p>
<p>②<strong>半互锁</strong></p>
<blockquote>
<p><strong>主模块</strong>发出请求信号，<strong>必须待接到从模块的回答信号后再撤销其请求信号</strong>，有互锁关系；</p>
<p><strong>从模块</strong>在接到请求信号后发出回答信号，<strong>不必等待获知主模块的请求信号已经撤销</strong>。隔一段时间后自动撤销其回答信号，无互锁关系。</p>
</blockquote>
<p>“握手少”</p>
<p>从设备接收请求信号后，不管主设备</p>
<p>③<strong>全互锁</strong></p>
<p>双方存在互锁关系</p>
<blockquote>
<p><strong>主模块</strong>发出请求信号，<strong>必须待从模块回答后再撤销其请求信号</strong>；</p>
<p><strong>从模块</strong>发出回答信号，<strong>必须待获知主模块请求信号已经撤销后</strong>，再撤销其回答信号。</p>
</blockquote>
<p>优点：可靠</p>
<h4 id="（4）半同步通信（同步、异步结合）"><a href="#（4）半同步通信（同步、异步结合）" class="headerlink" title="（4）半同步通信（同步、异步结合）"></a>（4）半同步通信（同步、异步结合）</h4><p>（快的主设备等待慢的从设备，直到$\overline{WAIT}$变成高电平）</p>
<ul>
<li><p>同步</p>
<p><strong>发送方</strong>用系统<strong>时钟前沿</strong>发信号</p>
<p><strong>接收方</strong>用系统<strong>时钟后沿</strong>判断、识别</p>
</li>
<li><p>异步</p>
<p>允许不同速度的模块和谐工作</p>
<p>增加一条<strong>“等待”响应信号</strong> $\overline{WAIT}$​（低电平有效，节拍的整数倍）​​</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220228132337109.png" alt="image-20220228132337109" style="zoom:67%;" /></p>
<blockquote>
<p>以输入数据为例的半同步通信时序：</p>
<p>$T_1$ 主模块发地址</p>
<p>$T_2$​ 主模块发命令</p>
<p>$T_W$​ 当$\overline{WAIT}$​为低电平时，等待一个$T$</p>
<p>$T_W$​ 当$\overline{WAIT}$​为低电平时，等待一个$T$</p>
<p>…</p>
<p>$T_3$ 从模块提供数据</p>
<p>$T_4$ 从模块撤销数据，主模块撤销命令</p>
</blockquote>
<ul>
<li><p>文字描述</p>
<ul>
<li>第一个阶段时钟信号开始：CPU给出地址信号，通过地址总线。</li>
</ul>
</li>
</ul>
<ul>
<li>第二个阶段：读操作，CPU给出读信号。第三个时钟周期开始前，如果从设备不能准备好，需通过$\overline{WAIT}$信号给出低电平，告诉CPU进行等待。CPU检测，若为低电平，则在第三周期到来前，插入时钟周期$T_w$。在下一个时钟周期到来前，主设备依然要检测$\overline{WAIT}$信号是否为低电平。如果$\overline{WAIT}$信号为高电平，则进入第三个阶段。</li>
</ul>
<ul>
<li>第三个阶段：数据准备好进行传输，数据已放在数据总线上，CPU接收数据。</li>
</ul>
<ul>
<li>第四个阶段：读命令信号和数据信号从总线上撤销。第四个时钟周期结束，地址总线上的地址信号也撤销。</li>
</ul>
<h4 id="上述三种通信的共同点"><a href="#上述三种通信的共同点" class="headerlink" title="上述三种通信的共同点"></a>上述三种通信的共同点</h4><p>一个总线传输周期（以输入数据为例）</p>
<ul>
<li>主模块通过传输总线向从模块发地址、命令：<strong>占用地址、控制总线</strong></li>
<li>从模块按照命令准备数据：<strong>不占用总线</strong>，总线空闲</li>
<li>从模块经数据总线向主模块发数据：<strong>占用数据总线</strong></li>
</ul>
<p>下一步：把总线空闲的时间利用起来——<u>从模块内部读数据过程并无实质性的信息传输</u>，总线纯属空闲等待。</p>
<h4 id="（5）分离式通信"><a href="#（5）分离式通信" class="headerlink" title="（5）分离式通信"></a>（5）分离式通信</h4><p><strong>充分挖掘系统总线每个瞬间的潜力</strong>——总线不闲下来</p>
<p>各模块占用总线使用权都必须提出申请。在准备数据的过程中不占用总线。</p>
<p>一个总线传输周期：$\begin{cases} 子周期1：主模块申请占用总线，使用完后即放弃总线的使用权 \\ 子周期2：从模块申请占用总线，将各种信息送至总线上  \end{cases}$​</p>
<p>（主模块可以变成从模块）</p>
<p><strong>分离式通信特点</strong></p>
<ul>
<li>各模块有权申请占用总线</li>
<li>采用同步方式通信，不等对方回答</li>
<li>各模块准备数据时，不占用总线</li>
<li>总线被占用时，无空闲（充分利用总线的带宽）</li>
</ul>
<p><strong>充分提高了总线的有效占用</strong></p>
<p>总线传输时间：总线完成一次完整而可靠传输所需时间</p>
<p>总线的通信控制：总线传送过程中双方的时间配合方式</p>
<h1 id="补充题"><a href="#补充题" class="headerlink" title="补充题"></a>补充题</h1><p>3.17 查资料完成：</p>
<p>①写出EISA（ISA）总线的标准信号定义</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220228190819228.png" alt="image-20220228190819228" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220228190847957.png" alt="image-20220228190847957" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220228190913283.png" alt="image-20220228190913283" style="zoom:67%;" /></p>
<p>②画出插座的俯视图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323195850149.png" alt="image-20220323195850149" style="zoom:80%;" /></p>
<p>③写出$A_1,D_1$的编号</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ul>
<li><p>例3.1</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302195533905.png" alt="image-20220302195533905" style="zoom:67%;" /></p>
</li>
</ul>
<blockquote>
<p>在实际情况中，</p>
<ul>
<li><p>增加数据线的宽度会使整个CPU的设计产生变化。存储器从32$\to$64</p>
</li>
<li><p>增加总线的时钟频率要求更高的性能，否则会导致计算机不稳定（步调跟不上）</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>例3.2</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302195829192.png" alt="image-20220302195829192" style="zoom:67%;" /></p>
</li>
</ul>
<blockquote>
<p><strong>异步串行通信的数据传送速率</strong>用<strong>波特率</strong>衡量。</p>
<p>波特率：单位时间内传送二进制数据的位数，单位：bps（位/秒）</p>
</blockquote>
<ul>
<li><p>例3.3</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302200713658.png" alt="image-20220302200713658" style="zoom:67%;" /></p>
</li>
<li><p>例3.4</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302200648866.png" alt="image-20220302200648866" style="zoom:67%;" /></p>
<blockquote>
<p>比特率：单位时间内通过信道传输的信息量称为比特传输速率，单位是比特/秒（bit/s）</p>
</blockquote>
</li>
</ul>
<p>【参考资料】：</p>
<p><a href="https://zhuanlan.zhihu.com/p/355061904">波特率和比特率</a></p>
<p><a href="https://blog.csdn.net/wordwarwordwar/article/details/78081156">波特率与比特率的关系</a></p>
<p><a href="https://blog.csdn.net/ymdq1113/article/details/69677116">波特率与比特率</a></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>computer organization</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理：第5章 输入输出系统</title>
    <url>/computer_organization/computer-organization-ch5/</url>
    <content><![CDATA[<p>除了CPU和存储器两大模块外，计算机硬件系统的第三个关键部分是<strong>输入输出模块</strong>，又称输入输出系统。</p>
<p>本章重点分析I/O设备与主机交换信息的三种控制方式（程序查询、中断、DMA）及其相应的接口功能和组成。主要介绍<strong>接口和DMA阶段</strong>的I/O系统</p>
<p><strong>每一节要求掌握的程度</strong>：硬件什么样，软件程序如何配合完成数据的输入输出</p>
<span id="more"></span>
<h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>I/O设备的独立性越来越强。</p>
<h3 id="一、I-O系统的发展概况"><a href="#一、I-O系统的发展概况" class="headerlink" title="一、I/O系统的发展概况"></a>一、I/O系统的发展概况</h3><ol>
<li><p><strong>早期阶段</strong>（程序查询方式）</p>
<p>I/O设备与主存交换信息都是通过CPU才能完成交换。</p>
<p>每个I/O设备都必须配有一套独立的逻辑电路与CPU相连。 </p>
<p>输入输出过程穿插在CPU执行程序过程中进行的，当I/O设备与主机交换信息时，CPU不得不停止各种运算，按<strong>串行</strong>方式工作，极浪费时间。</p>
<p>每个I/O逻辑控制电路与CPU的控制器紧密构成一个不可分割的整体，彼此依赖，相互牵连。难以增添、撤减设备。</p>
</li>
<li><p><strong>接口模块和DMA阶段</strong>（中断方式和DMA方式）</p>
<p>DMA：存储器直接输入输出方式</p>
<p>I/O设备通过接口模块与主机相连，采用<strong>总线连接</strong>方式</p>
<blockquote>
<p>I/O接口、DMA控制器与主机、CPU相互配合完成数据的输入和输出</p>
<p>连接方式变化：采用总线方式连接。I/O设备通过接口连接在总线上。一个总线连接多个设备</p>
</blockquote>
<p>CPU和I/O设备<strong>并行</strong>工作$\begin{cases} 中断方式 \\ DMA方式 \end{cases}$</p>
<blockquote>
<p>DMA在系统中可以有多个</p>
</blockquote>
</li>
<li><p><strong>通道结构的阶段</strong>（中大型计算机）</p>
<blockquote>
<p>通道用来负责管理I/O设备以及实现主存与I/O设备之间交换信息的部件，视为具有特殊功能的处理器。</p>
<p>通道有专用的通道指令，能独立地执行用通道指令编写的输入输出程序，但不是完全独立的处理器。（从属于CPU的专用的处理器）</p>
</blockquote>
<p>依赖通道管理的I/O设备在与主机交换信息时，CPU不直接参与管理，故提高了CPU的资源利用率。</p>
</li>
<li><p><strong>I/O处理机</strong></p>
<p>（又称“外围处理及”Peripheral Processor）</p>
<p>在没有处理器的情况下可以作为主机完成任务</p>
</li>
</ol>
<h3 id="二、输入输出系统的组成"><a href="#二、输入输出系统的组成" class="headerlink" title="二、输入输出系统的组成"></a>二、输入输出系统的组成</h3><h4 id="1-I-O软件"><a href="#1-I-O软件" class="headerlink" title="1.I/O软件"></a>1.I/O软件</h4><blockquote>
<p>功能：</p>
<p>(1). 将用户编制的程序（或数据）输入到主机内</p>
<p>(2). 将运算结果输出给用户</p>
<p>(3). 实现输入输出系统和主机工作的协调</p>
</blockquote>
<ul>
<li><p>指令</p>
<ul>
<li>对于接口模块方式，采用<strong>I/O指令</strong>完成</li>
<li>对于通道管理模式，需要<strong>I/O指令</strong>和<strong>通道指令</strong></li>
</ul>
</li>
<li><p><strong>I/O指令</strong>：CPU指令的一部分</p>
<script type="math/tex; mode=display">
\color{red}{操作码|命令码|设备码}</script><p><strong>操作码</strong>字段可作为I/O指令与其他指令的判别代码；</p>
<blockquote>
<p>如，访存指令、算逻指令、控制指令</p>
</blockquote>
<p><strong>命令码</strong>体现I/O设备的具体操作；</p>
<blockquote>
<p>I/O指令的<strong>命令码</strong>一般可表述如下几种情况：</p>
<ul>
<li>将数据从I/O设备输入主机</li>
<li>将数据从主机输出到I/O设备</li>
<li>状态测试（检测各个I/O设备处于Busy还是Ready状态）</li>
<li>形成某些操作命令</li>
</ul>
</blockquote>
<p><strong>设备码</strong>是多台设备的选择码。</p>
</li>
</ul>
<ul>
<li><p><strong>通道指令</strong>：通道自身的指令</p>
<p>（又称通道控制字, Channel Control Word, CCW）</p>
<p>指出<strong>数组的首地址、传送字数、操作命令</strong></p>
<blockquote>
<p>如，IBM/370通道指令为64位</p>
</blockquote>
</li>
</ul>
<h4 id="2-I-O硬件"><a href="#2-I-O硬件" class="headerlink" title="2.I/O硬件"></a>2.I/O硬件</h4><p>包括接口模式、I/O设备两大部分</p>
<ul>
<li>设备——I/O接口（通过接口，与主机完成信息交换）</li>
<li>通道方式：设备——设备控制器——子通道——通道</li>
</ul>
<h3 id="三、I-O设备与主机的联系方式"><a href="#三、I-O设备与主机的联系方式" class="headerlink" title="三、I/O设备与主机的联系方式"></a>三、I/O设备与主机的联系方式</h3><p>I/O设备与主机交换信息和CPU与主存交换信息相比，有许多不同点。</p>
<blockquote>
<p>例如，CPU如何对I/O设备进行编址；如何寻找I/O设备号；信息传送是如何逐位串行还是多为并行；I/O设备与主机以什么方式进行联络，使它们彼此都知道对方处于何种状态；I/O设备与主机是怎么连接的，等等。</p>
</blockquote>
<p>这一系列问题统称为I/O设备与主机的联系方式</p>
<h4 id="1-I-O设备编址方式"><a href="#1-I-O设备编址方式" class="headerlink" title="1.I/O设备编址方式"></a>1.I/O设备编址方式</h4><blockquote>
<p>通常将I/O设备码看作地址码</p>
</blockquote>
<ul>
<li><p><strong>统一编址</strong>：把I/O地址看作存储器地址的一部分</p>
<p>用取数、存数指令。</p>
<p><strong>占用存储空间</strong>，减少主存容量</p>
<blockquote>
<p>如，在64K地址的存储空间中，划分出8K地址作为I/O设备的地址。凡是在这8K地址内的访问，就是对I/O设备的访问。所用指令与访存指令相似。</p>
</blockquote>
</li>
<li><p><strong>不统一编址</strong>（单独编址）：I/O地址和存储器地址分开，所有对I/O设备的访问必须有专用的I/O指令</p>
<p>有专门的I/O指令</p>
<p>不占用主存空间，需要设置I/O专用指令</p>
</li>
</ul>
<h4 id="2-设备选址"><a href="#2-设备选址" class="headerlink" title="2.设备选址"></a>2.设备选址</h4><blockquote>
<p>由于每台设备都赋予一个设备号，因此要启动某一设备时，可由I/O指令的设备码字段直接指出该设备的设备号</p>
</blockquote>
<p>用<strong>设备选择电路</strong>识别是否被选中</p>
<p>（现代计算机已经去掉，设备不给单独地址）</p>
<h4 id="3-传送方式"><a href="#3-传送方式" class="headerlink" title="3.传送方式"></a>3.传送方式</h4><ul>
<li><p><strong>串行</strong>：在同一瞬间只传送一位信息，在不同时刻连续逐位传送一串信息。</p>
<p>传输速度较慢，但只需一根数据线和一根地线。传输距离远</p>
</li>
<li><p><strong>并行</strong>：在同一瞬间，n位信息同时从CPU输出至I/O设备，或由I/O设备输入CPU。</p>
<p>传输速度较快，但要求数据线多</p>
<blockquote>
<p>例如，16位信息并行传送需要16根数据线</p>
</blockquote>
</li>
</ul>
<h4 id="4-联络方式"><a href="#4-联络方式" class="headerlink" title="4.联络方式"></a>4.联络方式</h4><ol>
<li><p><strong>立即响应</strong></p>
<p>对于一些工作速度十分缓慢的I/O设备。</p>
<p>与CPU发生联系时，处于某种等待状态，只要I/O指令一到便立即响应。</p>
<blockquote>
<p>如，指示灯的亮和灭、开关的通断、A/D转换器缓变信号的输入</p>
</blockquote>
</li>
<li><p><strong>异步工作采用应答信号</strong></p>
<p>当I/O设备与主机工作速度不匹配时，采用异步工作方式。</p>
<p>交换信息前，I/O设备与主机完成各自的任务。一旦出现联络信号，彼此才准备交换信息。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321150200094.png" alt="image-20220321150200094" style="zoom:80%;" /></p>
</li>
</ol>
<p>   <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321150239215.png" alt="image-20220321150239215" style="zoom:80%;" /></p>
<blockquote>
<p>关于异步串行通信：</p>
<p>参考资料：<a href="https://blog.csdn.net/sinat_41653350/article/details/106018051">异步串行通信</a></p>
<p>①起始位为0。通讯线在空闲状态时保持高电平，因此下降沿判定为数据传输开始。</p>
<p>②数据位。传输时低位在前，高位在后。</p>
<p>③奇偶校验位（可以省略）</p>
<p>④停止位（终止位），停止位为1——位数可以有分数，因为位数本质含义是信号出现的时间。</p>
</blockquote>
<ol>
<li><p><strong>同步工作采用同步时标</strong></p>
<p>要求I/O设备与CPU工作速度完全同步。</p>
<p>这种联络互相之间还得配有<strong>专用电路</strong>，用以产生同步时标来控制同步工作。</p>
</li>
</ol>
<h4 id="5-I-O设备与主机的连接方式"><a href="#5-I-O设备与主机的连接方式" class="headerlink" title="5.I/O设备与主机的连接方式"></a>5.I/O设备与主机的连接方式</h4><blockquote>
<p>连接方式主要有两种：辐射式连接和总线式</p>
</blockquote>
<ul>
<li><p><strong>辐射式连接</strong></p>
<p>（计算机发展的初级阶段）</p>
<p>优点是可靠性高。</p>
<p>要求每一台I/O设备都有一套控制线路和一组信号线，因此所用的器材和连线较多，对I/O设备的增删都比较困难。</p>
</li>
<li><p><strong>总线连接方式</strong></p>
<p>（现代计算机系统采用的方式）</p>
<p>通过一组总线（包括地址线、数据线、控制线），将所有的I/O设备和主机连接。</p>
<p>插件方式容易出现故障</p>
</li>
</ul>
<h3 id="四、I-O设备与主机信息传送的控制方式"><a href="#四、I-O设备与主机信息传送的控制方式" class="headerlink" title="四、I/O设备与主机信息传送的控制方式"></a>四、I/O设备与主机信息传送的控制方式</h3><blockquote>
<p>I/O与主机交换信息的控制方式有5种：程序查询方式、程序中断方式、直接存储器存取范式（DMA）、I/O通道方式、I/O处理机方式</p>
</blockquote>
<h4 id="1-程序查询方式"><a href="#1-程序查询方式" class="headerlink" title="1.程序查询方式"></a>1.程序查询方式</h4><blockquote>
<p>程序查询方式是由<strong>CPU通过程序不断查询I/O设备是否已做好准备</strong>，从而控制I/O设备与主机交换信息</p>
</blockquote>
<ul>
<li>又称为程序控制I/O方式</li>
<li>当需要输入/输出时，CPU暂停执行主程序，转去执行<strong>设备输入输出的服务程序（I/O指令编写成的程序）</strong>，根据服务程序中的I/O指令进行数据传送</li>
<li>CPU不断检查I/O设备是否准备就绪，踏步等待</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321151006980.png" alt="image-20220321151006980" style="zoom:67%;" /></p>
<blockquote>
<p>CPU读取I/O的状态，检查是否准备就绪</p>
<p>CPU需要等待I/O设备的输入输出</p>
<p>场景：（串行）</p>
<ul>
<li>食堂的读卡器，输入刷卡金额后，刷卡机等待刷卡交钱。</li>
<li>充电桩</li>
<li>蓝牙设备的连接（暂时不能确定）</li>
<li>键盘交互（屏幕上字符的输出显示取决于键盘上的输入，I/O和CPU之间速度相差大，使用programmed i/o进行同步工作）</li>
</ul>
</blockquote>
<h4 id="2-程序中断方式（重点内容）"><a href="#2-程序中断方式（重点内容）" class="headerlink" title="2.程序中断方式（重点内容）"></a>2.程序中断方式（重点内容）</h4><ul>
<li><p><strong>CPU和I/O部分的并行工作</strong></p>
<p>I/O工作$\begin{cases}自身准备:CPU不查询 \\与主机交换信息：CPU暂停现行程序 \end{cases}$</p>
</li>
<li><p><strong>中断请求信号</strong>——中断服务程序</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321152113200.png" alt="image-20220321152113200" style="zoom:67%;" /></p>
<p>CPU执行K条指令后，处理中断服务程序。回来后执行第K+1条指令。</p>
<p>需要考虑回来后的现场变化问题</p>
<blockquote>
<p>传输过程仍然需要CPU的参与，而且要保证程序中断后恢复现场，恢复指令。</p>
<p>需要指令完成现场的保护和恢复，消耗CPU较大的时间</p>
</blockquote>
<ul>
<li><p><strong>程序中断方式流程</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321152607588.png" alt="image-20220321152607588" style="zoom:67%;" /></p>
</li>
</ul>
<blockquote>
<p>应用场景：航天飞船的逃逸塔</p>
</blockquote>
<h4 id="3-DMA方式"><a href="#3-DMA方式" class="headerlink" title="3.DMA方式"></a>3.DMA方式</h4><blockquote>
<p>Direct Memory Access，直接存储器访问</p>
<p>I/O设备能直接与主存交换信息而不占用CPU，CPU的资源利用率可以进一步提升，这就出现了直接存储器存取（DMA）的方式</p>
</blockquote>
<ul>
<li>主存和I/O之间有一条直接数据通道</li>
<li>不中断现行程序</li>
<li>周期挪用（周期窃取）</li>
<li><strong>CPU和I/O外设并行工作</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321153333278.png" alt="image-20220321153333278" style="zoom:67%;" /></p>
<blockquote>
<p>一个存储字，读内存写外设/读外设写内存（性质取决于命令）</p>
<p>此时CPU关上地址、数据、控制信号（CPU不知道这些信号），DMA信号仍然保持，电源线不能关。——ch4存储器中总线的驱动和隔离</p>
</blockquote>
<p>在DMA方式中，主存与I/O设备之间有一条数据通路，主存与I/O设备交换信息时，无须调用中断程序。若出现DMA和CPU同时访问主存，CPU总是将总线占有权让给DMA，通常把DMA的这种占有称为窃取或挪用。</p>
<p>窃取的时间一般为一个存取周期，故把DMA占用的存取周期称为窃取周期或挪用周期。</p>
<p>采用DMA方式时，也需要增加必要的DMA接口电路。</p>
<h4 id="三种方式的CPU工作效率比较"><a href="#三种方式的CPU工作效率比较" class="headerlink" title="三种方式的CPU工作效率比较"></a>三种方式的CPU工作效率比较</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323164951791.png" alt="image-20220323164951791" style="zoom:80%;" /></p>
<ul>
<li>中断方式中，CPU为了程序正确执行，进行了现场保护</li>
</ul>
<h2 id="5-2-I-O接口"><a href="#5-2-I-O接口" class="headerlink" title="5.2 I/O接口"></a>5.2 I/O接口</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><blockquote>
<p>为什么要设置接口？</p>
</blockquote>
<ul>
<li>实现设备的选择</li>
<li>实现数据缓冲达到速度的匹配</li>
<li>实现数据串一并格式转换</li>
<li>实现电平转换</li>
<li>传送控制命令</li>
<li>反应设备的状态：忙、就绪、中断请求</li>
</ul>
<blockquote>
<p>CPU想知道什么，接口就提供什么</p>
</blockquote>
<h3 id="二、接口的功能和组成"><a href="#二、接口的功能和组成" class="headerlink" title="二、接口的功能和组成"></a>二、接口的功能和组成</h3><p>接口分为硬件和软件。有数据的输入和输出。</p>
<p>接口需要数字量，外部设备使用的物理形式需要接口把模拟量变成数字量。</p>
<p>控制对象到接口，接口到计算机。</p>
<ol>
<li><p><strong>总线连接方式的I/O接口电路</strong></p>
<p>设备选择线、数据线、命令线、状态线</p>
<blockquote>
<p>设备选择线：（如今不使用）找不同的I/O接口地址——如今使用地址线</p>
<p>状态线：变成设备状态线——现代计算机大多采用三态逻辑电路来构成总线</p>
<p>命令线：I/O读、I/O写（2条）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323170333994.png" alt="image-20220323170333994" style="zoom:80%;" /></p>
</li>
<li><p><strong>接口的功能和组成</strong></p>
<p>|        功能        |          组成          |<br>| :————————: | :——————————: |<br>|      选址功能      |      设备选择电路      |<br>|   传送命令的功能   | 命令寄存器、命令译码器 |<br>|   传送数据的功能   |     数据缓冲寄存器     |<br>| 反应设备状态的功能 |      设备状态标记      |</p>
<p>$\begin{cases} 完成触发器D\\ 工作触发器B\\ 中断请求触发器INTR\\ 屏蔽触发器MASK \end{cases}$</p>
</li>
<li><p><strong>I/O接口的基本组成</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323171031357.png" alt="image-20220323171031357" style="zoom: 67%;" /></p>
<blockquote>
<p>对于现代计算机，没有状态线</p>
<p>接口要有数据存放的地方：DBR</p>
<p>设备选择：对CPU送来的地址进行译码</p>
<p>集成化的接口：计时器</p>
</blockquote>
<ul>
<li><p>内部接口：内部接口与系统总线相连，实质上是与内存、CPU相连。并行传输</p>
</li>
<li><p>外部接口：外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式。因此外部接口需具有串/并转换功能</p>
</li>
</ul>
</li>
</ol>
<h3 id="三、接口类型"><a href="#三、接口类型" class="headerlink" title="三、接口类型"></a>三、接口类型</h3><ol>
<li><p>按数据<strong>传送方式</strong>分类</p>
<blockquote>
<p>并行接口：Intel 8255</p>
<p>串行接口：Intel 8251</p>
</blockquote>
</li>
<li><p>按功能<strong>选择的灵活性</strong>分类</p>
<p>可以选择是否编程</p>
<blockquote>
<p>可编程接口：Intel 8255、Intel 8251</p>
<p>不可编程接口：Intel 8212</p>
</blockquote>
</li>
<li><p>按<strong>通用性</strong>分类</p>
<p>通用：数据口</p>
<blockquote>
<p>通用接口：Intel 8255、Intel 8251</p>
<p>专用接口：Intel 8279、Intel 8275</p>
</blockquote>
</li>
<li><p>按数据传送的<strong>控制方式</strong>分类</p>
<blockquote>
<p>中断接口：Intel 8259</p>
<p>DMA接口：Intel 8257</p>
</blockquote>
</li>
</ol>
<h2 id="5-4-程序查询方式"><a href="#5-4-程序查询方式" class="headerlink" title="5.4 程序查询方式"></a>5.4 程序查询方式</h2><h3 id="一、程序查询流程"><a href="#一、程序查询流程" class="headerlink" title="一、程序查询流程"></a>一、程序查询流程</h3><ul>
<li><strong>优先级排序</strong></li>
<li>计数值</li>
</ul>
<ol>
<li><p><strong>查询流程</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323180258354.png" alt="image-20220323180258354" style="zoom:67%;" /></p>
</li>
<li><p><strong>程序流程</strong></p>
<blockquote>
<p>首先知道数据的个数、首地址。外部设备要启动。CPU盯住外设是否准备好</p>
<p>准备好：对于输入，B=0，D=1；对于输出，B=1，D=0</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323180421204.png" alt="image-20220323180421204" style="zoom:67%;" /></p>
</li>
</ol>
<h3 id="二、程序查询方式接口电路"><a href="#二、程序查询方式接口电路" class="headerlink" title="二、程序查询方式接口电路"></a>二、程序查询方式接口电路</h3><p>不仅要有电路，还要有程序，均比较简单。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220323172434127.png" alt="image-20220323172434127" style="zoom: 67%;" /></p>
<blockquote>
<p>①启动命令（1）送至与非门。CPU通过I/O地址线选择设备（SEL高电平，1），通过与非门变成0，完成触发器D置0（0-没准备好），工作触发器B置1；</p>
<p>②B置1数据输出，外部设备启动；</p>
<p>③I/O设备的输入数据串行进入DBR，外设写数据到接口；</p>
<p>④驱动B触发器的置1信号和D的置0信号翻转，设备工作结束；</p>
<p>⑤D的1信号输出</p>
<p>⑥数据线把数据送出接口</p>
</blockquote>
<p>指令需要多少个I/O地址才能实现——3</p>
<p>通过什么命令发送过来——IN命令</p>
<p>数据CPU通过什么读回去——数据线，配合$\overline{IOW}$</p>
<p>假如变成<strong>输出</strong>（倒序）</p>
<blockquote>
<p>①CPU写入接口，把数据送入DBR</p>
<p>②CPU启动外设工作，选中设备，启动命令。使两个触发器置位。启动外部设备</p>
<p>③外部设备从DBR读出数据</p>
<p>④外设对工作触发器的状态改变，翻转。</p>
<p>⑤D变成1，告诉CPU可以继续写（覆盖DBR的数据）</p>
</blockquote>
<p>总结：输入方式准备好的信号状态D是1，没准备好是0。对于输出设备准备好（DBR中的数据已经送给外部设备。CPU可以再次输入）D是0，没准备好是1</p>
<blockquote>
<p>问题：</p>
<p>①如何使D触发器置0？原理是什么？</p>
<p>——启动命令有效（<strong>IN指令</strong>）并且地址线上代码与设备选择电路</p>
<p>对于输出</p>
<p>①启动命令和地址线是为了给出一个状态——给D送0。</p>
<p>——在CPU和D之间加入一个三态门，把D的地址流向CPU</p>
<p><a href="https://blog.csdn.net/sinat_41653350/article/details/106018051">双向三态门的使用</a></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220328163256387.png" alt="image-20220328163256387" style="zoom:67%;" /></p>
<blockquote>
<p>指令需要三个地址</p>
<p>第16位地址</p>
</blockquote>
<ul>
<li><p>例题1</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329194300129.png" alt="image-20220329194300129" style="zoom: 67%;" /></p>
<blockquote>
<p>例1的解答：按照I/O地址的要求设置反相器（地址为0则使用反相器），由于是输出，最后和$\overline{IOW}$相与，输出作为74LS244三态门电路的使能信号，控制CPU向外设输出的通和断。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329192540421.png" alt="image-20220329192540421" style="zoom: 67%;" /></p>
</li>
<li><p>例2</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329193023506.png" alt="image-20220329193023506" style="zoom:80%;" /></p>
<blockquote>
<p>例2解答：设计思路与例1相同。但是需要注意锁存，使用74LS373（8D锁存器）对输出进行锁存</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329193219199.png" alt="image-20220329193219199" style="zoom:67%;" /></p>
</li>
<li><p>例3&amp;例4</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329193642564.png" alt="image-20220329193642564" style="zoom:80%;" /></p>
<blockquote>
<p>解题思路：设计原则与例1、例2相同。</p>
<p>注意是1位输出，把一根数据线接入即可。</p>
</blockquote>
</li>
<li><p>例5&amp;例6</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329193815045.png" alt="image-20220329193815045" style="zoom: 67%;" /></p>
<blockquote>
<p>解题思路：注意是输入接口。</p>
<p>有两点变化：①三态门的方向要反过来：从CPU到I/O；②CPU上的控制信号变成了$\overline{IOR}$</p>
<p>下图中，左为例5答案，右为例6答案</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329194135388.png" alt="image-20220329194135388" style="zoom:80%;" /></p>
</li>
</ul>
<blockquote>
<p>改造接口：使D触发器变0。使用读控制。读数据需要地址译码和读控制</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329194443285.png" alt="image-20220329194443285" style="zoom:80%;" /></p>
<p>程序查询在TEST1中踏步等待</p>
<p>输出的改进：CPU把数据写入锁存器。三态门和锁存器的方向调过来，数据的进和出方向相反</p>
</blockquote>
<h2 id="5-5-程序中断方式"><a href="#5-5-程序中断方式" class="headerlink" title="5.5 程序中断方式"></a>5.5 程序中断方式</h2><h3 id="一、中断的概念"><a href="#一、中断的概念" class="headerlink" title="一、中断的概念"></a>一、中断的概念</h3><p>计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序，这就是<strong>中断</strong></p>
<blockquote>
<p>处理异常情况或特殊请求：中断服务程序</p>
<p>间断处：断点</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329201649521.png" alt="image-20220329201649521" style="zoom: 80%;" /></p>
<blockquote>
<p>中断方式可以告诉CPU时间片的信息——OS课程中内容</p>
<p>应用场景举例——消防采样：烟雾浓度、温度。检测异常后（中断源、断点），报警的同时启动消防设备（中断服务程序）</p>
</blockquote>
<h3 id="二、中断的产生"><a href="#二、中断的产生" class="headerlink" title="二、中断的产生"></a>二、中断的产生</h3><ul>
<li><p>由中断源产生（<strong>部分并行工作</strong>）</p>
</li>
<li><p>以打印机为例，CPU与打印机并行工作</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329201741586.png" alt="image-20220329201741586" style="zoom:67%;" /></p>
</li>
</ul>
<h3 id="三、程序中断方式的接口电路"><a href="#三、程序中断方式的接口电路" class="headerlink" title="三、程序中断方式的接口电路"></a>三、程序中断方式的接口电路</h3><ol>
<li><p>配置<strong>中断请求触发器</strong>(INTR)和<strong>中断屏蔽触发器</strong>(MASK)</p>
<blockquote>
<p>，是一个D触发器</p>
</blockquote>
<p>检查设备就绪（对于输入，<strong>D=1</strong>，数据已经到达DBR。对于输出，D=1，外设已经取走数据，CPU可以继续输出），且设备未被屏蔽（<strong>MASK=0</strong>，因此输出$\overline{Q}=1$），CPU的中断查询信号可将中断请求触发器置“1”（<strong>INTR=1</strong>）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220328173752751.png" alt="image-20220328173752751" style="zoom:80%;" /></p>
<p>对于INTR，使能的信号是来自CPU的中断查询信号</p>
</li>
<li><p><strong>排队器</strong></p>
<p>中断优先级低的要等待，优先级高的可以及时被CPU响应</p>
<ul>
<li>硬件：在CPU内或在接口电路中（链式排队器）</li>
<li>软件：详见第八章</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220328174231278.png" alt="image-20220328174231278" style="zoom:80%;" /></p>
<blockquote>
<p>前边的优先级高，可以锁住/屏蔽后面优先级低的设备</p>
</blockquote>
</li>
<li><p><strong>中断向量地址形成部件</strong></p>
<ul>
<li><p>入口地址——找到终端服务程序的位置，第一个</p>
<ul>
<li><p>由软件产生</p>
</li>
<li><p>硬件向量法：由<strong>硬件</strong>产生<strong>向量地址</strong>，再由<strong>向量地址</strong>找到<strong>入口地址</strong></p>
<blockquote>
<p>中断向量地址形成部件是一个编码器——设备编码器</p>
<p>现代计算机可以编出8位二进制数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220328174918285.png" alt="image-20220328174918285" style="zoom:80%;" /></p>
<blockquote>
<p>JMP200：告诉CPU跳转到200的入口地址执行程序</p>
<p>由RAM芯片（留有用户的接口）控制。每一次系统部分由BIOS基本操作系统负责引导到中断服务程序。用户变成交给系统填写向量表</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>程序中断方式接口电路的基本组成</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329201944273.png" alt="image-20220329201944273" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="四、I-O中断处理过程"><a href="#四、I-O中断处理过程" class="headerlink" title="四、I/O中断处理过程"></a>四、I/O中断处理过程</h3><ol>
<li><p>CPU响应中断的条件和时间</p>
<ul>
<li><p><strong>条件</strong>：<strong>允许中断触发器EINT=1</strong></p>
<blockquote>
<p>CPU有一个对所有中断控制的寄存器</p>
</blockquote>
<p>用<strong>开中断</strong>指令将EINT置“1”</p>
<blockquote>
<p>STI——详见汇编语言</p>
</blockquote>
<p><strong>关中断</strong>置“0”或自动复位</p>
<blockquote>
<p>CLI：将中断允许触发器清零</p>
<p>自动复位：计算机加电启动，中断允许触发器自动关上置零——外围设备都没有初始化。防止未填向量表，没有中断程序的情况下响应中断请求信号</p>
</blockquote>
</li>
<li><p><strong>时间</strong>：当D=1（随机）且MASK=0时</p>
<p>在<strong>每条指令执行阶段的结束</strong>，CPU<strong>发中断查询信号</strong>（将INTR置“1”）</p>
<blockquote>
<p>ch7，间指周期</p>
</blockquote>
</li>
</ul>
</li>
<li><p>I/O中断处理过程——已经集成到硬件中，中断控制器8259A</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329202340978.png" alt="image-20220329202340978" style="zoom:80%;" /></p>
<blockquote>
<p>当CPU通过I/O指令的地址码选中某设备后，则</p>
<p>①由CPU发启动I/O设备指令，将接口中的B置“1”，D置“0”；</p>
<p>②接口启动输入设备；</p>
<p>③输入设备将数据送入数据缓冲存储器DBR；</p>
<p>④输入设备向接口发出 ”设备工作结束“信号，B置”0“，D置”1“，标志设备准备就绪；</p>
<p>⑤当设备准备就绪（D=1），且本设备未被屏蔽时（MASK=0）时，在指令执行阶段的结束时刻，由CPU发出中断查询信号；</p>
<p>⑥设备中断请求触发器INTR被置”1”，标志设备向CPU提出<strong>中断请求</strong>。与此同时，INTR送至排队器，进行<strong>中断判优</strong>；</p>
<p>⑦若CPU中断允许（EINT=1），设备又被排队选中，即进入<strong>中断响应</strong>阶段，由中断响应信号INTA将排队器输出送至编码器形成的向量地址；</p>
<p>⑧向量地址送至PC，作为下一条指令的地址；</p>
<p>⑨由于向量地址中存放的是一条无条件转移指令（<strong>JMP</strong> XXX），故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进入<strong>中断服务阶段</strong>，通过输入指令将数据缓冲存储器DBR中的输入数据送至CPU的通用寄存器，再存入主存相关单元；</p>
<p>⑩中断服务的最后一条指令是中断返回指令，当其执行结束时，即<strong>中断返回</strong>至原程序的断点处。至此，一个完整的程序中断处理过程即告结束。</p>
</blockquote>
</li>
</ol>
<p>注意：DBR不能直接连接数据总线。如果DBR是数据寄存器，直接连接会导致数据总线被外设钳制住，。因此需要三态门断开，通过I/O地址执行IN指令。</p>
<p>向量地址从数据线接入。数据值是一个中断类型</p>
<h4 id="关于中断允许触发器（EINT）和中断屏蔽触发器（MASK）"><a href="#关于中断允许触发器（EINT）和中断屏蔽触发器（MASK）" class="headerlink" title="关于中断允许触发器（EINT）和中断屏蔽触发器（MASK）"></a>关于中断允许触发器（EINT）和中断屏蔽触发器（MASK）</h4><p>参考资料：<a href="https://www.zhihu.com/question/320290174">关于允许中断触发器和中断屏蔽触发器的疑问？</a></p>
<p><strong>EINT</strong>：CPU对中断请求的总控制</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220402094720119.png" alt="image-20220402094720119" style="zoom:67%;" /></p>
<p><strong>MASK</strong>：处理每个具体端口的中断请求</p>
<blockquote>
<p>I/O端口：接口电路中可以被CPU直接访问的寄存器</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220402094822192.png" alt="image-20220402094822192" style="zoom:67%;" /></p>
<h3 id="五、中断服务程序流程"><a href="#五、中断服务程序流程" class="headerlink" title="五、中断服务程序流程"></a>五、中断服务程序流程</h3><p>1.<strong>保护现场</strong></p>
<p>程序断点的保护（包括程序执行状态）——中断隐指令完成（<strong>中断周期，一系列操作</strong>，在指令系统中不存在，但是相当于指令的功能：开中断、关中断、向量地址采样相当于读数）</p>
<p>寄存器内容的保护：（防止内容改变而出错）进栈指令</p>
<blockquote>
<p>具体而言，可在中断服务的起始部分安排若干条存数指令，将寄存器的内容存至存储器中保存，或用进栈指令（PUSH）将各寄存器的内容推入堆栈保存。</p>
<p>涉及通用寄存器和状态寄存器</p>
</blockquote>
<p>2.<strong>中断服务</strong></p>
<p>中断程序的主体部分，对不同的I/O设备具有不同内容的设备服务。</p>
<p>（事先编好，设置到计算机中，可以找到）</p>
<blockquote>
<p>例如，打印机要求CPU将需打印的一行字符代码，通过接口送入打印机的缓冲存储器中；</p>
<p>又如，设备要求CPU将需显示的一行字符代码通过接口送入显示器的显示存储器中。</p>
</blockquote>
<p>3.<strong>恢复现场</strong>：出栈命令</p>
<blockquote>
<p>要求再推出服务程序前，将原程序中断时的“现场”恢复到原来的寄存器中。</p>
<p>通常可以用取数指令或出栈指令（POP），将保存在存储器或堆栈中的信息送到原来的寄存器中。</p>
</blockquote>
<p>4.<strong>中断返回</strong>：中断返回指令</p>
<blockquote>
<p>使其返回到原程序的断点处，以便继续执行原程序。</p>
<p>汇编语言中的iret指令</p>
</blockquote>
<p><strong>目前已经知道三条指令：开中断、关中断、中断返回</strong></p>
<ul>
<li><p>单重中断和多重中断</p>
<ul>
<li>单重中断：不允许中断现行的中断服务程序</li>
<li>多重中断：允许级别更高的中断源（嵌套）</li>
<li><strong>其区别在于”开中断”的设置时间不同</strong></li>
</ul>
<p>中断从中断周期（中断隐指令）开始</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330171310628.png" alt="image-20220330171310628" style="zoom:80%;" /></p>
<blockquote>
<p>开中断使EINT=1，表示允许中断，</p>
<p>中断周期（3件事，没有中断响应）：CPU中寄存器EINT=1响应，程序的地址保存再指令寄存器中，最后EINT=0关闭</p>
<p>中断隐指令中快速，硬件时间。服务程序中的开中断是软件时间，更慢</p>
</blockquote>
<p>多重中断在结束开始中断服务后，保护现场后先开中断</p>
<blockquote>
<p>注：若不开中断，会影响后面中断请求的响应（INTA）</p>
</blockquote>
</li>
<li><p>宏观上CPU与I/O并行工作</p>
</li>
<li><p>微观上CPU中断现行程序，为I/O服务</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330173009516.png" alt="image-20220330173009516" style="zoom: 80%;" /></p>
<blockquote>
<p>$A_0$可以对应两个I/O地址——0020H和0021H</p>
<p>$\overline{INTA}$：中断允许信号线</p>
<p>中断屏蔽寄存器：写“1”即为屏蔽</p>
</blockquote>
<p>（跳转到ch8）</p>
<p>关于中断的补充资料：</p>
<p>中断分类</p>
<p>软件中断：由OS发出的指令</p>
<p>中断系统要解决的问题</p>
<ol>
<li><p>如何产生中断？如何准备好信号？</p>
</li>
<li><p>允许/禁止中断源发/不发中断？</p>
</li>
<li><p>中断请求方式（电平触发/边缘型）？——边沿触发</p>
</li>
<li><p>识别信息送到CPU加以识别——中断类型</p>
</li>
<li><p>如何处理可屏蔽和非可屏蔽中断</p>
</li>
<li><p>如何实现多个中断源的优先级确定？——优先级排队（中断控制器，常选择固定优先级）</p>
<p>ch8.中断固定</p>
</li>
<li><p>防止外设中断、不被重复响应——边沿触发</p>
</li>
<li><p>如何处理更高级别？——</p>
</li>
<li><p>管理CPU的可屏蔽中断的响应和禁止？——中断控制</p>
</li>
<li><p>寻找入口</p>
</li>
</ol>
<p>整个中断服务程序过程中是软件执行</p>
<p>ip偏移量，cs代码段</p>
<p>软件堆栈：使用内存空间</p>
<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><h3 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h3><ol>
<li><p>引起中断的各种因素</p>
<ul>
<li><p>人为设置的中断——OS</p>
<blockquote>
<p>如，转管指令</p>
<p>int21是对硬盘的操作</p>
</blockquote>
</li>
<li><p>程序性事故</p>
<blockquote>
<p>溢出、操作码不能识别、除法非法</p>
</blockquote>
</li>
<li><p>硬件故障</p>
</li>
<li><p>I/O设备</p>
</li>
<li><p>外部事件</p>
<blockquote>
<p>用<strong>键盘中断</strong>现行程序</p>
</blockquote>
</li>
</ul>
</li>
<li><p>中断系统需解决的问题</p>
<ul>
<li>各中断源如何向CPU提出请求？</li>
<li>各中断源同时提出请求怎么办？</li>
<li>CPU什么条件、什么时间、以什么方式响应中断？</li>
<li>如何保护现场？</li>
</ul>
<blockquote>
<p>硬件+软件</p>
</blockquote>
</li>
</ol>
<h3 id="二、中断请求标记和中断判优逻辑"><a href="#二、中断请求标记和中断判优逻辑" class="headerlink" title="二、中断请求标记和中断判优逻辑"></a>二、中断请求标记和中断判优逻辑</h3><ol>
<li><p>中断请求标记：INTR</p>
<p>一个请求源，一个INTR中断请求标记触发器</p>
<p>多个INTR——组成中断请求标记寄存器</p>
<p>INTR分散在各个</p>
</li>
<li><p>中断判优逻辑</p>
<ul>
<li><p>硬件实现（排队器）</p>
<p>①分散在各个中断源的接口电路中，链式排队器</p>
<p>②集中在CPU内</p>
</li>
<li><p>软件实现（程序查询）</p>
<p>A、B、C优先级按降序排列</p>
<blockquote>
<p>寄存器读到CPU中，一个一个查询</p>
<p>电路简单，但是速度慢</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="三、中断服务程序入口地址的寻找"><a href="#三、中断服务程序入口地址的寻找" class="headerlink" title="三、中断服务程序入口地址的寻找"></a>三、中断服务程序入口地址的寻找</h3><ol>
<li>硬件向量法</li>
<li>软件查询法</li>
</ol>
<h3 id="四、中断响应"><a href="#四、中断响应" class="headerlink" title="四、中断响应"></a>四、中断响应</h3><ol>
<li><p>响应中断的条件</p>
<p>允许中断触发器EINT=1</p>
</li>
<li><p>响应中断的时间</p>
<p>指令执行周期结束时刻由CPU发查询信号</p>
</li>
<li><p>中断隐指令</p>
<ul>
<li><p>保护程序断点</p>
<blockquote>
<p>早期计算机，断点存于<strong>特定地址（0号地址）</strong>，断点进栈</p>
</blockquote>
</li>
<li><p>寻找服务程序入口地址</p>
<blockquote>
<p>向量地址——PC</p>
<p>中断识别程序入口地址M——PC</p>
</blockquote>
</li>
<li><p>硬件关中断</p>
</li>
</ul>
</li>
</ol>
<h3 id="五、保护现场和恢复现场"><a href="#五、保护现场和恢复现场" class="headerlink" title="五、保护现场和恢复现场"></a>五、保护现场和恢复现场</h3><ol>
<li>保护现场</li>
<li>恢复现场</li>
</ol>
<h3 id="六、中断屏蔽技术（不讲）"><a href="#六、中断屏蔽技术（不讲）" class="headerlink" title="六、中断屏蔽技术（不讲）"></a>六、中断屏蔽技术（不讲）</h3><h2 id="5-6-DMA方式"><a href="#5-6-DMA方式" class="headerlink" title="5.6 DMA方式"></a>5.6 DMA方式</h2><p>纯硬件实现</p>
<h3 id="一、DMA方式的特点"><a href="#一、DMA方式的特点" class="headerlink" title="一、DMA方式的特点"></a>一、DMA方式的特点</h3><ol>
<li><p><strong>DMA和程序中断两种方式的数据通路</strong></p>
<p>程序中断要等待CPU做出中断响应后再进行，很可能因此使数据丢失，</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330153935007.png" alt="image-20220330153935007" style="zoom:80%;" /></p>
</li>
<li><p><strong>DMA与主存交换数据的三种方式</strong></p>
<ul>
<li><p><strong>停止CPU访问主存</strong></p>
<blockquote>
<p>控制简单</p>
<p>CPU处于不工作状态或保持状态</p>
<p>未充分发挥CPU对主存的利用率</p>
</blockquote>
<p>微机常用</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330154137617.png" alt="image-20220330154137617" style="zoom:80%;" /></p>
</li>
<li><p><strong>周期挪用（周期窃取）</strong></p>
<blockquote>
<p>DMA访问主存有3种可能</p>
<ul>
<li>CPU此时不访存</li>
<li>CPU正在访存</li>
<li>CPU与DMA同时请求访存</li>
</ul>
<p>此时<strong>CPU将总线控制权让给DMA</strong></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330154400184.png" alt="image-20220330154400184" style="zoom:80%;" /></p>
</li>
<li><p><strong>DMA与CPU交替访问</strong></p>
<blockquote>
<p>CPU工作周期$\begin{cases} C_1专供DMA访存 \\ C_2专供CPU访存 \\ \end{cases}$</p>
<p>工作周期：<strong>所有指令执行过程中的一个基准时间</strong></p>
</blockquote>
<p>缺点：DMA可能不是很忙。但是存储器每次都要固定把时间分给DMA和CPU，会降低存储器工作速度。——只适合大型机，不适合微机</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330155111776.png" alt="image-20220330155111776" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ol>
<h3 id="二、DMA接口的功能和组成"><a href="#二、DMA接口的功能和组成" class="headerlink" title="二、DMA接口的功能和组成"></a>二、DMA接口的功能和组成</h3><h4 id="1-DMA接口功能"><a href="#1-DMA接口功能" class="headerlink" title="1.DMA接口功能"></a>1.DMA接口功能</h4><blockquote>
<p>不通过指令完成</p>
</blockquote>
<ul>
<li><p>向CPU<strong>申请</strong>DMA传送</p>
</li>
<li><p><strong>处理总线控制权</strong>的转交</p>
</li>
<li><p><strong>管理</strong>系统总线、<strong>控制</strong>数据传送</p>
<blockquote>
<p>四条指令：读内存、写外设、读外设、写内存</p>
</blockquote>
</li>
<li><p><strong>确定</strong>数据传送的<strong>首地址和长度</strong>，<strong>修正</strong>传送过程中的数据<strong>地址</strong>和<strong>长度</strong></p>
</li>
<li><p>DMA传送结束时，<strong>给出操作完成信号</strong></p>
</li>
</ul>
<h4 id="2-DMA接口组成"><a href="#2-DMA接口组成" class="headerlink" title="2.DMA接口组成"></a>2.DMA接口组成</h4><blockquote>
<p>DREQ：设备向DMA接口提出申请</p>
<p>HRQ：DMA控制逻辑向CPU请求DMA服务，发出总线使用权请求信号</p>
<p>HLDA：CPU发出的响应信号</p>
<p>DACK：通知设备已经被赋予一个DMA周期</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330155311386.png" alt="image-20220330155311386" style="zoom:80%;" /></p>
<ol>
<li><p><strong>主存地址寄存器（AR, address register）</strong></p>
<p>AR用于存放主存中需要交换数据的地址。</p>
<p>可+1</p>
</li>
<li><p><strong>字计数器（WC, word count）</strong></p>
<p>WC用于记录传送数据的总字节数。</p>
<p>可+1或-1</p>
</li>
<li><p><strong>数据缓冲寄存器（BR, buffer register）</strong></p>
<p>BR用于暂存每次传送的数据。</p>
</li>
<li><p><strong>DMA控制逻辑（Control Logic）</strong></p>
<p>DMA控制逻辑负责管理DMA的传送过程，由控制电路、时序电路及命令状态控制寄存器等组成。</p>
</li>
<li><p><strong>中断机构</strong></p>
<p>当字计数器溢出（全“0”）时，表示一批数据交换完毕，由“溢出信号”通过中断机构向CPU提出中断请求，请求CPU作DMA操作的后处理。</p>
</li>
<li><p><strong>设备地址寄存器（MAR）</strong></p>
<p>DAR存放I/O设备的设备码或表示设备信息存储区的寻址信息。</p>
</li>
</ol>
<h4 id="三、DMA的工作过程"><a href="#三、DMA的工作过程" class="headerlink" title="三、DMA的工作过程"></a>三、DMA的工作过程</h4><h5 id="1-DMA传送过程"><a href="#1-DMA传送过程" class="headerlink" title="1.DMA传送过程"></a>1.DMA传送过程</h5><blockquote>
<p>预处理、数据传送、后处理</p>
</blockquote>
<p>①<strong>预处理</strong></p>
<blockquote>
<p>在CPU中进行处理。开机后对外部设备初始化写入，在DMA申请总线之前</p>
</blockquote>
<p>通过DMA控制逻辑传送方向（入/出）</p>
<ul>
<li>设备地址$\to$ DMA的DAR</li>
<li>主存地址$\to$ DMA的AR</li>
<li>传送字数$\to$ DMA的WC</li>
</ul>
<p>②<strong>数据传送</strong></p>
<ul>
<li><p>数据传送示意图</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330155645114.png" alt="image-20220330155645114" style="zoom:80%;" /></p>
</li>
<li><p>数据传送过程（输入）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330155724136.png" alt="image-20220330155724136" style="zoom:80%;" /></p>
</li>
<li><p>数据传送过程（输出）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330155803168.png" alt="image-20220330155803168" style="zoom:80%;" /></p>
</li>
</ul>
<p>③<strong>后处理</strong></p>
<ul>
<li><p>校验送入主存的数是否正确</p>
</li>
<li><p>是否继续用DMA</p>
</li>
<li><p>测试传送过程是否正确，错则转诊断程序</p>
</li>
</ul>
<p><strong>由中断服务程序完成</strong>——不需要保留现场和恢复</p>
<h5 id="2-DMA接口与系统的连接方式"><a href="#2-DMA接口与系统的连接方式" class="headerlink" title="2.DMA接口与系统的连接方式"></a>2.DMA接口与系统的连接方式</h5><ul>
<li><p><strong>具有公共请求线的DMA请求</strong></p>
<p>优先级排序</p>
<p>参考ch3中的链式查询方式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330160031796.png" alt="image-20220330160031796" style="zoom:80%;" /></p>
</li>
<li><p><strong>独立的DMA请求</strong></p>
<p>CPU内部排序，参考第三章的独立请求方式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330160054294.png" alt="image-20220330160054294" style="zoom:80%;" /></p>
</li>
</ul>
<h5 id="DMA方式与程序中断方式的比较"><a href="#DMA方式与程序中断方式的比较" class="headerlink" title="DMA方式与程序中断方式的比较"></a>DMA方式与程序中断方式的比较</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">中断方式</th>
<th style="text-align:center">DMA方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>数据传输</strong></td>
<td style="text-align:center">程序</td>
<td style="text-align:center">硬件</td>
</tr>
<tr>
<td style="text-align:center"><strong>响应时间</strong></td>
<td style="text-align:center">指令执行结束</td>
<td style="text-align:center">存取周期结束</td>
</tr>
<tr>
<td style="text-align:center"><strong>处理异常情况</strong></td>
<td style="text-align:center">能</td>
<td style="text-align:center">不能</td>
</tr>
<tr>
<td style="text-align:center"><strong>中断请求</strong>（完成的任务）</td>
<td style="text-align:center">传送数据</td>
<td style="text-align:center">后处理</td>
</tr>
<tr>
<td style="text-align:center"><strong>优先级</strong></td>
<td style="text-align:center">低（可屏蔽中断）</td>
<td style="text-align:center">高</td>
</tr>
</tbody>
</table>
</div>
<h4 id="DMA接口的类型"><a href="#DMA接口的类型" class="headerlink" title="DMA接口的类型"></a>DMA接口的类型</h4><ul>
<li><p>选择型</p>
<p>在物理上连接多个设备，在逻辑上只允许连接一个设备</p>
</li>
<li><p>多路型</p>
<p>在物理上连接多个设备，在逻辑上允许连接多个设备同时工作</p>
</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>computer organization</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理：第4章 存储器</title>
    <url>/computer_organization/computer-organization-ch4/</url>
    <content><![CDATA[<p>需要掌握功能特性（外特性）</p>
<p>内存：使用什么芯片计算机可以直接访问 $\begin{cases} RAM \\ ROM \\ \end{cases}$</p>
<span id="more"></span>
<p>随机访问</p>
<p>存储器设计：</p>
<ul>
<li>设计-容量（按规定）</li>
<li>调试、证明</li>
<li>速度提高</li>
<li>可靠性4.1 概述</li>
</ul>
<p>【问题】</p>
<ol>
<li>存储器可分为哪些类型？</li>
<li>现代存储器的层次结构，为什么要分层？</li>
</ol>
<h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="一、存储器分类"><a href="#一、存储器分类" class="headerlink" title="一、存储器分类"></a>一、存储器分类</h3><h4 id="1-按存储介质分类"><a href="#1-按存储介质分类" class="headerlink" title="1.按存储介质分类"></a>1.按存储介质分类</h4><ul>
<li><p>半导体存储器（内存条芯片、U盘）——<strong>易失</strong></p>
<blockquote>
<p>TTL（集成度低，功耗高，高速）、MOS（主要）</p>
</blockquote>
</li>
<li><p>磁表面存储器（磁盘、磁带）——不易失</p>
<blockquote>
<p>基片表面磁层，分成若干个同心圆（磁道），分成若干个扇区（几百几K）</p>
</blockquote>
</li>
<li><p>磁芯存储器——不易失</p>
<blockquote>
<p>（1948，王安）</p>
<p>磁芯里面有导线，在电流作用下磁化，用于保存两个状态。硬磁材料、环状元件。</p>
</blockquote>
</li>
<li><p>光盘存储器——激光、磁光材料</p>
</li>
</ul>
<h4 id="2-按存取方式分类"><a href="#2-按存取方式分类" class="headerlink" title="2.按存取方式分类"></a>2.按存取方式分类</h4><ul>
<li><p>存取时间与物理地址无关（<strong>随机访问</strong>）</p>
<ul>
<li><p>随机存储器（$RAM$, Random Access Memory）：在程序执行过程中<strong>可读/可写</strong></p>
<blockquote>
<p>存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关</p>
<p>计算机系统的主存采用这种随机存储器</p>
</blockquote>
<p>$根据存储信息原理不同\begin{cases} 静态RAM（SRAM,static RAM）\\ \qquad ——以触发器原理寄存信息 ——Cache \\ 动态RAM（DRAM, dynamic RAM）\\ \qquad ——以电容充放电原理寄存信息——主存 \end{cases}$</p>
</li>
<li><p>只读存储器（$ROM$, Read Only Memory）：在程序执行过程中<strong>只读</strong></p>
<blockquote>
<p>能对其存储的内容读出，而不能对其重新写入的存储器。</p>
<p>一旦存储了原始信息后，在程序执行过程中，只能将内部信息读出，而不能随意重新写入新的信息去改变原始信息。</p>
<p>通常存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。——BIOS，基本操作系统，初始化程序、检测程序（故障检测）</p>
</blockquote>
<p>它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。</p>
<p>$\begin{cases} 掩膜型只读存储器 \\（MROM, \ Masked \ ROM）\\ 可编程只读存储器 \\（PROM, \ Programmable \ ROM）\\ —— 烧录一次\\ 可擦除可编程只读存储器 \\（EPROM,\ Erasable \ Programmable \ ROM）\\ ——使用紫外线照射可以擦除。可擦写10000次以上 \\ 用电可擦除可编程只读存储器 \\（EEPROM,\ Electrically \ Erasable \  Programmable \ ROM） \\  —— 可再现（计算机攻击、病毒）\end{cases}$</p>
<p>闪速存储器（Flash Memory）：具有EEPROM的特点，而速度比EEPROM快得多</p>
</li>
</ul>
</li>
<li><p>存取时间与物理地址有关（串行访问）</p>
<ul>
<li><p>顺序存取存储器——磁带</p>
<blockquote>
<p>无论信息处在哪个位置，读/写必须从其介质的始端开始按顺序寻找</p>
</blockquote>
</li>
<li><p>直接存取存储器——磁盘</p>
<blockquote>
<p>属于部分串行访问的存储器</p>
<p>在对磁盘读/写时，首先直接指出该存储器中的某个小区域（<strong>磁道</strong>），然后再按顺序寻访，直到找到位置</p>
<p>前段是直接访问，后段是串行访问</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="3-按在计算机中的作用分类"><a href="#3-按在计算机中的作用分类" class="headerlink" title="3.按在计算机中的作用分类"></a>3.按在计算机中的作用分类</h4><ul>
<li><strong>主存储器</strong>（主存）：可以和CPU直接交换信息</li>
<li><strong>辅助存储器</strong>（辅存）：主存的后援存储器，用来存放当前暂时不用的程序和数据，不能与CPU直接交换信息</li>
<li><strong>缓冲存储器</strong>（缓存）：用在两个速度不同的部件之中</li>
</ul>
<blockquote>
<p>CPU与主存之间可设置一个高速缓存（Cache），起到缓冲作用——SRAM，存取速度快、价格更昂贵、集成度较低</p>
<p>DRAM一般用于主存储器</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220113103102291.png" alt="image-20220113103102291" style="zoom: 67%;" /></p>
<h3 id="二、存储器的层次结构"><a href="#二、存储器的层次结构" class="headerlink" title="二、存储器的层次结构"></a>二、存储器的层次结构</h3><h4 id="1-存储器三个主要特性的关系"><a href="#1-存储器三个主要特性的关系" class="headerlink" title="1.存储器三个主要特性的关系"></a>1.存储器三个主要特性的关系</h4><p>速度、容量、价格/位</p>
<blockquote>
<p>寄存器分组成堆，彼此之间不产生冲突</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132012588.png" alt="image-20220302132012588" style="zoom:67%;" /></p>
<h4 id="2-缓存-主存层次和主存-辅存层次（存储体系）"><a href="#2-缓存-主存层次和主存-辅存层次（存储体系）" class="headerlink" title="2.缓存-主存层次和主存-辅存层次（存储体系）"></a>2.缓存-主存层次和主存-辅存层次（存储体系）</h4><p>程序的局部性原理</p>
<ul>
<li><p>缓存-主存层次</p>
<ul>
<li><p>主要解决<strong>CPU和主存速度不匹配</strong>的问题。</p>
</li>
<li><p>缓存速度比主存高。将CPU近期要用的信息<strong>调入缓存</strong>，CPU便可以直接从缓存中获取信息，从而提高访存的速度。</p>
</li>
<li><p><strong>缓存容量小</strong>，需要不断将主存的内容调入缓存，使缓存中原来的信息被替换掉</p>
</li>
<li>主存和缓存的数据调动是<strong>硬件自动完成</strong>的，对程序员透明</li>
<li>使用了缓存的速度，容量和价位接近于主存</li>
</ul>
</li>
<li><p>主存-辅存层次</p>
<ul>
<li>主要解决<strong>存储系统容量</strong>的问题</li>
<li>辅存的速度比主存低，而且不能和CPU直接交换信息。但<strong>容量比主存大得多，可以存放大量暂时没有用到的信息</strong>。当CPU需要用这些信息时，再<strong>将辅存的内容调到主存</strong>，供CPU直接访问</li>
<li>主存和辅存之间的数据调动是由<strong>硬件和操作系统共同完成</strong>的——I/O线</li>
<li>使用了主存的速度，容量和价位接近于辅存</li>
</ul>
</li>
<li><p>主存-辅存层次逐渐形成了虚拟存储系统</p>
<p>（计算机体系结构、操作系统）</p>
<ul>
<li>程序员<strong>编程的地址范围</strong>与<strong>虚拟存储器的地址空间</strong>相对应</li>
</ul>
<blockquote>
<p>指令地址码——虚地址（虚存地址、虚拟地址）或逻辑地址</p>
<p>主存的实际地址——物理地址或实地址</p>
</blockquote>
<p>物理地址是程序在执行过程中能够真正访问的地址</p>
<p>对于程序员，可用的地址空间远远大于主存空间，使程序员以为自己占有一个容量极大的主存，实际这个主存不存在</p>
<p>当虚地址的内容在主存时，机器可以立即使用；虚地址内容不在主存，必须先将此虚地址的内容传递到主存的合适单元后再为机器所用</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132029038.png" alt="image-20220302132029038" style="zoom:67%;" /></p>
<h2 id="4-2-主存储器"><a href="#4-2-主存储器" class="headerlink" title="4.2 主存储器"></a>4.2 主存储器</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-主存的基本组成"><a href="#1-主存的基本组成" class="headerlink" title="1.主存的基本组成"></a>1.主存的基本组成</h4><p>根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。</p>
<p>读出时，需经过读出放大器，才能将被选中单元的存储字送到MDR；</p>
<p>写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中的单元中。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132102239.png" alt="image-20220302132102239" style="zoom:67%;" /></p>
<blockquote>
<p>对于控制电路而言，读和写命令的优先级相同，因此不会出现两个信号都使能的情况。</p>
<p>在设计上，同一时刻最多有一个信号有效（低电平）。都为低电平为无效状态</p>
</blockquote>
<h4 id="2-主存和CPU的联系"><a href="#2-主存和CPU的联系" class="headerlink" title="2.主存和CPU的联系"></a>2.主存和CPU的联系</h4><p>通过三种类型的信号进行联系</p>
<blockquote>
<p>当要从存储器读出某一信息字时，</p>
<ul>
<li><p>首先由CPU将该字的地址送到MAR，经地址总线送至主存，然后发出读命令。</p>
</li>
<li><p>主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读到数据总线上</p>
</li>
</ul>
<p>当存储器要向主存存入一个信息字时，</p>
<ul>
<li><p>首先CPU将该字所在主存单元的地址经MAR送到地址总线，并将信息字送入MDR，然后向主存发出写命令。</p>
</li>
<li><p>主存接到写命令后，便将数据线上的信息写入到对应地址线指出的内存单元中。</p>
</li>
</ul>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132141452.png" alt="image-20220302132141452" style="zoom:67%;" /></p>
<h4 id="3-主存中存储单元地址的分配"><a href="#3-主存中存储单元地址的分配" class="headerlink" title="3.主存中存储单元地址的分配"></a>3.主存中存储单元地址的分配</h4><p>图中，纵为字地址，横为字节地址。</p>
<p>无论计算机的字长怎么变化，只会影响按字寻址的长度，不会影响存储空间的大小</p>
<p>大端法和小端法</p>
<ul>
<li><p>大端法：<strong>高位字节</strong>地址为字地址</p>
<blockquote>
<p>左图中的12对应的字节地址（大端地址）为字地址</p>
</blockquote>
</li>
<li><p>小端法：<strong>低位字节</strong>地址为字地址</p>
<blockquote>
<p>右图中的78对应的字节地址（小端地址）为字地址</p>
</blockquote>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220113105727882.png" alt="image-20220113105727882" style="zoom: 67%;" /></p>
<blockquote>
<p>$24$根地址线，按<strong>字节</strong>寻址：$2^{24} = 16MB$</p>
<p>字长为$16$位，按<strong>字</strong>寻址：$8MW$</p>
<p>字长为$32$位，按<strong>字</strong>寻址：$4MW$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132213779.png" alt="image-20220302132213779" style="zoom:67%;" /></p>
<p>如何区分“按字节寻址”和“按字寻址”？</p>
<p>【参考资料】：<a href="https://blog.csdn.net/qq_25297587/article/details/89818719">按字寻址和按字节寻址</a></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302152419968.png" alt="image-20220302152419968" style="zoom:67%;" /></p>
<h4 id="4-主存的技术指标"><a href="#4-主存的技术指标" class="headerlink" title="4.主存的技术指标"></a>4.主存的技术指标</h4><p><strong>存储容量</strong>：主存<strong>存放二进制代码的总位数</strong></p>
<p><strong>存储速度</strong>：</p>
<ul>
<li><p>存取时间（$Memory$ $Access$ $ Time$）：存储器的<strong>访问时间</strong>$\begin{cases} 读出时间 \\ 写入时间 \\ \end{cases}$</p>
<ul>
<li>读出时间——给出地址信号到数据线上稳定的输出</li>
<li>写入时间——给出地址信号到数据写入到给定的地址单元中</li>
</ul>
</li>
<li><p>存取周期（$Memory$  $Cycle$  $Time$）：<strong>连续两次独立的存储器操作</strong>。（读或写）所需的<strong>最小间隔时间</strong></p>
<p>​    $\begin{cases} 读周期 \\ 写周期 \\ \end{cases}$</p>
<blockquote>
<p>现代MOS型存储器的存取周期可达100ns，双极型TTL存储器的存取周期接近于10ns</p>
</blockquote>
<ul>
<li>存取时间比存取周期短</li>
</ul>
<p>【参考资料】：<a href="https://blog.csdn.net/qq_40627648/article/details/83626288">计算机组成原理补充——三种刷新方式，存取周期＞存取时间的原因</a>）</p>
</li>
</ul>
<p><strong>存储器的带宽</strong>：<strong>位/秒</strong></p>
<p>与存取周期密切相关。表示单位时间内存储区存取的信息量</p>
<blockquote>
<p>如，存取周期$500ns$，每个存取周期可访问$16$位，则带宽为$32M位/秒$</p>
</blockquote>
<h5 id="提高存储器带宽的措施"><a href="#提高存储器带宽的措施" class="headerlink" title="提高存储器带宽的措施"></a>提高存储器带宽的措施</h5><ul>
<li>缩短存取周期</li>
<li>增加存储字长，使每个存取周期可读/写更多的二进制位数</li>
<li>增加存储体</li>
</ul>
<h3 id="二、半导体存储芯片简介"><a href="#二、半导体存储芯片简介" class="headerlink" title="二、半导体存储芯片简介"></a>二、半导体存储芯片简介</h3><p>内存在存储器中唯一 $\begin{cases} 地址：一般是CPU低位地址寻找芯片内的位置 \\ 片选：对应CPU的地址译码。芯片之间  \end{cases}$</p>
<p>数据：单元内容</p>
<p>读写控制</p>
<p>电压VCC和接地GND</p>
<h4 id="1-半导体存储芯片的基本结构"><a href="#1-半导体存储芯片的基本结构" class="headerlink" title="1.半导体存储芯片的基本结构"></a>1.半导体存储芯片的基本结构</h4><blockquote>
<p>地址线涉及空间分配，在内存的什么地方</p>
</blockquote>
<p>包括存储矩阵（01代码）、译码驱动（地址线）、读写电路（数据线）</p>
<p>还有芯片选择线（判断）、读写控制线</p>
<p>片选线：$\overline{CS}（selected）、\overline{CE}（enabled）$</p>
<p>读/写控制线：$\overline{WE}$（低电平时进行写操作，高电平读）、$\overline{OE}$（允许读）、$\overline{WE}$（允许写）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302132953214.png" alt="image-20220302132953214" style="zoom:67%;" /></p>
<h5 id="存储芯片片选线的作用"><a href="#存储芯片片选线的作用" class="headerlink" title="存储芯片片选线的作用"></a>存储芯片片选线的作用</h5><p>可以让某一个或某一些芯片同时作用</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133219996.png" alt="image-20220302133219996" style="zoom:67%;" /></p>
<h4 id="2-半导体存储芯片的译码驱动方式"><a href="#2-半导体存储芯片的译码驱动方式" class="headerlink" title="2.半导体存储芯片的译码驱动方式"></a>2.半导体存储芯片的译码驱动方式</h4><h5 id="（1）线选法"><a href="#（1）线选法" class="headerlink" title="（1）线选法"></a>（1）线选法</h5><p>$4$位地址，决定$2^4 = 16$根地址线上的$8$位数据</p>
<blockquote>
<p>用一根字选择线（字线），直接选中一个存储单元的各位（如一个字节）</p>
<p>结构较简单，但只适于容量不大的存储芯片</p>
<p>如当$A_3A_2A_1A_0$为1111时，则第15根字线被选中，对应最后一行的8位代码可直接读出或写入</p>
</blockquote>
<p>地址线从一个方向送过来，控制一行的芯片——译码器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133315990.png" alt="image-20220302133315990" style="zoom:67%;" /></p>
<h5 id="（2）重合法"><a href="#（2）重合法" class="headerlink" title="（2）重合法"></a>（2）重合法</h5><p>$X、Y$各$5$根地址线，构成了$2^5 \times 2^5 = 32 \times 32$的矩阵。每个地址对应$1$位的数据</p>
<blockquote>
<p>被选单元是由X、Y两个方向的地址决定的</p>
<p>例如，当地址线全0时，译码输出$X_0$和$Y_0$有效，矩阵中的第0行、第0列共同选中的那位即被选中</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133343084.png" alt="image-20220302133343084" style="zoom:67%;" /></p>
<h3 id="三、随机存取存储器（RAM）"><a href="#三、随机存取存储器（RAM）" class="headerlink" title="三、随机存取存储器（RAM）"></a>三、随机存取存储器（RAM）</h3><h4 id="1-静态RAM（SRAM）"><a href="#1-静态RAM（SRAM）" class="headerlink" title="1.静态RAM（SRAM）"></a>1.静态RAM（SRAM）</h4><h5 id="（1）静态RAM基本电路"><a href="#（1）静态RAM基本电路" class="headerlink" title="（1）静态RAM基本电路"></a>（1）静态RAM基本电路</h5><p>存储器中用于寄存“0”和“1”代码的电路，下图是一个由6个MOS管组成的基本单元电路</p>
<blockquote>
<p>$T_1$-$T_4$是一个由MOS管组成的触发器的基本电路，$T_5$、$T_6$犹如一个开关，受行地址选择信号控制。$T_1$-$T_6$共同构成一个基本单元电路。</p>
<p>$T_7$、$T_8$受列地址选择控制，分别与位线$A’$和$A$相连。不属于基本电路内的部件，芯片内同一列的各个基本电路所共有。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133441283.png" alt="image-20220302133441283" style="zoom:67%;" /></p>
<h6 id="①静态RAM基本电路的读操作"><a href="#①静态RAM基本电路的读操作" class="headerlink" title="①静态RAM基本电路的读操作"></a>①静态RAM基本电路的读操作</h6><blockquote>
<p>给出行选和列选信号 $\to$ 读选择有效 $\to$ 读放</p>
</blockquote>
<p>假设触发器已有“1”信号，即A点高电平。</p>
<ul>
<li>当需要读出时，只要使行、列地址选择信号均有效，$T_5$、$T_6$、$T_7$、$T_8$均导通，</li>
<li>A点高电平通过$T_6$后，再由位线通过$T_8$作为读放大器的输入信号，</li>
<li>在读选择有效时，将“1”信号读出</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133518910.png" alt="image-20220302133518910" style="zoom:67%;" /></p>
<p>静态RAM是用触发器原理存储信息，因此即使信息读出后，它仍保持其原状态，不需要再生。但电源掉电后，原存信息丢失，属于<strong>易失性半导体存储器</strong></p>
<h6 id="②静态RAM基本电路的写操作"><a href="#②静态RAM基本电路的写操作" class="headerlink" title="②静态RAM基本电路的写操作"></a>②静态RAM基本电路的写操作</h6><blockquote>
<p>行地址选择信号有效，列地址选择信号有效 （低电平）$\to $ 写选择信号有效 $\to$ 数据经过$D_{IN}$通过写放大器进入$A’$和$A$</p>
<p>由于两个写放大器相反，保证信号不同。</p>
</blockquote>
<ul>
<li>写入时不论触发器原状态如何，只要将写入代码送至$D_{IN}$端，</li>
<li>在写选择有效时，经两个写放大器，使两端输出相反电平，</li>
<li>这样，就欲把写入的信息写入到该基本单元电路中。</li>
</ul>
<blockquote>
<p>如欲写入“1“，即$D_{IN}$ = 1，经两个写放大器使位线$A$为高电平，位线$A’$为低电平，结果使$A$点为高，$A’$点为低，即写入了”1“信息。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220302133548297.png" alt="image-20220302133548297" style="zoom:67%;" /></p>
<h5 id="（2）静态RAM芯片举例"><a href="#（2）静态RAM芯片举例" class="headerlink" title="（2）静态RAM芯片举例"></a>（2）静态RAM芯片举例</h5><h6 id="①Intel-2114外特性"><a href="#①Intel-2114外特性" class="headerlink" title="①Intel 2114外特性"></a>①Intel 2114外特性</h6><p>$\overline{WE}$复用，低电平为写，高电平为读</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105355921.png" alt="image-20220307105355921" style="zoom: 67%;" /></p>
<h6 id="②Intel-2114-RAM矩阵（64-times-64）读"><a href="#②Intel-2114-RAM矩阵（64-times-64）读" class="headerlink" title="②Intel 2114 RAM矩阵（64 $\times$ 64）读"></a>②Intel 2114 RAM矩阵（64 $\times$ 64）读</h6><h6 id="③Intel-2114-RAM矩阵（64-times-64）写"><a href="#③Intel-2114-RAM矩阵（64-times-64）写" class="headerlink" title="③Intel 2114 RAM矩阵（64 $\times$ 64）写"></a>③Intel 2114 RAM矩阵（64 $\times$ 64）写</h6><h5 id="（3）静态RAM读时序"><a href="#（3）静态RAM读时序" class="headerlink" title="（3）静态RAM读时序"></a>（3）静态RAM读时序</h5><p>在整个读周期中，$\overline{WE}$始终为高电平。</p>
<p><strong>读周期</strong>$t_{RC}$是指<strong>对芯片进行两次连续读操作的最小间隔时间</strong></p>
<p><strong>读时间</strong>$t_A$表示<strong>从地址有效到数据稳定所需的时间</strong>，显然读时间小于读周期</p>
<p>图中$t_{CO}$是从片选有效到数据稳定的时间</p>
<blockquote>
<p>只有当地址有效经$t_A$后，且当片选有效经$t_{CO}$后，数据才能稳定输出，二者必须同时具备</p>
<p>根据$t_A$和$t_{CO}$的值，便可知当地址有效后经$t_A$-$t_{CO}$时间必须给出片选有效信号，否则信号不能出现在数据线上</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105611033.png" alt="image-20220307105611033" style="zoom:67%;" /></p>
<p>注意：<strong>从片选失效到输出高阻需一段时间$t_{OTD}$，故地址失效后，数据线上的有效数据有一段维持时间$t_{OTA}$，以保证所读的数据可靠</strong></p>
<h5 id="（4）静态RAM写时序"><a href="#（4）静态RAM写时序" class="headerlink" title="（4）静态RAM写时序"></a>（4）静态RAM写时序</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105635863.png" alt="image-20220307105635863" style="zoom:67%;" /></p>
<p>写周期$t_{WC}$是对芯片进行连续两次写操作的最小间隔时间</p>
<p>写周期包括滞后时间$t_{AW}$、写入时间$t_w$和写恢复时间$t_{WR}$</p>
<blockquote>
<p>在有效数据出现前，RAM的数据线上存在着前一时刻的数据$D_{OUT}$，故在地址线发生变化后，$\overline{CS}$、$\overline{WE}$均需滞后$t_{AW}$再有效，以避免将无效数据写入RAM的错误。</p>
<p>但写允许$\overline{WE}$失效后，地址必须保持一段时间，称为写恢复时间。</p>
<p>此外，RAM数据线上的有效数据（即CPU送至RAM的写入数据$D_{IN}$）必须在$\overline{CS}$、$\overline{WE}$失效前的$t_{DW}$时刻出现，并延续一段时间$t_{DH}$（此刻地址线仍有效，$t_{WR} &gt; t_{DH}$），以保证数据可靠写入。（采样点）</p>
</blockquote>
<p>SRAM总结：触发器原理。写入数据后一直保持，直至下次写入</p>
<h4 id="2-动态RAM（DRAM）——了解内容"><a href="#2-动态RAM（DRAM）——了解内容" class="headerlink" title="2.动态RAM（DRAM）——了解内容"></a>2.动态RAM（DRAM）——了解内容</h4><p>【问题】</p>
<ul>
<li>保存0和1的原理是什么？——电容（保存电荷——保存信息，有电1）</li>
<li>基本单元电路的构成是什么？</li>
<li>对单元电路如何读出和写入？</li>
<li>典型芯片的结构是什么样子？</li>
<li>动态RAM芯片如何进行读出和写入操作？</li>
<li>动态RAM为什么要刷新，刷新方法？</li>
</ul>
<h5 id="（1）动态RAM基本单元电路"><a href="#（1）动态RAM基本单元电路" class="headerlink" title="（1）动态RAM基本单元电路"></a>（1）动态RAM基本单元电路</h5><p>电容记录0和1。带有电荷电路特点：电荷2ms内维持，之后变化归零。因此需要再生（刷新）电路</p>
<p>SRAM则是4个三极管，利用触发器原理</p>
<ul>
<li>$C_s$表示与电荷带电有关<ul>
<li>读出相反，写入相同</li>
</ul>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307105749956.png" alt="image-20220307105749956" style="zoom:67%;" /></p>
<h5 id="（2）动态RAM芯片举例"><a href="#（2）动态RAM芯片举例" class="headerlink" title="（2）动态RAM芯片举例"></a>（2）动态RAM芯片举例</h5><p>①三管动态RAM芯片（Intel 1103）读</p>
<p>②三管动态RAM芯片（Intel 1103）写</p>
<p>③单管动态RAM 4116（16K $\times$ 1位）外特性</p>
<p>④4116（16K $\times$ 1位）芯片读原理</p>
<p>⑤4116（16K $\times$ 1位）芯片写原理</p>
<h5 id="（3）动态RAM时序"><a href="#（3）动态RAM时序" class="headerlink" title="（3）动态RAM时序"></a>（3）动态RAM时序</h5><p><strong>行、列地址分开传送</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">读时序</th>
<th style="text-align:center">写时序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">行地址$\overline{RAS}$有效</td>
<td style="text-align:center">行地址$\overline{RAS}$有效</td>
</tr>
<tr>
<td style="text-align:center">写允许$\overline{WE}$有效（高）</td>
<td style="text-align:center">写允许$\overline{WE}$有效（低）</td>
</tr>
<tr>
<td style="text-align:center">列地址$\overline{CAS}$有效</td>
<td style="text-align:center">数据$\overline{D_{IN}}$有效</td>
</tr>
<tr>
<td style="text-align:center">数据$\overline{D_{OUT}}$有效</td>
<td style="text-align:center">列地址$\overline{CAS}$有效</td>
</tr>
</tbody>
</table>
</div>
<h5 id="（4）动态RAM刷新"><a href="#（4）动态RAM刷新" class="headerlink" title="（4）动态RAM刷新"></a>（4）动态RAM刷新</h5><p><strong>刷新与行地址有关</strong></p>
<h6 id="①集中刷新（存取周期为0-5μs）：专时专用"><a href="#①集中刷新（存取周期为0-5μs）：专时专用" class="headerlink" title="①集中刷新（存取周期为0.5μs）：专时专用"></a>①集中刷新（存取周期为0.5μs）：专时专用</h6><ul>
<li>“死区”、“死时间率”</li>
</ul>
<p>以128$\times$128矩阵为例</p>
<h6 id="②分散刷新（存取周期为1μs）：频繁刷新"><a href="#②分散刷新（存取周期为1μs）：频繁刷新" class="headerlink" title="②分散刷新（存取周期为1μs）：频繁刷新"></a>②分散刷新（存取周期为1μs）：频繁刷新</h6><ul>
<li>无“死区”</li>
</ul>
<p>以128$\times$128矩阵为例</p>
<h6 id="③异步刷新（分散刷新与集中刷新相结合）"><a href="#③异步刷新（分散刷新与集中刷新相结合）" class="headerlink" title="③异步刷新（分散刷新与集中刷新相结合）"></a>③异步刷新（分散刷新与集中刷新相结合）</h6><ul>
<li>每行每隔2ms刷新一次</li>
<li>每一段为集中刷新，整体来看是分散刷新</li>
</ul>
<h4 id="3-动态RAM和静态RAM的比较（重点）"><a href="#3-动态RAM和静态RAM的比较（重点）" class="headerlink" title="3.动态RAM和静态RAM的比较（重点）"></a>3.动态RAM和静态RAM的比较（重点）</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">DRAM（主存）</th>
<th style="text-align:center">SRAM（缓存）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>存储原理</strong></td>
<td style="text-align:center">电容</td>
<td style="text-align:center">触发器</td>
</tr>
<tr>
<td style="text-align:center"><strong>集成度</strong></td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
</tr>
<tr>
<td style="text-align:center"><strong>芯片引脚</strong></td>
<td style="text-align:center">少</td>
<td style="text-align:center">多</td>
</tr>
<tr>
<td style="text-align:center"><strong>功耗</strong></td>
<td style="text-align:center">小</td>
<td style="text-align:center">大</td>
</tr>
<tr>
<td style="text-align:center"><strong>价格</strong></td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center"><strong>速度</strong></td>
<td style="text-align:center">慢</td>
<td style="text-align:center">快</td>
</tr>
<tr>
<td style="text-align:center"><strong>刷新</strong></td>
<td style="text-align:center">有</td>
<td style="text-align:center">无</td>
</tr>
</tbody>
</table>
</div>
<h3 id="四、只读存储器（ROM）——了解内容"><a href="#四、只读存储器（ROM）——了解内容" class="headerlink" title="四、只读存储器（ROM）——了解内容"></a>四、只读存储器（ROM）——了解内容</h3><h4 id="1-掩膜ROM（MROM"><a href="#1-掩膜ROM（MROM" class="headerlink" title="1.掩膜ROM（MROM)"></a>1.掩膜ROM（MROM)</h4><ul>
<li>行列选择器交叉处有MOS管为“1”</li>
<li>行列选择器交叉处无MOS管为“0”</li>
</ul>
<h4 id="2-PROM（一次性编程）"><a href="#2-PROM（一次性编程）" class="headerlink" title="2.PROM（一次性编程）"></a>2.PROM（一次性编程）</h4><p>优点：程序完成后保持稳定的状态</p>
<p>但是若修改需要更换芯片</p>
<ul>
<li>熔丝断为“0”</li>
<li>熔丝未断为“1”</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125100716032.png" alt="image-20220125100716032" style="zoom:80%;" /></p>
<h4 id="3-EPROM（多次性编程）"><a href="#3-EPROM（多次性编程）" class="headerlink" title="3.EPROM（多次性编程）"></a>3.EPROM（多次性编程）</h4><h5 id="（1）N型沟道浮动栅MOS电路"><a href="#（1）N型沟道浮动栅MOS电路" class="headerlink" title="（1）N型沟道浮动栅MOS电路"></a>（1）N型沟道浮动栅MOS电路</h5><p>浮动栅使用<strong>紫外线</strong>照射5-10分钟进行擦除，需要芯片脱离CPU/系统，离线到EPROM编程器照射</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125100850329.png" alt="image-20220125100850329" style="zoom:80%;" /></p>
<h5 id="（2）2716-EPROM的逻辑图和引脚图"><a href="#（2）2716-EPROM的逻辑图和引脚图" class="headerlink" title="（2）2716 EPROM的逻辑图和引脚图"></a>（2）2716 EPROM的逻辑图和引脚图</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307165247384.png" alt="image-20220307165247384" style="zoom:67%;" /></p>
<h4 id="4-EEPROM（多次性编程）"><a href="#4-EEPROM（多次性编程）" class="headerlink" title="4.EEPROM（多次性编程）"></a>4.EEPROM（多次性编程）</h4><ul>
<li>电可擦写</li>
<li>局部擦写</li>
<li>全部擦写</li>
</ul>
<h4 id="5-Flash-Memory（闪速型存储器）"><a href="#5-Flash-Memory（闪速型存储器）" class="headerlink" title="5.Flash Memory（闪速型存储器）"></a>5.Flash Memory（闪速型存储器）</h4><ul>
<li>EPROM——价格便宜、集成度高</li>
<li>EEPROM——电可擦洗重写</li>
<li>比EEPROM快，具备RAM功能</li>
</ul>
<h3 id="五、存储器与CPU的连接（重点和难点）"><a href="#五、存储器与CPU的连接（重点和难点）" class="headerlink" title="五、存储器与CPU的连接（重点和难点）"></a>五、存储器与CPU的连接（重点和难点）</h3><p>（本节的重点和难点）</p>
<h4 id="1-存储器容量的扩展"><a href="#1-存储器容量的扩展" class="headerlink" title="1.存储器容量的扩展"></a>1.存储器容量的扩展</h4><p>包括<strong>位扩展、字扩展、字位扩展</strong></p>
<ul>
<li>位扩展（增加存储字长）</li>
<li>字扩展（增加存储字的数量）</li>
<li>字、位扩展</li>
</ul>
<h5 id="（1）位扩展"><a href="#（1）位扩展" class="headerlink" title="（1）位扩展"></a>（1）位扩展</h5><p>【例】用2片1K×4位存储芯片组成1K×8位的存储器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160517155.png" alt="image-20220316160517155" style="zoom:50%;" /></p>
<h5 id="（2）字扩展"><a href="#（2）字扩展" class="headerlink" title="（2）字扩展"></a>（2）字扩展</h5><p>增加存储单元的个数</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160533664.png" alt="image-20220316160533664" style="zoom:50%;" /></p>
<h5 id="（3）字、位扩展"><a href="#（3）字、位扩展" class="headerlink" title="（3）字、位扩展"></a>（3）字、位扩展</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316160558820.png" alt="image-20220316160558820" style="zoom:50%;" /></p>
<h4 id="2-存储器与CPU连接"><a href="#2-存储器与CPU连接" class="headerlink" title="2.存储器与CPU连接"></a>2.存储器与CPU连接</h4><ol>
<li><p>地址线的连接</p>
</li>
<li><p>数据线的连接</p>
</li>
<li><p>读/写命令线的连接——控制</p>
<p>需要地址、数据、控制总线</p>
</li>
<li><p>片选线的连接</p>
<p>地址线</p>
</li>
<li><p>合理选择存储芯片——芯片的性质（可读可写/只读）</p>
<ul>
<li>配置文件使用ROM</li>
<li>可读可写使用RAM</li>
</ul>
</li>
<li><p>其他：时序（性能选择，如主频总线和CPU不同）、负载、干扰</p>
</li>
</ol>
<h4 id="【例4-1】（P94）"><a href="#【例4-1】（P94）" class="headerlink" title="【例4-1】（P94）"></a>【例4-1】（P94）</h4><blockquote>
<p>给出内存的一部分，开始的地址和截止的地址，未告知空间大小——需要自己查</p>
<p>给出系统的性质（系统程序/工作区和用户程序）</p>
</blockquote>
<p>系统程序——ROM；用户程序/程序工作区——RAM</p>
<ul>
<li><p>地址</p>
<p><strong>不变的地址为片选地址，变化的为片内地址</strong></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309160958497.png" alt="image-20220309160958497" style="zoom:50%;" /></p>
<p>只读存储器用于系统工作区，随机存储区用于程序工作区</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309161157269.png" alt="image-20220309161157269" style="zoom:50%;" /></p>
<p>芯片地址要和CPU地址一一对应，剩余地址进行片选</p>
<blockquote>
<p>$A_{13}, A_{12},A_{11}用于片选$</p>
<p>注意输入端不悬空</p>
<p>$\overline{MREQ}$和$\overline{WR}$协作，控制读操作和写操作</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309161451439.png" alt="image-20220309161451439" style="zoom:50%;" /></p>
<blockquote>
<p>设计时注意：<br>①元件/芯片要命名</p>
<p>②每条信号线也要标识信号的名称</p>
<p>③厂家名、类型——考试可以免</p>
<p>④达到线-线一一对应</p>
</blockquote>
<h4 id="【例4-2】（P95）"><a href="#【例4-2】（P95）" class="headerlink" title="【例4-2】（P95）"></a>【例4-2】（P95）</h4><blockquote>
<p>地址线必须全用——保证唯一性</p>
<p>尽量CPU地址线和芯片的地址线一一对应</p>
</blockquote>
<ul>
<li><p>最小8K地址</p>
<p>前3位全0</p>
<p>需要13根地址线——$A_0-A_{12}$</p>
</li>
<li><p>相邻16K地址</p>
<p>需要14根地址线——两个8K</p>
</li>
<li><p>最大4K地址</p>
</li>
</ul>
<blockquote>
<p>注意：</p>
<p>①实质上，CPU和芯片的信号线都接到总线上</p>
<p>②作为设计草图，信号线可以省略标注（<strong>画三个点，不可省</strong>）——学会简化</p>
<p>③标好芯片名称</p>
</blockquote>
<h4 id="【例4-3】"><a href="#【例4-3】" class="headerlink" title="【例4-3】"></a>【例4-3】</h4><p>某计算机地址为$A_{15}-A_{0}$，共16条。数据$D_{7}-D_{0}$，用$\overline{MEMR}$和$\overline{MEMW}$作为控制信号。用8K×8RAM及8K×8ROM芯片设计一个存储器系统。</p>
<p>其中：最小8K地址为系统程序区，其他为用户程序区</p>
<p>回答：①存储器需多少个芯片以及类型；②写出系统每个芯片的地址空间分配；③画出CPU和存储器原理图；④叙述说明存储器工作的正常和异常的测试程序；⑤若变成16位/32位计算机，该如何设计？</p>
<blockquote>
<p>RAM和ROM测试</p>
<p>【参考资料】<a href="https://blog.csdn.net/u012252959/article/details/107955566#:~:text=%E6%B5%8B%E8%AF%95RAM%E7%9A%84%E6%96%B9%E6%B3%95,%E5%B9%B6%E4%B8%8E%E6%A0%A1%E9%AA%8C%E5%92%8C%E6%AF%94%E8%BE%83%E3%80%82">ROM和RAM测试总结</a></p>
<p>测试RAM的方法是写读各个内存单元，检查是否能够正确写入；测试ROM的方法是累加各存储单元数值并与校验和比较。</p>
<p>ROM</p>
<p>留一个单元——</p>
<p>驱动和隔离</p>
<p>使用三态门</p>
</blockquote>
<h4 id="存储器设计总结"><a href="#存储器设计总结" class="headerlink" title="存储器设计总结"></a>存储器设计总结</h4><ul>
<li>芯片选择：系统程序ROM存储器，用户程序/系统工作RAM</li>
<li>地址空间的确定</li>
<li>存储器的数据线与芯片的数据线对应相连（别忘了驱动和隔离——工程设计，考试不要求）</li>
<li>控制线（芯片）端——CPU与存储器控制线相连<ul>
<li>写控（$\overline{OE}$）</li>
<li>读控（）</li>
<li>驱动</li>
</ul>
</li>
<li>芯片的地址线与CPU地址线对应相连<ul>
<li>保证芯片地址在内存的唯一性</li>
<li>CPU（$A_0…A_i$）——芯片</li>
<li>总线的片选线时该芯片的总线地址（去掉片内地址的所有的唯一译码得来）</li>
</ul>
</li>
</ul>
<h4 id="译码方法总结"><a href="#译码方法总结" class="headerlink" title="译码方法总结"></a>译码方法总结</h4><ul>
<li>少变多<ul>
<li>1$\to$2：反相器</li>
<li>2$\to$4：74LS139</li>
<li>3$\to$8：74LS138</li>
<li>4$\to$16：74LS164</li>
</ul>
</li>
<li>多变少——地址译码<ul>
<li>适当添加反相器</li>
<li>控制端：使用读控、写控相与</li>
</ul>
</li>
</ul>
<p>补充题：1.例1和例2仿照例3重新完成 2.双CPU共享存储器</p>
<h3 id="六、存储器的校验——可靠性、容错性"><a href="#六、存储器的校验——可靠性、容错性" class="headerlink" title="六、存储器的校验——可靠性、容错性"></a>六、存储器的校验——可靠性、容错性</h3><p>目的：使存储器（自身）具有检测错误、纠正错误的能力。</p>
<p>容错设计的常见方法有四种：</p>
<blockquote>
<p>A、硬件冗余方法</p>
<p>B、软件冗余方法</p>
<p>C、时间冗余方法</p>
<p>D、信息冗余方法</p>
</blockquote>
<h4 id="硬件冗余"><a href="#硬件冗余" class="headerlink" title="硬件冗余"></a>硬件冗余</h4><p>是通过<strong>外加硬件的方式来达到系统容错的目的方式</strong>。是系统级的容错技术。技术常采用，它是用两倍、三倍的元件重复，从而增加了系统的可靠性。如：二模冗余、三模冗余等方式实现。 </p>
<ul>
<li><p>二模冗余</p>
<p>采用结果比较原则：结果相同，取其一； </p>
<p>结果不同，重新执行或每个模块进行自检，查出错误模块为止。</p>
</li>
<li><p>三模冗余：按照“三中取二”原则进行。</p>
</li>
</ul>
<h4 id="软件冗余"><a href="#软件冗余" class="headerlink" title="软件冗余"></a>软件冗余</h4><p>软件冗余技术：指开发容错软件的适宜环境和系统方法；<br>其主要目的是<strong>提供足够的冗余信息与算法程序，使系统在实际运行过程中，能够及时发现程序错误，采取补救措施</strong>，保证整个计算的正确性。<br>软件冗余包含多种技术和方法。<br>(研究生开设一门—-容错技术讲解)</p>
<h4 id="时间冗余"><a href="#时间冗余" class="headerlink" title="时间冗余"></a>时间冗余</h4><p>基本思想是：<strong>在一定时间内，重复执行指令或者一段程序来消除故障的影响</strong>，以达到容错的效果，它是用消耗时间来换取容错性的目 的，时间冗余的典型应用是程序卷回。</p>
<ul>
<li>两种方法：指令复执、程序卷回</li>
</ul>
<h4 id="信息冗余"><a href="#信息冗余" class="headerlink" title="信息冗余"></a>信息冗余</h4><p>通过在数据中，附加冗余的信息位，来达到故障检测和容错的目的。</p>
<p>常用的信息冗余技术：奇偶校验码、汉明码、循环码等。</p>
<p>存储器的检测及纠错功能，采用的是汉明码技术。</p>
<h4 id="存储器的汉明码校验原理"><a href="#存储器的汉明码校验原理" class="headerlink" title="存储器的汉明码校验原理"></a>存储器的汉明码校验原理</h4><p>题型：生成汉明码、汉明码纠错</p>
<h5 id="1-编码的最小距离"><a href="#1-编码的最小距离" class="headerlink" title="1.编码的最小距离"></a>1.编码的最小距离</h5><ul>
<li><p>编码的检测能力和纠错能力和什么有关？——任意二组合法代码之间<strong>二进制位的最小差异数</strong></p>
</li>
<li><p>编码的最小距离</p>
<p>任意两组合法代码之间的<strong>二进制位数</strong>的<strong>最小差异编码的纠错、检错能力与编码的最小距离有关</strong></p>
<script type="math/tex; mode=display">
L-1 = D+C \quad (D \geq C)</script><p>（L——编码的最小距离，L=3）</p>
<p>（D——检测错误的位数，具有一位纠错能力）</p>
<p>（C——纠正错误的位数）</p>
<blockquote>
<p>BCD码、ASCII码是没有检测及纠错能力的编码</p>
<p><strong>汉明码是具有一位纠错能力的编码</strong></p>
</blockquote>
</li>
<li><p>汉明码</p>
<p>具有一位纠错能力的编码</p>
<p>采用奇偶校验</p>
<p>采用分组校验</p>
<p>汉明码的分组是一种非划分方式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220125105813576.png" alt="image-20220125105813576" style="zoom: 50%;" /></p>
</li>
</ul>
<h5 id="2-汉明码的组成"><a href="#2-汉明码的组成" class="headerlink" title="2.汉明码的组成"></a>2.汉明码的组成</h5><ul>
<li><p>三要素</p>
<script type="math/tex; mode=display">
2^{k}-1 \geq n+k \\</script><p>多少位检测位、检测位的位置、检测位的取值</p>
<p><code>信息位n位，校验位k位</code></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128105943809.png" alt="image-20220128105943809" style="zoom: 67%;" /></p>
</li>
</ul>
<blockquote>
<p>各检测位$C_i$所承担的检测小组为：</p>
<p>$C_1$检测的$g_1$小组包含第1，3，5，7，9，11，…</p>
<p>$C_2$检测的$g_2$小组包含第2，3，6，7，10，11，…</p>
<p>$C_4$检测的$g_3$小组包含第4，5，6，7，12，13，…</p>
<p>$C_8$检测的$g_4$小组包含第8，9，10，11，12，13，14，15，24，…</p>
<p>$g_i$小组独占第$2^{i-1}$位</p>
<p>$g_i$和$g_j$小组共同占第$2^{i-1}+2^{j-1}$位</p>
<p>$g_i、g_j$和$g_l$小组共同占第$2^{i-1}+2^{j-1}+2^{l-1}$位</p>
</blockquote>
<p>【例4-4】求0101按“偶校验”配置的汉明码</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309121524680.png" alt="image-20220309121524680" style="zoom:50%;" /></p>
<p>【练习1】按配偶原则配置0011的汉明码</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309121612964.png" alt="image-20220309121612964" style="zoom:50%;" /></p>
<h5 id="3-汉明码的纠错过程"><a href="#3-汉明码的纠错过程" class="headerlink" title="3.汉明码的纠错过程"></a>3.汉明码的纠错过程</h5><ul>
<li><p><strong>偶校验</strong>：异或的结果为0则不出错，为1则出错</p>
</li>
<li><p><strong>奇校验</strong>：与偶校验相反</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309132525822.png" alt="image-20220309132525822" style="zoom:50%;" /></p>
<p>【例4.5】已知接收到的汉明码为0100111（按配偶原则配置）试问要求传送的信息是什么？</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309132622850.png" alt="image-20220309132622850" style="zoom:50%;" /></p>
<p>【练习2】写出按偶校验配置的汉明码0101101的纠错过程</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316163138252.png" alt="image-20220316163138252" style="zoom:50%;" /></p>
<blockquote>
<p>出错的是第4位（校验码），不需要纠错</p>
</blockquote>
<p>【练习3】按配奇原则配置0011的汉明码</p>
<ul>
<li><p>答：配奇的汉明码为</p>
<blockquote>
<p>$1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7$</p>
<p>$c_1 \ c_2 \ 0 \  0 \ c_4 \ 1 \ 1$</p>
<p>$c_1 = 3 \oplus 5 \oplus 7 = 1$  </p>
</blockquote>
</li>
</ul>
<h5 id="4-汉明码应用"><a href="#4-汉明码应用" class="headerlink" title="4.汉明码应用"></a>4.汉明码应用</h5><p>按照汉明码的特点，在设计计算机存储器时，要明确存储器的性能指标：检测错误个数、纠正错误个数；</p>
<blockquote>
<p>例如：哈工大设计的“神舟”飞船的容错计算机中，它的存储器字长为16位、采用校验位为6位，所以，选用 SN54LS630实现”1位纠错、2位报警”功能。</p>
</blockquote>
<h3 id="七、提高访存速度的措施"><a href="#七、提高访存速度的措施" class="headerlink" title="七、提高访存速度的措施"></a>七、提高访存速度的措施</h3><blockquote>
<p>CPU速度每年提升52%，但内存的速度提升很慢。CPU得不到指令，进行空载（等待）。需要解决存储墙的问题。</p>
</blockquote>
<p>【解决方式】</p>
<ul>
<li>采用高速器件（带宽大、延迟小）</li>
<li>采用层次结构Cache-主存</li>
<li>调整主存的结构</li>
</ul>
<h4 id="1-单体多字系统"><a href="#1-单体多字系统" class="headerlink" title="1.单体多字系统"></a>1.单体多字系统</h4><p>CPU每次访问内存都可以访问四个数据寄存器，可以增加存储器的带宽。</p>
<p>【问题】：</p>
<ul>
<li>造成给定的存储字长被错误修改</li>
<li>如果取得指令不是连续存储</li>
</ul>
<p>【原因】：位置连续</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128114909794.png" alt="image-20220128114909794" style="zoom: 80%;" /></p>
<p>原理：由于程序、数据在内存中是顺序存放，一个地址，一个存取周期内可取出4×W位。<br>要求：存储器的各个存储器体的数据能够寄存及顺序读出等硬件支持。 遇到转移指令、数据非顺序<br>时失效。</p>
<h4 id="2-多体并行系统"><a href="#2-多体并行系统" class="headerlink" title="2.多体并行系统"></a>2.多体并行系统</h4><ul>
<li><p>存储器模块组成：各个模块各自都有独立的：MAR、 MDR、地址译码、驱动电路、读写控制；</p>
</li>
<li><p>特点： 每个存储器模块有相同的容量和存储速度； 各个存储器模块可以并行工作，又可以交叉工作；</p>
</li>
<li><p>并行工作：即同时可以访问N个存储器模块，同时启动、同时读出、完全并行的工作；（注意：同时读出的N个存储字，在总线上需要顺序、分时传出）；</p>
</li>
</ul>
<h5 id="（1）高位交叉，顺序编址存储器"><a href="#（1）高位交叉，顺序编址存储器" class="headerlink" title="（1）高位交叉，顺序编址存储器"></a>（1）高位交叉，顺序编址存储器</h5><blockquote>
<p>高位译码决定体地址，低位译码决定体内的地址</p>
</blockquote>
<p>【问题】具有并行基础，但会造成某一个存储体十分繁忙，其余闲置</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115133016.png" alt="image-20220128115133016" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316165850524.png" alt="image-20220316165850524" style="zoom: 50%;" /></p>
<p>适合存储器的扩展，不适合带宽的提升</p>
<ul>
<li>高位交叉编址多体存储器工作原理：只要合理安排及调度，可以实现不同请求源，与不同存储体进行访问，实现并行工作；</li>
</ul>
<ul>
<li><p>优点：一个体内地址是连续的，有利于扩充；</p>
</li>
<li><p>缺点：相邻指令或数据是在连续存放在一个存储体内。<strong>不利于程序并行</strong></p>
<blockquote>
<p>一个体内运行——串行</p>
</blockquote>
</li>
</ul>
<h5 id="（2）低位交叉并行多体存储器（各个体轮流编址）"><a href="#（2）低位交叉并行多体存储器（各个体轮流编址）" class="headerlink" title="（2）低位交叉并行多体存储器（各个体轮流编址）"></a>（2）低位交叉并行多体存储器（各个体轮流编址）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115441608.png" alt="image-20220128115441608" style="zoom: 67%;" /></p>
<blockquote>
<p>低位不同——体号。高位——体内地址</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171050903.png" alt="image-20220316171050903" style="zoom:50%;" /></p>
<blockquote>
<p>地址译码需要加上三态门进行驱动和隔离</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171111134.png" alt="image-20220316171111134" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220128115417652.png" alt="image-20220128115417652" style="zoom: 67%;" /></p>
<blockquote>
<p>注：带宽：数据传输率</p>
<p>每个存储体完成数据传输（总线传输周期），则下一个存储体开始传输</p>
<p>对于每个存储体，访存周期不变</p>
</blockquote>
<ul>
<li>特点：在一个存储器周期结束之后，每隔1/4周期，CPU即可获得一个结果。</li>
<li>优点：相邻各个存储体内地址是连续的，有利于并行—流水线计算机相邻各个存储体内地址是连续的，单独每个体的地址是间隔的。</li>
</ul>
<blockquote>
<p><strong>题型</strong></p>
<p>对于低位交叉的存储器，连续读取n个字所需要的时间$t_1$为：$t_1 = T + (n-1) \tau$ </p>
<p>其中，$T$为存取周期，$\tau$为总线传输周期</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220316171737021.png" alt="image-20220316171737021" style="zoom:50%;" /></p>
<h5 id="（3）存储器控制部件（存控）"><a href="#（3）存储器控制部件（存控）" class="headerlink" title="（3）存储器控制部件（存控）"></a>（3）存储器控制部件（存控）</h5><blockquote>
<p>在多体交叉并行存储器的设计中，不仅要考虑存储器自身的并行性支撑：单独MAR、MDR、译码驱动、读控制、写控制、数据寄存器等；</p>
<p>如何确定存储器与CPU、外存、I/O设备、I/O处理机等，不同信息交换源之间的关系；<br>因此，在某一时刻，如何进行<strong>优先级排队</strong>，<strong>选出</strong>优先级高的请求源，<strong>与存储器进行信息交换</strong>；这个功能及任务<strong>由存储器的控制器（存控）来实现</strong>。</p>
</blockquote>
<p>存储器控制部件（存控）组成：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220309133933651.png" alt="image-20220309133933651" style="zoom: 67%;" /></p>
<p><strong>（1）排队器（硬件）</strong></p>
<p>（详见ch8，中断优先级排队器的设计）</p>
<p><strong>确定</strong>同一时刻访问存储器的请求源；按照<strong>优先级</strong>原则进行。</p>
<ul>
<li><p>对易发生代码丢失的请求源，安排最高优先级；</p>
<blockquote>
<p>如，某些外设信息最易丢失</p>
</blockquote>
</li>
<li><p>严重影响CPU工作的请求源，安排次级优先级，否则导致CPU工作异常；</p>
<blockquote>
<p>如，写数高于读数；读数高于读指令</p>
</blockquote>
</li>
</ul>
<p><strong>（2）存控标志触发器$C_m$</strong></p>
<p>用来<strong>接收排队器输出信号</strong>，一旦响应某个请求源，标记 $C_m$ 被置“1”，以便<strong>启动节拍发生器工作</strong>。</p>
<p><strong>（3）节拍发生器</strong></p>
<p><strong>产生固定节拍</strong>，与机器<strong>主脉冲同步</strong>，使控制线路按一定时序发出控制信号；</p>
<p><strong>（4）控制线路</strong></p>
<p>将排队器输出的信号，与<strong>节拍器发生器提供的信号配合</strong>，向存储器各个部件发出各种控制信号，用于实现对总线控制，以及完成存储器的读/写操作，并向请求源发出回答信号，表示存储器已经响应了它的请求；</p>
<h4 id="3-高性能存储芯片（了解内容）"><a href="#3-高性能存储芯片（了解内容）" class="headerlink" title="3.高性能存储芯片（了解内容）"></a>3.高性能存储芯片（了解内容）</h4><p>按照摩尔定律：存储器容量每3年两番的规律，使DRAM的性能得到提高。</p>
<p><strong>（1）SDRAM（同步DRAM）</strong></p>
<p>在系统时钟的控制下进行读出和写入</p>
<p><strong>CPU无须等待</strong></p>
<p><strong>（2）RDRAM</strong></p>
<p>由<code>Rambus</code>开发，主要解决<strong>存储器带宽</strong>的问题</p>
<p><strong>（3）带Cache的DRAM</strong></p>
<p>在DRAM的芯片内集成了一个由<strong>SRAM</strong>组成的<strong>Cache</strong>，有利于<strong>猝发式读取</strong></p>
<blockquote>
<p>一次读取几个存储字长（给出首地址就能完成剩余的读写操作，不需要再给出地址）</p>
</blockquote>
<h2 id="4-3-高速缓冲存储器"><a href="#4-3-高速缓冲存储器" class="headerlink" title="4.3 高速缓冲存储器"></a>4.3 高速缓冲存储器</h2><p>Cache是用SRAM制成的</p>
<h3 id="一、概述-1"><a href="#一、概述-1" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-为什么用Cache"><a href="#1-为什么用Cache" class="headerlink" title="1.为什么用Cache"></a>1.为什么用Cache</h4><blockquote>
<p>CPU 优先级低于易失性外设的请求源；出现CPU“空等”现象</p>
<p>CPU 和主存（DRAM）的速度差异发展快，且速度差越来越大；</p>
</blockquote>
<p>——避免CPU“空等”现象</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165237238.png" alt="image-20220321165237238" style="zoom: 67%;" /></p>
<h5 id="程序访问的局部性原理"><a href="#程序访问的局部性原理" class="headerlink" title="程序访问的局部性原理"></a>程序访问的局部性原理</h5><p>CPU在访问内存时，在一定时间，是<strong>局部地址区域的访问</strong>，指令和数据中内存中的地址是<strong>连续存放</strong>的，是<strong>相对的簇聚</strong>的。</p>
<blockquote>
<p>如：子程序、循环出现、一些常数等</p>
</blockquote>
<ul>
<li>时间的局部性：在不久的将来还会使用</li>
<li>空间的局部性：相邻的指令或数据还会使用</li>
</ul>
<blockquote>
<p>主存和Cache之间的数据传送单位不是一个字，而是几个字组成的子块</p>
<p>不适合离散情况</p>
</blockquote>
<h4 id="2-Cache的工作原理——注意Cache的命中率"><a href="#2-Cache的工作原理——注意Cache的命中率" class="headerlink" title="2.Cache的工作原理——注意Cache的命中率"></a>2.Cache的工作原理——注意Cache的命中率</h4><p><strong>（1）主存和缓存的编址</strong></p>
<blockquote>
<p>都分为块号和块内地址</p>
<p>主存和缓存的块的长度均为b位</p>
<p>主存有$2^m-1$块，缓存有$2^c-1$块</p>
<p>实际过程中，$M$ &gt;&gt; $C$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165142799.png" alt="image-20220321165142799" style="zoom:80%;" /></p>
<p><strong>主存和缓存按块存储，块的大小相同</strong></p>
<p><strong>（2）命中与未命中</strong></p>
<blockquote>
<p>缓存有C块，主存共有M块，M &gt;&gt; C</p>
</blockquote>
<p>命中与否取决于<strong>主存块是否调入缓存</strong>，用<code>标记记录</code>与某缓存块建立了对应关系的<code>主存块号</code></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165312839.png" alt="image-20220321165312839" style="zoom:67%;" /></p>
<p><strong>（3）Cache的命中率</strong></p>
<p>——CPU欲访问的信息在Cache中的比率</p>
<p>命中率与<strong>Cache的容量与块长</strong>有关</p>
<p>一般每块可取4~8个字</p>
<p><strong>块长取一个存取周期内从主存调出的信息长度</strong></p>
<blockquote>
<p>例如，</p>
<p>CRAY_1：16体交叉，块长取16个存储字</p>
<p>IBM 370/168：4体交叉，块长取4个存储字（64位 × 4 = 256位）</p>
</blockquote>
<p><strong>（4）Cache-主存系统的效率</strong></p>
<p>效率<strong>e</strong>与<strong>命中率</strong>有关</p>
<script type="math/tex; mode=display">
e = \frac{访问Cache的时间}{平均访问时间} \times 100 \%</script><p>平均访问时间：访问t的时间 * 访问t的概率</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165345089.png" alt="image-20220321165345089" style="zoom:80%;" /></p>
<h4 id="3-Cache的基本结构"><a href="#3-Cache的基本结构" class="headerlink" title="3.Cache的基本结构"></a>3.Cache的基本结构</h4><blockquote>
<p>添加Cache后，计算机的读取写入速度提升。</p>
<p>①<strong>CPU需要给出地址</strong>，分为两部分：块内地址（不需要识别，主存和Cache同）、块号（块外地址的值）；</p>
<p>②送入<strong>主存Cache地址映射变换机构</strong>。硬件设计时要在3种方式之一（追求指标：快速）。里面是组合逻辑电路，<strong>比较主存和Cache的块号</strong>；</p>
<p>③如果块号相同，则命中，进入<strong>Cache存储体</strong>内读取数据，<strong>与数据总线</strong>进行信息交换；</p>
<p>④如果没有命中，则<strong>判断是否可以装入</strong>（Cache是否有空闲空间，与映射方式有关）。如果可以装入，则访问主存装入Cache；不能装入则进入<strong>Cache替换机构</strong>。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165049480.png" alt="image-20220321165049480" style="zoom: 80%;" /></p>
<ul>
<li><p>CPU完成的部件：</p>
<ul>
<li><p>Cache存储体：一定是RAM。</p>
</li>
<li><p>地址映射变换机构。是否命中是比较器。</p>
</li>
<li><p>Cache替换机构：是硬件，把某一个叶判断是否需要写入内存</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Cache工作时间一定要小于读取时间（读周期、写周期）</p>
</blockquote>
<h4 id="4-Cache的读写操作"><a href="#4-Cache的读写操作" class="headerlink" title="4.Cache的读写操作"></a>4.Cache的读写操作</h4><ul>
<li><p><strong>Cache读操作</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165015269.png" alt="image-20220321165015269" style="zoom:67%;" /></p>
<blockquote>
<p><strong>过程</strong>：</p>
<ol>
<li><p>CPU发送地址，同时到达Cache和主存。</p>
</li>
<li><p>比较是否命中（Cache的内容是否在主存中）：</p>
<ul>
<li><p>命中：直接访问Cache取出信息送到CPU</p>
</li>
<li><p>没有命中：判断Cache是否满：</p>
<ul>
<li>Cache满：替换算法，腾出空位（替换算法与映射方式有关）</li>
<li>Cache没满：将新主存块调入Cache中</li>
</ul>
</li>
</ul>
<p>访问主存，取出信息送到CPU</p>
</li>
<li><p>结束Cache的读操作</p>
</li>
</ol>
</blockquote>
</li>
<li><p><strong>Cache写操作</strong>——Cache和主存的一致性</p>
<ol>
<li><p>写直达法（Write-through）</p>
<p>数据既写入Cache又写入主存</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164735646.png" alt="image-20220321164735646" style="zoom: 80%;" /></p>
</li>
<li><p>写回法（Write-back）</p>
<blockquote>
<p>速度更快，但需要注意把Cache的信息写回主存</p>
</blockquote>
<p>出现主存和Cache映射的数据不一致，Cache的信息是有效的。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164735646.png" style="zoom:80%;" /></p>
<p><strong>写操作的时间就是访问Cache的时间</strong>。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321164840004.png" alt="image-20220321164840004" style="zoom:80%;" /></p>
</li>
</ol>
</li>
</ul>
<h4 id="5-Cache的改进"><a href="#5-Cache的改进" class="headerlink" title="5.Cache的改进"></a>5.Cache的改进</h4><p><strong>（1）增加Cache的级数</strong></p>
<ul>
<li>片载（片内）Cache</li>
<li>片外 Cache</li>
</ul>
<p><strong>（2）统一缓存和分立缓存</strong></p>
<blockquote>
<p>统一缓存：指令和数据都存放在同一缓存内的Cache</p>
<p>分立缓存：指令和数据分别存放在两个缓存中，一个称为指令Cache，一个称为数据Cache</p>
</blockquote>
<ul>
<li><p><strong>指令Cache</strong>和<strong>数据Cache</strong>——与主存结构有关</p>
</li>
<li><p>与指令执行的控制方式有关，是否流水（ch8）</p>
<blockquote>
<p>并行加工指令：提速，但产生资源的竞争、冲突</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>例如，</p>
<p>Pentium：8K指令Cache，8K数据Cache</p>
<p>PowerPC620：32K指令Cache，32K数据Cache</p>
</blockquote>
<h3 id="二、Cache-主存的地址映射"><a href="#二、Cache-主存的地址映射" class="headerlink" title="二、Cache-主存的地址映射"></a>二、Cache-主存的地址映射</h3><h4 id="1-直接映射"><a href="#1-直接映射" class="headerlink" title="1.直接映射"></a>1.直接映射</h4><blockquote>
<p>主存块只能装载/映射到指定的缓存块</p>
<p>下图中每个主存块只与一个缓存块相对应。</p>
<p>映射关系式：$i = j \ \ mod \  \ C$ 或 $i = \ j \ \ mod \ \ 2^C$</p>
<p>（$i$为缓存块号，$j$为主存块号，$C$为缓存块号）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165743565.png" alt="image-20220321165743565" style="zoom:67%;" /></p>
<ul>
<li><strong>每个缓存块i</strong>可以和<strong>若干个主存块</strong>对应</li>
<li><strong>每一个主存块j</strong>只能和<strong>一个缓存块</strong>对应</li>
</ul>
<blockquote>
<p>Cache存储体的字块是一对多的关系</p>
<p>主存块是一对一的关系</p>
<p>t位地址全相同——匹配成功，命中</p>
</blockquote>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>不够灵活</strong>。即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分利用。</li>
<li>重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而<strong>降低命中率</strong></li>
</ul>
<p><strong>总结</strong>：速度快，效率低</p>
<h4 id="2-全相联映射"><a href="#2-全相联映射" class="headerlink" title="2.全相联映射"></a>2.全相联映射</h4><blockquote>
<p>任何一个主存块可以调用任何一个空闲的缓存块</p>
<p>主存子块标记从$t$位增加到$t+c$位，使得Cache“标记”的位数增多，而且访问Cache时<strong>主存子块标记需要和Cache的全部“标记”位进行比较</strong>，才能判断出所访问的主存地址是否已在Cache内</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321165944751.png" alt="image-20220321165944751" style="zoom:80%;" /></p>
<ul>
<li><strong>主存中的任一块</strong>可以映射到<strong>缓存的任一块</strong></li>
</ul>
<blockquote>
<p>缺点：识别字段由t变为t+c，除了主存子块标记判断的位数增多，延长匹配的时间</p>
<p><strong>解决方法</strong>（书P153）相联存储器</p>
</blockquote>
<p><strong>总结</strong>：效率最高，比较时间长，硬件复杂</p>
<h4 id="3-组相联映射"><a href="#3-组相联映射" class="headerlink" title="3.组相联映射"></a>3.组相联映射</h4><blockquote>
<p>直接映射和组相联映射的结合</p>
<p>Cache分为若干组，每一组又分为若干块（2, 4, 8, 16, … ）</p>
<p>主存储器中的区数 = Cache中的组数</p>
</blockquote>
<script type="math/tex; mode=display">
i = j \mod Q</script><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321170055398.png" alt="image-20220321170055398" style="zoom:80%;" /></p>
<ul>
<li><strong>某一主存块j</strong>按<strong>模Q</strong>映射到缓存的<strong>第i组的任一块</strong></li>
</ul>
<blockquote>
<p>比直接映射方式的主存子块标记位数多，比全相联映射方式的标记位数少</p>
<p>组间为直接映射，组内为全相联映射</p>
</blockquote>
<h3 id="三、替换算法"><a href="#三、替换算法" class="headerlink" title="三、替换算法"></a>三、替换算法</h3><ol>
<li><p>先进先出（FIFO）算法</p>
<p>选择最早调入Cache的字块进行替换。</p>
</li>
<li><p>近期最小使用（LRU）算法</p>
<p>Least Recently Used</p>
<p>较好地利用访存局部性原理，替换出近期用得最少的字块</p>
<blockquote>
<p><strong>全相联映射</strong></p>
<p>每个主存块可以调用任何空闲的缓存块，能够确定哪个字块近期使用最少</p>
</blockquote>
</li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220130103055884.png" alt="image-20220130103055884" style="zoom: 80%;" /></p>
<p><strong>小结</strong></p>
<ul>
<li>直接：<strong>某一</strong>主存块<strong>只能固定</strong>映射到<strong>某一</strong>缓存块——不灵活</li>
<li>全相联：<strong>某一</strong>主存块<strong>能</strong>映射到<strong>任一</strong>缓存块——成本高</li>
<li>组相联：<strong>某一</strong>主存块只能映射到<strong>某一</strong>缓存<strong>组</strong>中的<strong>任一块</strong></li>
</ul>
<h2 id="4-4-辅助存储器（了解内容）"><a href="#4-4-辅助存储器（了解内容）" class="headerlink" title="4.4 辅助存储器（了解内容）"></a>4.4 辅助存储器（了解内容）</h2><p>（考试不要求）</p>
<h3 id="一、概述-2"><a href="#一、概述-2" class="headerlink" title="一、概述"></a>一、概述</h3><ol>
<li><p>特点：不直接与CPU交换信息</p>
</li>
<li><p>磁表面存储器的技术指标</p>
<ul>
<li><p>记录密度：道密度Dt，位密度Db</p>
</li>
<li><p>存储容量：$C = n \times k \times s$​ </p>
</li>
<li><p>平均寻址时间：寻道时间+等待时间</p>
<script type="math/tex; mode=display">
 辅存的速度
\begin{cases}
寻址时间\\
磁头读写时间
\end{cases}</script></li>
<li><p>数据传输率</p>
</li>
</ul>
</li>
</ol>
<script type="math/tex; mode=display">
     D_r = D_b \times V</script><ul>
<li>误码率：出错信息位数与读出信息的总位数之比</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>computer organization</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理：第6章 运算方法与运算器</title>
    <url>/computer_organization/computer-organization-ch6/</url>
    <content><![CDATA[<p>最终都归结于<strong>指令系统</strong></p>
<ol>
<li><p><strong>运算器的功能</strong>：数据加工处理的部件</p>
<p>数据处理：逻辑运算、算术运算</p>
<ul>
<li><p><strong>逻辑运算</strong>：逻辑指令、移位指令</p>
<p>AND, OR, XOR, NOT, TEST（测试得到结果的状态）</p>
<ul>
<li><p><strong>移位指令</strong>：算术移位、逻辑移位</p>
<p>算术移位：算术左、右移位；算术循环左、右移位；算术带进位循环左、右移位；</p>
<p>逻辑移位：逻辑左、右移</p>
</li>
</ul>
</li>
<li><p><strong>算术运算</strong>：</p>
<p>加法（进/不进位）</p>
<p>减法（进/不进位）</p>
<p>乘法、除法等各种算术类指令</p>
<blockquote>
<p>通过对数据处理的算法研究：加、减、乘、除运算，可以分解为移位（左、右）和加法两个基本操作；</p>
<p><strong>移位操作</strong>简单，一个节拍——向左或向右</p>
<p><strong>加法复杂</strong>，主要因素是<strong>进位时间</strong>的长短</p>
</blockquote>
<p>运算器是在<strong>指令的执行周期</strong>，对算术、逻辑运算类指令进行加工处理，计算机的核心部件。</p>
<span id="more"></span>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406205210360.png" alt="image-20220406205210360" style="zoom:67%;" /></p>
</li>
<li><p><strong>运算器的分类</strong></p>
<p>定点数运算器、浮点数运算器</p>
<ul>
<li><p><strong>定点数运算器</strong>（实现定点数运算），分为：整数定点运算器、小数定点运算器</p>
<ul>
<li>整数定点运算器：运算器处理的是纯整数</li>
<li>小数定点运算器：运算器处理的是纯小数</li>
</ul>
<p>纯整数和纯小数都存在局限性，改进为浮点数运算，兼容定点数运算</p>
</li>
<li><p><strong>浮点数运算器</strong>（实现浮点数的运算）</p>
<blockquote>
<p>组成：<strong>尾数、阶码</strong>。前者本身是小数定点数，后者是整数定点数</p>
</blockquote>
<p>float的加减乘除都可以分解为尾数定点运算和阶码定点运算等步骤</p>
<p>浮点数运算由定点数运算完成，故定点数的运算是运算器的基础</p>
</li>
<li><p>定点运算器与浮点运算器的比较</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406210111941.png" alt="image-20220406210111941" style="zoom: 67%;" /></p>
</li>
</ul>
</li>
<li><p><strong>运算器组成</strong></p>
<blockquote>
<p>只有加法器也是可以通过编写程序来完成乘法和除法运算</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505211155320.png" alt="image-20220505211155320" style="zoom:80%;" /></p>
<p>CPU的内部结构——示意图中缺少DMA控制器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505211245016.png" alt="image-20220505211245016" style="zoom:80%;" /></p>
<p>标志寄存器F</p>
</li>
</ol>
<p>   <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505211342200.png" alt="image-20220505211342200" style="zoom:80%;" /></p>
<p>   标志位的作用</p>
<p>   <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505211426045.png" alt="image-20220505211426045" style="zoom:80%;" /></p>
<blockquote>
<p>PC：包含段寄存器</p>
<p>FR：IF与中断允许触发器是同步的</p>
<p>（OF溢出标志位）注：定点数的溢出——运算结果超过当前存放结果目标单元的容量</p>
<p>溢出不一定有害——DMA中出现溢出通知CPU交权</p>
<p>（CF进位/借位标志位）</p>
<p>（SF结果的符号标志位）</p>
<p>（PF结果1的偶标志位，否则PF置0）</p>
<p>（ZF结果为0标志）</p>
<p>（AF辅助进位标志B-D调整）</p>
<p>（DF增量方式标志位）</p>
<p>（IF中断允许标志位）</p>
<p>（TF单步标志位）</p>
</blockquote>
<p>   <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505211548160.png" alt="image-20220505211548160" style="zoom:80%;" /></p>
<p>   <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505211608109.png" alt="image-20220505211608109" style="zoom:80%;" /></p>
<ol>
<li><p><strong>运算器的设计与实现</strong></p>
<ul>
<li><p>确定数据表示方法，找出最优算法；</p>
</li>
<li><p>确定操作数获取、操作结果生成、结果状态的生成方法；</p>
</li>
<li><p>逻辑正确、时需配合正确、驱动合理；信号稳定、功耗低等；</p>
</li>
<li><p>确定运算器的体系结构：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406210233474.png" alt="image-20220406210233474" style="zoom: 67%;" /></p>
</li>
</ul>
</li>
</ol>
<h2 id="6-1-无符号数和有符号数"><a href="#6-1-无符号数和有符号数" class="headerlink" title="6.1 无符号数和有符号数"></a>6.1 无符号数和有符号数</h2><h3 id="一、无符号数"><a href="#一、无符号数" class="headerlink" title="一、无符号数"></a>一、无符号数</h3><p>应用：存储器地址、I/O地址、指令代码、逻辑操作数等</p>
<p><strong>寄存器的位数：反应无符号数的表示范围</strong></p>
<p>通常称寄存器的位数为机器字长</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406210447646.png" alt="image-20220406210447646" style="zoom:67%;" /></p>
<h3 id="二、有符号数"><a href="#二、有符号数" class="headerlink" title="二、有符号数"></a>二、有符号数</h3><p>应用：相对地址值、立即数等</p>
<h4 id="1-机器数与真值"><a href="#1-机器数与真值" class="headerlink" title="1. 机器数与真值"></a>1. 机器数与真值</h4><p>0表示正，1表示负</p>
<blockquote>
<p>使用一位或多位二进制数表示符号</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505211840675.png" alt="image-20220505211840675" style="zoom:80%;" /></p>
<h4 id="2-原码表示法"><a href="#2-原码表示法" class="headerlink" title="2. 原码表示法"></a>2. 原码表示法</h4><ul>
<li><p>整数原码定义</p>
<script type="math/tex; mode=display">
[x]_{原} = 
\begin{cases}
0,x \qquad 2^n > x \geq 0 \\
2^n-x \qquad 0 \geq x > -2^n
\end{cases}</script><blockquote>
<p>x为真值，n为整数的位数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406210742718.png" alt="image-20220406210742718" style="zoom:67%;" /></p>
</li>
<li><p>小数的原码表示</p>
<script type="math/tex; mode=display">
[x]_{原} = 
\begin{cases}
x \qquad 1 > x \geq 0 \\
1-x \qquad 0 \geq x > -1\\
\end{cases}</script><blockquote>
<p>x为真值</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406211301317.png" alt="image-20220406211301317" style="zoom:67%;" /></p>
</li>
</ul>
<blockquote>
<p>0在原码中有两种表示方法：全0或者10000000</p>
<p>即：在原码的有效编码中，“0”占两个编码值</p>
</blockquote>
<h4 id="3-反码表示法"><a href="#3-反码表示法" class="headerlink" title="3. 反码表示法"></a>3. 反码表示法</h4><ul>
<li><p>整数定义</p>
<script type="math/tex; mode=display">
[x]_{反} = 
\begin{cases}
0,x \qquad 2^n > x \geq 0 \\
(2^{n+1}-1)+x \qquad 0 \geq x > -2^n \quad (mod \ 2^{n+1}-1)
\end{cases}</script><blockquote>
<p>x为真值，n为整数的位数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406211718152.png" alt="image-20220406211718152" style="zoom:67%;" /></p>
</li>
<li><p>小数定义</p>
<script type="math/tex; mode=display">
[x]_{反} = 
\begin{cases}
x \qquad 1 > x \geq 0 \\
(2-2^{-n}) + x \qquad 0 \geq x > -1 \quad (mod \ 2-2^{-n}) \\
\end{cases}</script><blockquote>
<p>x为真值，n为小数的位数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406211944750.png" alt="image-20220406211944750" style="zoom:67%;" /></p>
<blockquote>
<p>$[x]_{反}$有0,0000和1,1111两种形式</p>
</blockquote>
</li>
</ul>
<h4 id="4-补码表示法"><a href="#4-补码表示法" class="headerlink" title="4. 补码表示法"></a>4. 补码表示法</h4><ul>
<li><p>整数补码定义</p>
<script type="math/tex; mode=display">
[x]_{补} = 
\begin{cases}
0,x \qquad 2^n > x \geq 0 \\
2^{n+1}+x \qquad 0 > x \geq -2^n \quad (mod \ 2^{n+1}) \\
\end{cases}</script><blockquote>
<p>x为真值，n为整数的位数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406212548206.png" alt="image-20220406212548206" style="zoom:67%;" /></p>
</li>
<li><p>小数补码定义</p>
<script type="math/tex; mode=display">
[x]_{补} = 
\begin{cases}
x \qquad 1 > x \geq 0 \\
2+x \qquad 0 > x \geq -1 \quad (mod \ 2) \\
\end{cases}</script><blockquote>
<p>x为真值</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406212715214.png" alt="image-20220406212715214" style="zoom:67%;" /></p>
</li>
<li><p>求补码的快捷方式：真值为正取自身，真值为负则取反+1</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406212832689.png" alt="image-20220406212832689" style="zoom: 67%;" /></p>
</li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406213401446.png" alt="image-20220406213401446" style="zoom:67%;" /></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li><p><strong>最高位为符号位</strong>，书写上用“,”（整数）或“.”（小数）将数值部分和符号位隔开</p>
</li>
<li><p>对于正数，<strong>原码= 补码 = 反码</strong></p>
</li>
<li><p>对于负数，符号位为1，其数值部分：</p>
<p>补码：原码除符号，位外每位取反末位加1</p>
<p>反码：原码除符号位外每位取反</p>
</li>
</ol>
<h4 id="例题（必须掌握）"><a href="#例题（必须掌握）" class="headerlink" title="例题（必须掌握）"></a>例题（必须掌握）</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406213644615.png" alt="image-20220406213644615" style="zoom: 67%;" /></p>
<blockquote>
<p>拓展：条件改为——对于小数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">二进制代码</th>
<th style="text-align:center">无符号数对应的真值</th>
<th style="text-align:center">原码对应的真值</th>
<th style="text-align:center">补码对应的真值</th>
<th style="text-align:center">反码对应的真值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>00000000</strong></td>
<td style="text-align:center">0.00000000</td>
<td style="text-align:center">0.0000000</td>
<td style="text-align:center">0.0000000</td>
<td style="text-align:center">0.0000000</td>
</tr>
<tr>
<td style="text-align:center"><strong>00000001</strong></td>
<td style="text-align:center">0.00000001</td>
<td style="text-align:center">0.0000001</td>
<td style="text-align:center">0.0000001</td>
<td style="text-align:center">0.0000001</td>
</tr>
<tr>
<td style="text-align:center"><strong>00000010</strong></td>
<td style="text-align:center">0.00000010</td>
<td style="text-align:center">0.0000010</td>
<td style="text-align:center">0.0000010</td>
<td style="text-align:center">0.0000010</td>
</tr>
<tr>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>01111111</strong></td>
<td style="text-align:center">0.01111111</td>
<td style="text-align:center">0.1111111</td>
<td style="text-align:center">0.1111111</td>
<td style="text-align:center">0.1111111</td>
</tr>
<tr>
<td style="text-align:center"><strong>10000000</strong></td>
<td style="text-align:center">0.10000000</td>
<td style="text-align:center">-0.0000000</td>
<td style="text-align:center">1.0000000</td>
<td style="text-align:center"><strong>不能表示</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>10000001</strong></td>
<td style="text-align:center">0.10000001</td>
<td style="text-align:center">-0.0000001</td>
<td style="text-align:center">-0.1111111</td>
<td style="text-align:center">-0.1111110</td>
</tr>
<tr>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
<td style="text-align:center"><strong>……</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>11111101</strong></td>
<td style="text-align:center">0.11111101</td>
<td style="text-align:center">-0.1111101</td>
<td style="text-align:center">-0.0000011</td>
<td style="text-align:center">-0.0000010</td>
</tr>
<tr>
<td style="text-align:center"><strong>11111110</strong></td>
<td style="text-align:center">0.11111110</td>
<td style="text-align:center">-0.1111110</td>
<td style="text-align:center">-0.0000010</td>
<td style="text-align:center">-0.0000001</td>
</tr>
<tr>
<td style="text-align:center"><strong>11111111</strong></td>
<td style="text-align:center">0.11111111</td>
<td style="text-align:center">-0.1111111</td>
<td style="text-align:center">-0.0000001</td>
<td style="text-align:center">-0.0000000</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220406215229663.png" alt="image-20220406215229663" style="zoom: 67%;" /></p>
<h2 id="6-2-数的定点表示和浮点表示"><a href="#6-2-数的定点表示和浮点表示" class="headerlink" title="6.2 数的定点表示和浮点表示"></a>6.2 数的定点表示和浮点表示</h2><blockquote>
<p>定点数是重点，浮点数作了解</p>
</blockquote>
<p>注意点：</p>
<ol>
<li>浮点数的尾数S不能为全0</li>
</ol>
<h3 id="一、定点表示"><a href="#一、定点表示" class="headerlink" title="一、定点表示"></a>一、定点表示</h3><p>小数点固定在某一位置的数为定点数，有以下两种格式。</p>
<blockquote>
<p>小数点位于数符和第一数值位之间时，机器内的数为纯小数；</p>
<p>小数点位于数值位之后时，机器内的数为纯整数。</p>
</blockquote>
<p>在定点机中，由于小数点的位置固定不变，故当机器处理的数不是纯小数或者纯整数时，必须乘上一个比例因子，否则会产生“溢出”</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412171431311.png" alt="image-20220412171431311" style="zoom:67%;" /></p>
<h3 id="二、浮点表示"><a href="#二、浮点表示" class="headerlink" title="二、浮点表示"></a>二、浮点表示</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412171516631.png" alt="image-20220412171516631" style="zoom: 67%;" /></p>
<h4 id="1-浮点数的表示形式"><a href="#1-浮点数的表示形式" class="headerlink" title="1. 浮点数的表示形式"></a>1. 浮点数的表示形式</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412171557311.png" alt="image-20220412171557311" style="zoom:67%;" /></p>
<h4 id="2-浮点数的表示范围"><a href="#2-浮点数的表示范围" class="headerlink" title="2. 浮点数的表示范围"></a>2. 浮点数的表示范围</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412171631831.png" alt="image-20220412171631831" style="zoom:67%;" /></p>
<h2 id="6-3-定点运算"><a href="#6-3-定点运算" class="headerlink" title="6.3 定点运算"></a>6.3 定点运算</h2><blockquote>
<p>包括移位、加、减、乘、除</p>
</blockquote>
<h3 id="一、移位运算操作"><a href="#一、移位运算操作" class="headerlink" title="一、移位运算操作"></a>一、移位运算操作</h3><h4 id="1-算术移位方法"><a href="#1-算术移位方法" class="headerlink" title="1. 算术移位方法"></a>1. 算术移位方法</h4><p>算术左移、右移时符号位不变</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412171802533.png" alt="image-20220412171802533" style="zoom:80%;" /></p>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>正数的算术移位运算</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412171835286.png" alt="image-20220412171835286" style="zoom: 67%;" /></p>
<p>负数的算术移位运算</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412171850790.png" alt="image-20220412171850790" style="zoom:67%;" /></p>
<p><strong>补码和反码</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172001014.png" alt="image-20220412172001014" style="zoom:67%;" /></p>
<h4 id="2-算术移位的原理"><a href="#2-算术移位的原理" class="headerlink" title="2. 算术移位的原理"></a>2. 算术移位的原理</h4><blockquote>
<p>符号位保持不变：符号位的输出接到输入端</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411162154216.png" alt="image-20220411162154216" style="zoom: 80%;" /></p>
<ul>
<li>讨论移位丢掉1的情况</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411162555905.png" alt="image-20220411162555905" style="zoom:80%;" /></p>
<blockquote>
<p>思考：移位的硬件如何配置</p>
</blockquote>
<p>算术左移符号位SF移到进位/借位符号位CF中；右移最低位，移位到CF中。</p>
<h4 id="3-逻辑移位的原理"><a href="#3-逻辑移位的原理" class="headerlink" title="3. 逻辑移位的原理"></a>3. 逻辑移位的原理</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172059734.png" alt="image-20220412172059734" style="zoom: 80%;" /></p>
<h4 id="4-算术移位指令、逻辑移位指令"><a href="#4-算术移位指令、逻辑移位指令" class="headerlink" title="4. 算术移位指令、逻辑移位指令"></a>4. 算术移位指令、逻辑移位指令</h4><blockquote>
<p>RCL、RCR加上进位标志</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172146255.png" alt="image-20220412172146255" style="zoom:80%;" /></p>
<p>算术移位左移</p>
<blockquote>
<p>$D_0$的0不能从地线中获取，能够变化</p>
</blockquote>
<h3 id="二、定点数加、减法运算方法及实现"><a href="#二、定点数加、减法运算方法及实现" class="headerlink" title="二、定点数加、减法运算方法及实现"></a>二、定点数加、减法运算方法及实现</h3><h4 id="1-原码加减法算法特点"><a href="#1-原码加减法算法特点" class="headerlink" title="1. 原码加减法算法特点"></a>1. 原码加减法算法特点</h4><p><strong>原码加法特点</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172303437.png" alt="image-20220412172303437" style="zoom:80%;" /></p>
<p><strong>原码减法特点</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172402863.png" alt="image-20220412172402863" style="zoom: 80%;" /></p>
<p>原码和反码被淘汰的原因：两种情况，四种状态。功能部件多</p>
<h4 id="2-补码加减法运算"><a href="#2-补码加减法运算" class="headerlink" title="2. 补码加减法运算"></a>2. 补码加减法运算</h4><h5 id="a-补码加减运算公式"><a href="#a-补码加减运算公式" class="headerlink" title="a. 补码加减运算公式"></a>a. 补码加减运算公式</h5><ol>
<li><p><strong>加法</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411170416253.png" alt="image-20220411170416253" style="zoom: 80%;" /></p>
</li>
<li><p><strong>减法</strong></p>
<blockquote>
<p>B的补码和-B的补码</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172437131.png" alt="image-20220412172437131" style="zoom:80%;" /></p>
<p>特点：符号、数值一起参与运算；只做加法操作</p>
</li>
<li><p><strong>加法、减法指令</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172536447.png" alt="image-20220412172536447" style="zoom:80%;" /></p>
<blockquote>
<p>ZF：零标志位。ZF=1，目标寄存器中的值全为0</p>
<p>PF：奇偶标志位。PF=1，结果的所有bit位中1的个数为偶数</p>
</blockquote>
</li>
</ol>
<h5 id="b-举例"><a href="#b-举例" class="headerlink" title="b. 举例"></a>b. 举例</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172628341.png" alt="image-20220412172628341" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172644158.png" alt="image-20220412172644158" style="zoom: 67%;" /></p>
<h5 id="c-溢出判断"><a href="#c-溢出判断" class="headerlink" title="c. 溢出判断"></a>c. 溢出判断</h5><blockquote>
<p>实质：结果超过了数据存放的容量，放不下</p>
</blockquote>
<ol>
<li><p><strong>一位符号位判溢出</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172809098.png" alt="image-20220412172809098" style="zoom:80%;" /></p>
</li>
<li><p><strong>两位符号位判溢出</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412172845737.png" alt="image-20220412172845737" style="zoom:80%;" /></p>
</li>
</ol>
<blockquote>
<p>两位符号位溢出：多占用一位数值位，高位。空间被压缩，效率低，设计简单；——能够知道溢出为正溢出还是负溢出</p>
<p>一位符号位溢出：效率高，但电路复杂</p>
<p>常采用1位符号位溢出</p>
</blockquote>
<h4 id="3-补码加、减法运算器设计"><a href="#3-补码加、减法运算器设计" class="headerlink" title="3. 补码加、减法运算器设计"></a>3. 补码加、减法运算器设计</h4><ol>
<li><p><strong>加减运算器硬件组成</strong></p>
<blockquote>
<p>对比书和ppt中补码运算器结构示意图：不同在于ppt中的寄存器F。不能只关注溢出，关键是运算的结果处理，要对所有结果状态都要考虑到</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411173444528.png" alt="image-20220411173444528" style="zoom:80%;" /></p>
<blockquote>
<p>加法、减法，是否带进位</p>
</blockquote>
</li>
<li><p><strong>多位并行加、减法运算的硬件原理</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220413161938766.png" alt="image-20220413161938766" style="zoom:80%;" /></p>
</li>
<li><p><strong>补码加法、减法并行运算步骤分解</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220413162229840.png" alt="image-20220413162229840" style="zoom:80%;" /></p>
<p>$N_1$时间比$N_0$短，因此按照$N_0$来计算。加法操作一个节拍无法完成，至少需要2个节拍。</p>
<p>考虑进位链</p>
<p>（此处放2张补码加减法实现图）</p>
<p>节拍发生器</p>
<p><strong>进位标志位CF</strong>与最高位的进位的值相同</p>
<p><strong>符号标志位SF</strong>与最高位的值相同</p>
<p><strong>零标志位ZF</strong>取n位的或非（有1，出1）</p>
<p><strong>溢出标志位OF</strong>取$C_n$与$C_{n-1}$的异或</p>
<p><strong>偶校验标志位PF</strong>取$A_n$到$A_0$的异或再取反送入输入端</p>
<p><strong>辅助进位标志位AF</strong>：低四位运算（0,1,2,3），是3向4的进位（与CF相区别）</p>
<blockquote>
<p>AF辅助进位标志：在进行算术运算的时候，如果低字节中低4位产生进位或者借位的时候，则置1，否则置0。即当两个字节相加时，如果从第3位向第4位形成了进位，则AF=1</p>
</blockquote>
<p>（与逻辑图片）</p>
<p>电路特点：标志触发器用于完成指令</p>
<p>CF没有影响</p>
<p>处理逻辑数</p>
<p>OF没有影响，没有进位</p>
<p>ZF有关系，所有位进行或运算</p>
</li>
<li><p><strong>状态寄存器各位生成方法及硬件实现</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220413173152581.png" alt="image-20220413173152581" style="zoom:80%;" /></p>
</li>
</ol>
<h3 id="三、乘法运算"><a href="#三、乘法运算" class="headerlink" title="三、乘法运算"></a>三、乘法运算</h3><h4 id="1-分析笔算乘法"><a href="#1-分析笔算乘法" class="headerlink" title="1. 分析笔算乘法"></a>1. 分析笔算乘法</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220413173324978.png" alt="image-20220413173324978" style="zoom:80%;" /></p>
<h4 id="2-笔算乘法改进"><a href="#2-笔算乘法改进" class="headerlink" title="2. 笔算乘法改进"></a>2. 笔算乘法改进</h4><blockquote>
<p>A和B按照权重进行打开</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220413173505639.png" alt="image-20220413173505639" style="zoom:80%;" /></p>
<p>加一位，右移一位</p>
<h4 id="3-改进后的笔算乘法过程"><a href="#3-改进后的笔算乘法过程" class="headerlink" title="3. 改进后的笔算乘法过程"></a>3. 改进后的笔算乘法过程</h4><p>两个寄存器：部分积和乘数。把符号位去掉，绝对值相乘。最后空出最高位，用于符号位。</p>
<p>每次执行的过程：①若乘数最右位为1，部分积加上被乘数，部分积右移（末位移到乘数寄存器的高位）；②乘数右移，继续执行①，直到原乘数全部移出</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220413173713347.png" alt="image-20220413173713347" style="zoom:80%;" /></p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>全加器的个数与位数有关</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220413174252314.png" alt="image-20220413174252314" style="zoom:80%;" /></p>
<h4 id="4-原码乘法"><a href="#4-原码乘法" class="headerlink" title="4. 原码乘法"></a>4. 原码乘法</h4><ol>
<li><p>原码一位乘运算规则</p>
<blockquote>
<p>特点：</p>
<p>①绝对值运算</p>
<p>②用移位的次数判断乘法是否结束</p>
<p>③逻辑移位</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418160616645.png" alt="image-20220418160616645" style="zoom:80%;" /></p>
</li>
<li><p>原码一位乘递推公式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418160642037.png" alt="image-20220418160642037" style="zoom:80%;" /></p>
</li>
<li><p>原码一位乘的硬件配置</p>
<blockquote>
<p>开始准备阶段，存放部分累加和的A寄存器和计数器C清零。放数：被乘数原码放在X，乘数原码放在Q。</p>
<p>Q的最低位$Q_n$是Q末尾的输出，判断是否进行加被乘数的运算（1-A加X，0-A加0）。</p>
<p>结束后，把符号位S取出来，放到A的最高位$A_0$。还要把乘法标记$G_M$清零</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418161346366.png" alt="image-20220418161346366" style="zoom:80%;" /></p>
<blockquote>
<p>上面的配置图还需要<strong>节拍发生器</strong>来控制系统稳定工作</p>
<p>节拍有两种：①生成部分积；②右移，前者节拍时间更长；在实际过程中，使用前者节拍作为节拍发生器的节拍。</p>
</blockquote>
<p>有很多附加动作，消耗时间大</p>
</li>
</ol>
<h4 id="5-补码乘法"><a href="#5-补码乘法" class="headerlink" title="5. 补码乘法"></a>5. 补码乘法</h4><ol>
<li><p>补码一位乘运算规则</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418164234429.png" alt="image-20220418164234429" style="zoom:80%;" /></p>
<ul>
<li>Booth算法（被乘数、乘数符号任意）</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418164413023.png" alt="image-20220418164413023" style="zoom:80%;" /></p>
<ul>
<li>Booth算法递推公式</li>
</ul>
<blockquote>
<p>后项减前项结果决定是否加x补码或者-x补码或者不加，然后右移</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418164627575.png" alt="image-20220418164627575" style="zoom:80%;" /></p>
<ol>
<li><p><strong>例题</strong></p>
<blockquote>
<p>移位4次，求和5次（乘数符号位参与）</p>
<p>补码右移用符号位的数值补高位</p>
<p>最后一次影响精度</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418164915035.png" alt="image-20220418164915035" style="zoom:80%;" /></p>
</li>
</ol>
</li>
<li><p>Booth算法的硬件配置</p>
<blockquote>
<p>输出负数的补码：接到负输出端，末位+1</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418170642139.png" alt="image-20220418170642139" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418171739880.png" alt="image-20220418171739880" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418172034885.png" alt="image-20220418172034885" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418172143592.png" alt="image-20220418172143592" style="zoom:67%;" /></p>
</li>
</ol>
<h4 id="乘法小结"><a href="#乘法小结" class="headerlink" title="乘法小结"></a>乘法小结</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418171322634.png" alt="image-20220418171322634" style="zoom:80%;" /></p>
<h3 id="四、除法运算"><a href="#四、除法运算" class="headerlink" title="四、除法运算"></a>四、除法运算</h3><h4 id="1-分析笔算除法"><a href="#1-分析笔算除法" class="headerlink" title="1. 分析笔算除法"></a>1. 分析笔算除法</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418173057291.png" alt="image-20220418173057291" style="zoom:80%;" /></p>
<h4 id="2-笔算除法和机器除法的比较"><a href="#2-笔算除法和机器除法的比较" class="headerlink" title="2. 笔算除法和机器除法的比较"></a>2. 笔算除法和机器除法的比较</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418173159908.png" alt="image-20220418173159908" style="zoom:80%;" /></p>
<h4 id="3-原码除法"><a href="#3-原码除法" class="headerlink" title="3. 原码除法"></a>3. 原码除法</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418173420700.png" alt="image-20220418173420700" style="zoom:80%;" /></p>
<ol>
<li><p>恢复余数法</p>
<blockquote>
<p>特点：<strong>硬件无法实现</strong></p>
<p>被除数和商都左移一位，商寄存器留出低位。</p>
<p>每次出来一位结果放在商寄存器的低位。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418174058127.png" alt="image-20220418174058127" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418174114824.png" alt="image-20220418174114824" style="zoom:80%;" /></p>
</li>
<li><p>不恢复余数法</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220418174349585.png" alt="image-20220418174349585" style="zoom:80%;" /></p>
</li>
</ol>
<h2 id="6-4-浮点四则运算"><a href="#6-4-浮点四则运算" class="headerlink" title="6.4 浮点四则运算"></a>6.4 浮点四则运算</h2><h3 id="一、浮点加减运算"><a href="#一、浮点加减运算" class="headerlink" title="一、浮点加减运算"></a>一、浮点加减运算</h3><script type="math/tex; mode=display">
x=S_x \times 2^{j_x} \qquad y=S_y \times 2^{j_y}</script><h4 id="1-对阶"><a href="#1-对阶" class="headerlink" title="1. 对阶"></a>1. 对阶</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215331498.png" alt="image-20220505215331498" style="zoom:80%;" /></p>
<h4 id="2-尾数求和"><a href="#2-尾数求和" class="headerlink" title="2. 尾数求和"></a>2. 尾数求和</h4><p>（举例）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215419266.png" alt="image-20220505215419266" style="zoom:80%;" /></p>
<h4 id="3-规格化"><a href="#3-规格化" class="headerlink" title="3. 规格化"></a>3. 规格化</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215403126.png" alt="image-20220505215403126" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215449370.png" alt="image-20220505215449370" style="zoom:80%;" /></p>
<p>（例题6.27）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215514122.png" alt="image-20220505215514122" style="zoom:80%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215554895.png" alt="image-20220505215554895" style="zoom:80%;" /></p>
<h4 id="4-舍入"><a href="#4-舍入" class="headerlink" title="4. 舍入"></a>4. 舍入</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215541803.png" alt="image-20220505215541803" style="zoom:80%;" /></p>
<h4 id="5-溢出判断"><a href="#5-溢出判断" class="headerlink" title="5. 溢出判断"></a>5. 溢出判断</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505215622898.png" alt="image-20220505215622898" style="zoom:80%;" /></p>
<h3 id="二、浮点乘除运算"><a href="#二、浮点乘除运算" class="headerlink" title="二、浮点乘除运算"></a>二、浮点乘除运算</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420162715858.png" alt="image-20220420162715858" style="zoom:80%;" /></p>
<blockquote>
<p>硬件复杂一些</p>
</blockquote>
<p>掌握程度：浮点数运算的步骤。</p>
<p>加减：把阶放成相同</p>
<p>乘除：两个定点数运算</p>
<h2 id="6-5-算术逻辑单元"><a href="#6-5-算术逻辑单元" class="headerlink" title="6.5 算术逻辑单元"></a>6.5 算术逻辑单元</h2><p><strong>解决问题</strong>：移位、算术运算</p>
<h3 id="一、ALU电路"><a href="#一、ALU电路" class="headerlink" title="一、ALU电路"></a>一、ALU电路</h3><blockquote>
<p>74181</p>
<p>$S_3-S_0$控制译码</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420163028296.png" alt="image-20220420163028296" style="zoom:80%;" /></p>
<h3 id="二、快速进位链"><a href="#二、快速进位链" class="headerlink" title="二、快速进位链"></a>二、快速进位链</h3><h4 id="1-并行加法器"><a href="#1-并行加法器" class="headerlink" title="1.并行加法器"></a>1.并行加法器</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420163348777.png" alt="image-20220420163348777" style="zoom:80%;" /></p>
<h4 id="2-串行进位链"><a href="#2-串行进位链" class="headerlink" title="2.串行进位链"></a>2.串行进位链</h4><blockquote>
<p>注意串行进位链的延时</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420163512250.png" alt="image-20220420163512250" style="zoom:80%;" /></p>
<h4 id="3-并行进位链（先行进位，跳跃进位）"><a href="#3-并行进位链（先行进位，跳跃进位）" class="headerlink" title="3.并行进位链（先行进位，跳跃进位）"></a>3.并行进位链（先行进位，跳跃进位）</h4><blockquote>
<p>二级进位，最慢的是与或非门加上与非门，一共2.5$t_y$</p>
<p>电路复杂，速度快</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420163858209.png" alt="image-20220420163858209" style="zoom:80%;" /></p>
<ol>
<li><p><strong>单重分组跳跃进位链</strong></p>
<p>组内并行进位，组间串行进位</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420164338906.png" alt="image-20220420164338906" style="zoom:80%;" /></p>
</li>
<li><p><strong>双重分组跳跃进位链</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505223944688.png" alt="image-20220505223944688" style="zoom:80%;" /></p>
</li>
<li><p><strong>双重分组跳跃进位链：大组进位分析</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505224049764.png" alt="image-20220505224049764" style="zoom:80%;" /></p>
</li>
<li><p><strong>双重分组跳跃进位链的大组进位线路</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505224132552.png" alt="image-20220505224132552" style="zoom:80%;" /></p>
</li>
<li><p><strong>双重分组跳跃进位链的小组进位线路</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505224213231.png" alt="image-20220505224213231" style="zoom:80%;" /></p>
</li>
<li><p><strong>n=16双重分组跳跃进位链</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505224248672.png" alt="image-20220505224248672" style="zoom:80%;" /></p>
</li>
<li><p><strong>n=32双重分组跳跃进位链</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220505224316996.png" alt="image-20220505224316996" style="zoom:80%;" /></p>
</li>
</ol>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>computer organization</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理：第7章 指令系统</title>
    <url>/computer_organization/computer-organization-ch7/</url>
    <content><![CDATA[<p>计算机的最高指挥：晶振——产生指令。</p>
<p>计算机在指令驱动下运行。指令组成程序</p>
<h2 id="7-1-机器指令"><a href="#7-1-机器指令" class="headerlink" title="7.1 机器指令"></a>7.1 机器指令</h2><p>机器语言：由一条条语句构成，每一条语句又能准确表达某种语义</p>
<p>机器指令：每一条机器语言的语句</p>
<p>指令系统：全部机器指令的集合</p>
<span id="more"></span>
<h3 id="一、指令的一般格式"><a href="#一、指令的一般格式" class="headerlink" title="一、指令的一般格式"></a>一、指令的一般格式</h3><h4 id="1-操作码"><a href="#1-操作码" class="headerlink" title="1.操作码"></a>1.操作码</h4><p>反映机器做什么操作</p>
<blockquote>
<p>用来指明该指令所要完成的操作，</p>
<p>如：加法、减法、传送、移位、转移等</p>
</blockquote>
<p>位数反映操作种类（机器允许的指令条数）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503140908602.png" alt="image-20220503140908602" style="zoom: 50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503141005021.png" alt="image-20220503141005021" style="zoom: 50%;" /></p>
<p>三地址指令操作码每减少一种可多构成$2^4$种二地址指令</p>
<p>二地址指令操作码每减少一种可多构成$2^4$种一地址指令</p>
<h4 id="2-地址码"><a href="#2-地址码" class="headerlink" title="2.地址码"></a>2.地址码</h4><p>用来指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址。</p>
<blockquote>
<p>“地址”可以是主存的地址，也可以是寄存器的地址，I/O设备的地址</p>
</blockquote>
<h5 id="1-四地址"><a href="#1-四地址" class="headerlink" title="1. 四地址"></a>1. 四地址</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503141141637.png" alt="image-20220503141141637" style="zoom: 50%;" /></p>
<h5 id="2-三地址"><a href="#2-三地址" class="headerlink" title="2. 三地址"></a>2. 三地址</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503141155067.png" alt="image-20220503141155067" style="zoom: 50%;" /></p>
<h5 id="3-二地址"><a href="#3-二地址" class="headerlink" title="3. 二地址"></a>3. 二地址</h5><p>4次：取A1，A2，写A1，取指令</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503142230997.png" alt="image-20220503142230997" style="zoom: 50%;" /></p>
<h5 id="4-一地址"><a href="#4-一地址" class="headerlink" title="4. 一地址"></a>4. 一地址</h5><p>2次：取A1，取指令</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503143841338.png" alt="image-20220503143841338" style="zoom: 50%;" /></p>
<h5 id="5-零地址"><a href="#5-零地址" class="headerlink" title="5. 零地址"></a>5. 零地址</h5><p>子程序返回（RET）、中断返回（IRET）——没有地址码，操作数的地址隐含在堆栈指针SP中</p>
<h3 id="二、指令字长"><a href="#二、指令字长" class="headerlink" title="二、指令字长"></a>二、指令字长</h3><p>指令字长取决于$\begin{cases} 操作码的长度\\ 操作数地址的长度 \\ 操作数地址的个数 \\  \end{cases}$</p>
<ol>
<li><p>指令字长<strong>固定</strong></p>
<p>指令字长=存储字长</p>
<blockquote>
<p>早期的计算机，访问某个存储单元便可取出一条完整的指令或一个完整的数据。控制方式简单</p>
</blockquote>
</li>
<li><p>指令字长<strong>可变</strong></p>
<p>按字节的倍数变化</p>
<blockquote>
<p>为了提高指令的运行速度和节省存储空间，通常尽可能把常用的指令（如：数据传送指令、算逻运算指令等）设计成单字长或短字长格式的指令</p>
</blockquote>
</li>
</ol>
<p><strong>小结</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503144647612.png" alt="image-20220503144647612" style="zoom: 50%;" /></p>
<h2 id="7-2-操作数类型和操作类型"><a href="#7-2-操作数类型和操作类型" class="headerlink" title="7.2 操作数类型和操作类型"></a>7.2 操作数类型和操作类型</h2><h3 id="一、操作数类型"><a href="#一、操作数类型" class="headerlink" title="一、操作数类型"></a>一、操作数类型</h3><p>常见的操作数类型：地址、数字、字符、逻辑数据</p>
<ul>
<li><strong>地址</strong>：无符号的整数。涉及操作数地址的计算</li>
<li><strong>数字</strong>：定点数、浮点数和十进制数</li>
<li><strong>字符</strong>：普遍采用ASCII码</li>
<li><strong>逻辑数据</strong>：</li>
</ul>
<h3 id="二、数据在存储器中的存放方式"><a href="#二、数据在存储器中的存放方式" class="headerlink" title="二、数据在存储器中的存放方式"></a>二、数据在存储器中的存放方式</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503150538893.png" alt="image-20220503150538893" style="zoom: 50%;" /></p>
<h3 id="三、操作类型"><a href="#三、操作类型" class="headerlink" title="三、操作类型"></a>三、操作类型</h3><h4 id="1-数据传送"><a href="#1-数据传送" class="headerlink" title="1. 数据传送"></a>1. 数据传送</h4><p>包括：<strong>寄存器与寄存器</strong>、<strong>寄存器与存储单元</strong>、<strong>存储单元与存储单元</strong>之间的传送。</p>
<blockquote>
<p>如：从源到目的之间的传送、对存储器读（LOAD）和写（STORE）、交换源和目的的内容、置1、清0、进栈、出栈等</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420171448556.png" alt="image-20220420171448556" style="zoom: 80%;" /></p>
<h4 id="2-算术逻辑操作"><a href="#2-算术逻辑操作" class="headerlink" title="2. 算术逻辑操作"></a>2. 算术逻辑操作</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420171520628.png" alt="image-20220420171520628" style="zoom:80%;" /></p>
<h4 id="3-移位操作"><a href="#3-移位操作" class="headerlink" title="3. 移位操作"></a>3. 移位操作</h4><blockquote>
<p>移位操作所需时间远比乘除操作执行时间短，用来代替简单的乘法和除法运算</p>
</blockquote>
<ul>
<li>算术移位：对<strong>有符号数</strong>的乘/除以2的运算</li>
<li>逻辑移位：<strong>无符号数</strong></li>
<li>循环移位（带进位和不带进位）</li>
</ul>
<h4 id="4-转移"><a href="#4-转移" class="headerlink" title="4. 转移"></a>4. 转移</h4><p>多数情况下，计算机按照顺序执行程序的每条指令，但有时需要改变顺序，采用<strong>转移类指令来完成</strong></p>
<p>分为：无条件转移、条件转移、跳转、过程调用与返回、陷阱等</p>
<ul>
<li><p><strong>无条件转移</strong></p>
<p>不受任何条件约束，可直接把程序转移到下一条需执行指令的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP X	;将指令地址无条件转至X</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>条件转移</strong></p>
<p>根据当前指令的执行结果来决定是否需要转移。</p>
<p>若条件满足，则转移；不满足，则继续按顺序执行。</p>
<p>一般机器都能提供一些条件码，这些条件码是某些操作的结果</p>
<blockquote>
<p>如：对于</p>
<p>零标志位ZF，结果为0，ZF=1；</p>
<p>负标志位SF，结果为负，SF=1；</p>
<p>溢出标志位OF，结果有溢出，OF=1；</p>
<p>进位标志位CF，最高位有进位，CF=1；</p>
<p>奇偶标志位PF，结果呈偶数，PF=1；</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BRO X	; 若结果（有符号数）溢出(OF)，则指令跳转到X</span><br><span class="line">BRC Y	; 若最高位有进位(CF)，则指令跳转到Y</span><br><span class="line">SKP DZ ; 暗示其下一条指令将被跳过，隐含了转移地址是SKP后的第二条指令，条件是完成触发器D为0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420171635065.png" alt="image-20220420171635065" style="zoom:80%;" /></p>
<ul>
<li><p><strong>调用和返回</strong></p>
<blockquote>
<p>类似中断</p>
</blockquote>
<p>在编写程序时，有些具有特定功能的程序段会被反复使用。为避免重复编写，可将这些程序段设定为独立子程序，当需要执行某子程序时，只需子程序调用指令即可。</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420171657961.png" alt="image-20220420171657961" style="zoom:80%;" /></p>
<ul>
<li><p><strong>陷阱（Trap）与陷阱指令</strong></p>
<p>陷阱时一种意外事故的中断</p>
<blockquote>
<p>如，机器在运行中，可能会出现电源电压不稳定、存储器校验出差错、输入输出设备出现了故障、用户使用未被定义的指令、除数出现0、运算结果溢出、特权指令等</p>
</blockquote>
<p>致使计算机不能正常工作，采取措施，发出陷阱信号。暂停当前程序的执行，转入故障处理程序，进行相应的故障处理。</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420171756033.png" alt="image-20220420171756033" style="zoom:80%;" /></p>
<h4 id="5-输入输出"><a href="#5-输入输出" class="headerlink" title="5.输入输出"></a>5.输入输出</h4><blockquote>
<p>AL是8bit，AX是16bit</p>
<p>输入：端口送入CPU</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220420171857720.png" alt="image-20220420171857720" style="zoom:80%;" /></p>
<h2 id="7-3-寻址方式"><a href="#7-3-寻址方式" class="headerlink" title="7.3 寻址方式"></a>7.3 寻址方式</h2><blockquote>
<p>已知指令的顺序寻址、中断隐指令、开机第一条指令</p>
</blockquote>
<p>开机第一条指令的位置：FFFFFFF0</p>
<p>0xFFFF0 指令：跳转到F000:EO5B</p>
<blockquote>
<p>参考资料：<a href="https://blog.csdn.net/u010383242/article/details/50586782">开机后的第一条指令</a></p>
</blockquote>
<p>中断隐指令怎么找</p>
<h3 id="一、指令寻址"><a href="#一、指令寻址" class="headerlink" title="一、指令寻址"></a>一、指令寻址</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503153526386.png" alt="image-20220503153526386" style="zoom: 50%;" /></p>
<h3 id="二、数据寻址"><a href="#二、数据寻址" class="headerlink" title="二、数据寻址"></a>二、数据寻址</h3><p>指令字中必须设一字段来指明属于哪一种寻址方式——<strong>寻址特征位</strong>，记作M</p>
<p>指令的地址码字段通常都不代表操作数的真实地址，把它称为<strong>形式地址</strong>，记作A</p>
<p>操作数的真实地址称为<strong>有效地址</strong>，记作EA</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503153543995.png" alt="image-20220503153543995" style="zoom: 50%;" /></p>
<blockquote>
<p>假设指令字长、存储字长、机器字长均相同</p>
</blockquote>
<h4 id="1-立即寻址"><a href="#1-立即寻址" class="headerlink" title="1. 立即寻址"></a>1. 立即寻址</h4><p>特点：操作数本身设在指令字内，即：<strong>形式地址A不是操作数的地址，而是操作数本身，又称之为立即数</strong></p>
<blockquote>
<p>立即数是有符号数，以<strong>补码</strong>形式保存</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503153600596.png" alt="image-20220503153600596" style="zoom: 50%;" /></p>
<p>优点：只要取出指令，便可立即获得操作数，在执行阶段不必再访问存储器</p>
<p>A的位数限制立即数的范围。</p>
<h4 id="2-直接寻址"><a href="#2-直接寻址" class="headerlink" title="2. 直接寻址"></a>2. 直接寻址</h4><p>特点：指令字中的形式地址A就是操作数的真实地址EA，即：EA=A</p>
<blockquote>
<p>有效地址由形式地址直接给出</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503153713905.png" alt="image-20220503153713905" style="zoom: 50%;" /></p>
<p>优点：寻找操作数简单，不需要专门计算操作数的地址，在指令执行阶段对主存只访问一次。</p>
<p>A的位数限制了操作数的寻址范围，而且必须修改A的值才能修改操作数的地址。</p>
<h4 id="3-隐含寻址"><a href="#3-隐含寻址" class="headerlink" title="3. 隐含寻址"></a>3. 隐含寻址</h4><blockquote>
<p>操作数地址隐含在操作码或某个寄存器中</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154526162.png" alt="image-20220503154526162" style="zoom:50%;" /></p>
<h4 id="4-间接寻址"><a href="#4-间接寻址" class="headerlink" title="4. 间接寻址"></a>4. 间接寻址</h4><blockquote>
<p>有效地址由形式地址间接给出。</p>
<p>类似于指针，有效地址是形式地址单元的数值</p>
<p>2次访存</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154543218.png" alt="image-20220503154543218" style="zoom: 50%;" /></p>
<h4 id="5-寄存器寻址"><a href="#5-寄存器寻址" class="headerlink" title="5. 寄存器寻址"></a>5. 寄存器寻址</h4><blockquote>
<p>有效地址即为寄存器编号</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154600520.png" alt="image-20220503154600520" style="zoom:50%;" /></p>
<h4 id="6-寄存器间接寻址"><a href="#6-寄存器间接寻址" class="headerlink" title="6. 寄存器间接寻址"></a>6. 寄存器间接寻址</h4><blockquote>
<p>有效地址在寄存器内（访问寄存器内容）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154617609.png" alt="image-20220503154617609" style="zoom: 50%;" /></p>
<h4 id="7-基址寻址"><a href="#7-基址寻址" class="headerlink" title="7. 基址寻址"></a>7. 基址寻址</h4><ol>
<li><p>采用专用寄存器作基址寄存器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154638769.png" alt="image-20220503154638769" style="zoom:50%;" /></p>
</li>
<li><p>采用通用寄存器$R_0$作基址寄存器</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154658187.png" alt="image-20220503154658187" style="zoom:50%;" /></p>
</li>
</ol>
<h4 id="8-变址寻址"><a href="#8-变址寻址" class="headerlink" title="8. 变址寻址"></a>8. 变址寻址</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154716131.png" alt="image-20220503154716131" style="zoom:50%;" /></p>
<h4 id="9-相对寻址"><a href="#9-相对寻址" class="headerlink" title="9. 相对寻址"></a>9. 相对寻址</h4><blockquote>
<p>EA=(PC)+A，A是相对与当前指令的位移量</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154737331.png" alt="image-20220503154737331" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154815612.png" alt="image-20220503154815612" style="zoom:50%;" /></p>
<h4 id="10-堆栈寻址"><a href="#10-堆栈寻址" class="headerlink" title="10. 堆栈寻址"></a>10. 堆栈寻址</h4><blockquote>
<p>堆栈指令调用内存（堆栈指令或者内存单元操作）</p>
</blockquote>
<p>是一种数据格式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503154832850.png" alt="image-20220503154832850" style="zoom:80%;" /></p>
<h2 id="7-4-指令格式举例"><a href="#7-4-指令格式举例" class="headerlink" title="7.4 指令格式举例"></a>7.4 指令格式举例</h2><h3 id="一、设计指令格式时应考虑的因素"><a href="#一、设计指令格式时应考虑的因素" class="headerlink" title="一、设计指令格式时应考虑的因素"></a>一、设计指令格式时应考虑的因素</h3><h4 id="1-指令系统的兼容性"><a href="#1-指令系统的兼容性" class="headerlink" title="1. 指令系统的兼容性"></a>1. 指令系统的兼容性</h4><p>向上兼容</p>
<h4 id="2-其他因素"><a href="#2-其他因素" class="headerlink" title="2. 其他因素"></a>2. 其他因素</h4><ul>
<li><strong>操作类型</strong>：包括指令个数及操作的难易程度</li>
<li><strong>数据类型</strong>：确定哪些数据类型可参与操作</li>
<li><strong>指令格式</strong>：指令字长是否固定；操作码位数、是否采用扩展操作码技术，地址码位数、地址个数、寻址方式类型</li>
<li><strong>寻址方式</strong>：指令寻址、操作数寻址</li>
<li><strong>寄存器个数</strong>：寄存器的多少直接影响指令的执行时间</li>
</ul>
<h3 id="二、指令格式举例"><a href="#二、指令格式举例" class="headerlink" title="二、指令格式举例"></a>二、指令格式举例</h3><ol>
<li><p>PDP-8</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503155132681.png" alt="image-20220503155132681" style="zoom:50%;" /></p>
</li>
<li><p>PDP-11</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220424161443696.png" alt="image-20220424161443696" style="zoom: 80%;" /></p>
</li>
<li><p>IBM 360</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220424161616537.png" alt="image-20220424161616537" style="zoom:80%;" /></p>
</li>
<li><p>Intel 8086</p>
<blockquote>
<p>零地址是空操作数</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220424161810340.png" alt="image-20220424161810340" style="zoom:80%;" /></p>
</li>
</ol>
<blockquote>
<p>要求：条件一定，写出指令格式</p>
</blockquote>
<h2 id="考试题型总结——设计指令系统"><a href="#考试题型总结——设计指令系统" class="headerlink" title="考试题型总结——设计指令系统"></a>考试题型总结——设计指令系统</h2><p>操作码多少位</p>
<p>寻址特征位（是否选择——硬件设计有关）</p>
<p>M寻址特征位</p>
<p>A形式地址</p>
<h2 id="7-5-RISC技术"><a href="#7-5-RISC技术" class="headerlink" title="7.5 RISC技术"></a>7.5 RISC技术</h2><p>RISC(Reduced Instruction set computer)</p>
<p>硬件简单，寻址方式、指令砍掉，无法运行CISC程序，因此不易指令系统兼容</p>
<h3 id="一、RISC-的产生和发展"><a href="#一、RISC-的产生和发展" class="headerlink" title="一、RISC 的产生和发展"></a>一、RISC 的产生和发展</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503155316293.png" alt="image-20220503155316293" style="zoom:50%;" /></p>
<h3 id="二、RISC-的主要特征"><a href="#二、RISC-的主要特征" class="headerlink" title="二、RISC 的主要特征"></a>二、RISC 的主要特征</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503155338256.png" alt="image-20220503155338256" style="zoom:50%;" /></p>
<h3 id="三、CISC-的主要特征"><a href="#三、CISC-的主要特征" class="headerlink" title="三、CISC 的主要特征"></a>三、CISC 的主要特征</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503155402226.png" alt="image-20220503155402226" style="zoom: 50%;" /></p>
<h3 id="四、RISC和CISC-的比较"><a href="#四、RISC和CISC-的比较" class="headerlink" title="四、RISC和CISC 的比较"></a>四、RISC和CISC 的比较</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220503155423222.png" alt="image-20220503155423222" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>computer organization</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/undefined/hello-world/</url>
    <content><![CDATA[<p>你好，Hexo！你好，世界！</p>
<p>欢迎来到我的博客</p>
<p>我将持续记录日常学习、生活的点点滴滴</p>
]]></content>
  </entry>
  <entry>
    <title>数理逻辑：绪论</title>
    <url>/mathematical_logic/mathematical-logic-ch0/</url>
    <content><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>数理逻辑是用数学的方法研究<strong>推理</strong>，特别是研究数学中的推理</p>
<p>推理的前提和结论都是命题，命题的真假与<strong>内容是否符合现实</strong>有关。</p>
<script type="math/tex; mode=display">
premises 前提 \quad（命题）\\
\downarrow  \quad reason 推理 \\
conclusions 结论 \quad （命题）\\</script><span id="more"></span>
<ol>
<li><p>正确的推理：从”正确的前提“能得到”正确的结论“的推理。</p>
<p>推理正确——可推导关系，属于<code>演绎逻辑</code>（与之相对的是<code>归纳逻辑</code>）</p>
<p>正确的前提：前提为真</p>
<p>正确的结论：结论为真</p>
</li>
<li><p>推理正确与否<strong>与前提和结论中命题是否为真命题没有关系</strong>。</p>
<p><strong>推理的正确性与命题的逻辑形式有关</strong></p>
<p><strong>命题内容决定命题的真假</strong></p>
<script type="math/tex; mode=display">
命题：
\begin{cases}
内容 \\
逻辑形式（抽象） \\
\end{cases}</script><blockquote>
<p>所有中学生打网球（前提）</p>
<p>王军不打网球（前提）</p>
<p>王军不是中学生（结论）</p>
<p>——推理正确，不是所有命题都为真命题</p>
</blockquote>
<p>上述推理的逻辑形式为：</p>
<blockquote>
<p>S中所有元有R性质（前提）</p>
<p>a没有R性质（前提）</p>
<p>a不是S中的元（结论）</p>
</blockquote>
</li>
<li><p>数理逻辑中，用自然语言陈述命题会带来不方便</p>
</li>
<li><p>数理逻辑的研究语言为：对象语言、元语言</p>
<ul>
<li>对象语言：被研究对象的语言。<strong>形式语言</strong>，用符号构成的公式来代替自然语言中的命题，<strong>没有二义性</strong><ul>
<li>语义：符号，公式的含义</li>
<li>语法：由符号构成的公式的形状和语法结构</li>
</ul>
</li>
<li>元语言：辅助描述对象语言。自然语言</li>
</ul>
</li>
<li><p>数理逻辑产生的动机：将一切推理的正确性化归于计算的通用代数</p>
<ul>
<li>建立一种普遍适用的精确的科学语言</li>
<li>建立一种推理的演算</li>
</ul>
</li>
<li><p>预备知识：</p>
<ul>
<li><p>集合</p>
<p>集合S上的（n元）关系R</p>
<p>外延：具有概念所反映的特有属性的所有事物</p>
<p>内涵：概念中所反映事物的特有属性</p>
</li>
<li><p>归纳定义和归纳证明</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第1节 命题逻辑的基本概念</title>
    <url>/mathematical_logic/mathematical-logic-ch1/</url>
    <content><![CDATA[<h1 id="1-1-命题与联结词"><a href="#1-1-命题与联结词" class="headerlink" title="1.1 命题与联结词"></a>1.1 命题与联结词</h1><h2 id="命题与真值"><a href="#命题与真值" class="headerlink" title="命题与真值"></a>命题与真值</h2><ul>
<li>命题：能<strong>唯一</strong>确定<strong>真假值</strong>的<strong>陈述句</strong></li>
<li>命题的真值：一个命题的真or假</li>
<li>真值的取值：真or假</li>
<li>真命题与假命题：由内容是否符合实际情况决定</li>
</ul>
<p>注意：</p>
<ul>
<li>感叹句、祈使句、疑问句、<strong>悖论</strong>不是命题</li>
<li>判断结果不唯一确定的陈述句不是命题（针对真值多种取值的情况）</li>
</ul>
<span id="more"></span>
<h2 id="命题分类"><a href="#命题分类" class="headerlink" title="命题分类"></a>命题分类</h2><ul>
<li>简单命题（原子命题）：不能分解成更简单的命题（基本单位）</li>
<li>命题符合：由简单命题通过<strong>联结词</strong>联结而成的命题</li>
<li>联结词有5类：与（$\land$​​）、或（$\vee$​）、非（$\neg$​）、蕴含（如果…那么（则）…，$\to$）、等价（当且仅当，$\leftrightarrow$）。$\neg$​为单联结词</li>
</ul>
<h2 id="简单命题符号化"><a href="#简单命题符号化" class="headerlink" title="简单命题符号化"></a>简单命题符号化</h2><ul>
<li>用小写英文字母$p,q,r,…,$$p_i$,$q_i$,$r_i(i\geq1)$表示简单命题</li>
<li>用”1“表示真，用”0“表示假</li>
</ul>
<h2 id="否定、合取、析取联结词"><a href="#否定、合取、析取联结词" class="headerlink" title="否定、合取、析取联结词"></a>否定、合取、析取联结词</h2><ul>
<li><p><strong>定义1</strong>：设 p为命题，<strong>复合命题</strong>“非p”(或“p的否定”) 称为 p的<strong>否定式</strong>，记作$\neg$​p，符号$\neg$​称作<strong>否定联结词</strong>。 </p>
<p>规定: $\neg$​p 为真当且仅当<u>p为假</u>。</p>
</li>
<li><p><strong>定义2</strong>：设p,q为两个命题，复合命题“p并且q”(或 “p 与 q”)称为 p与q的<strong>合取式</strong>，记作p∧q，∧称作<strong>合取联结词</strong>。</p>
<p>规定: p∧q为真当且仅当<u>p与q同时为真</u>。</p>
</li>
<li><p><strong>定义3</strong>：设p, q为两个命题，复合命题“p或q”称作 p 与 q 的<strong>析取式</strong>，记作p∨q，∨称作<strong>析取联结词</strong>。 </p>
<p>规定: p∨q为假当且仅当<u>p与q同时为假</u>。</p>
</li>
<li><p>关于”或“：$\begin{cases} 相容或：可兼 \qquad（例如：我上街买矿泉水或者买饮料） \\ 排斥或（异或）：不相容或,不可兼 \qquad （例如：某人星期一来或者星期二来） \\ \end{cases}$​</p>
<blockquote>
<p>又如：</p>
<p>ab = 0——a = 0 或 b = 0 </p>
<p>(a-1)·(a-2) = 0——a = 1 或 a = 2</p>
</blockquote>
<p>规定：数学上取<strong>相容或</strong></p>
<p>排斥或：($\neg$ p $\land$q) $\vee$ (p$\land$$\neg$ q)</p>
</li>
</ul>
<h2 id="蕴含联结词"><a href="#蕴含联结词" class="headerlink" title="蕴含联结词"></a>蕴含联结词</h2><ul>
<li><p><strong>定义4</strong>：设p, q为两个命题，复合命题”如果p, 则q” 称作p与q的<strong>蕴涵式</strong>，记作p→q， </p>
<p>并称p是蕴涵式的<strong>前件</strong>， q为蕴涵式的<strong>后件</strong>，→称作<strong>蕴涵联结词</strong>。 </p>
<p>规定：p→q为假当且仅当<u>p为真q为假</u>。</p>
<blockquote>
<p>蕴含举例：</p>
<p>对任何x，如果x&gt;3，则$x^2$&gt;9 真命题 </p>
<p>令x=4，如果 4&gt;3，则16&gt;9（前提真，结论真） </p>
<p>令x=-4，如果 -4&gt;3，则16&gt;9（前提假，结论真）</p>
<p>令x=-2，如果 -2&gt;3, 则4&gt;9（前提假，结论假）——<strong>整个</strong>命题为真</p>
<p><strong>对于该蕴含命题（真命题），不存在前提真，结论假的情况</strong></p>
</blockquote>
</li>
<li><p>要证明符合命题：如果p, 则q</p>
<ul>
<li>一般情况下，<strong>由前提真，证明结论真</strong></li>
<li>特殊情况下，<strong>前提为假，没有什么可做的</strong></li>
</ul>
<blockquote>
<p>可以用来证明</p>
<p>证：空集是任意集合的子集</p>
<p>任何集合S，$\oslash \subseteq S$​​​ </p>
<p>由子集的定义</p>
<p><strong>任何x，若$x \in \oslash$​，则$x \in S$​​​​ </strong>——空证明</p>
</blockquote>
</li>
<li><p>关于蕴含联结词的一些概念</p>
<ul>
<li><p>p→q 的逻辑关系：（有p一定有q，没有q一定没有p——逆否关系）——p$\subseteq$​​q</p>
<ul>
<li>q为p的必要条件</li>
<li>p为q的充分条件</li>
</ul>
<blockquote>
<p>p$\rightarrow$​​​q  $\Leftrightarrow$​​  $\neg$​q$\to$$\neg$​p</p>
<p>p与q等价：$\begin{cases} p \to q \\ \neg p \to \neg q  \end{cases}$</p>
</blockquote>
</li>
<li><p>“如果 p, 则 q” 有很多不同的表述方法：<strong>（需要好好理解）</strong></p>
<ul>
<li><p>若p，就q</p>
</li>
<li><p>只要p，就q</p>
</li>
<li><p><strong>p仅当q</strong></p>
<blockquote>
<p>p当且仅当q</p>
<p>$\begin{cases} p当q——当有q就有p（q为充分条件，写在→前面）\\  p仅当q——仅当q，才p（q为必要条件，写在→后面）/除非q，才p：p→q \\ \end{cases}$ </p>
</blockquote>
</li>
<li><p><strong>只有q，才p</strong></p>
</li>
<li><p>除非q，才p</p>
</li>
<li><p>除非q，否则非p（双重否定）</p>
<blockquote>
<p>除非q，否则p：$\neg p \rightarrow q$​</p>
</blockquote>
</li>
</ul>
</li>
<li><p>当 p 为假时，p→q 恒为真，称为空证明</p>
</li>
<li><p>常出现的错误：不分充分与必要条件</p>
</li>
<li><p>在自然语言中，“如果 p , 则 q ” ，p, q具有某种内在联系；</p>
<p><strong>但在数理逻辑中， p, q可以无任何内在联系</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="等价联结词"><a href="#等价联结词" class="headerlink" title="等价联结词"></a>等价联结词</h2><ul>
<li><p><strong>定义5</strong>：设 p, q为两个命题，复合命题“p当且仅当q” 称作p与q的<strong>等价式</strong>，记作p$\leftrightarrow$​q，$\leftrightarrow$​称作<strong>等价联结词</strong>。 </p>
<p>规定: <u>p$\leftrightarrow$​​q为真</u>当且仅当<u>p与q同时为真或同时为假。</u></p>
<p>​         p$\leftrightarrow$q 的逻辑关系：p与q互为充分必要条件。</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>基本联结词：构成一层</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225084811509.png" alt="image-20220225084811509" style="zoom:67%;" /></p>
<p><strong>注意优先级：括号$&gt;$非$&gt;$与$&gt;$或$&gt;$蕴含$&gt;$等价</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225085015688.png" alt="image-20220225085015688" style="zoom:67%;" /></p>
<h1 id="1-2-命题公式及其赋值"><a href="#1-2-命题公式及其赋值" class="headerlink" title="1.2 命题公式及其赋值"></a>1.2 命题公式及其赋值</h1><h2 id="命题变项与合式公式"><a href="#命题变项与合式公式" class="headerlink" title="命题变项与合式公式"></a>命题变项与合式公式</h2><ul>
<li><p><strong>命题常项</strong>（命题常元）：简单命题（相当于常数或常量）</p>
</li>
<li><p><strong>命题变项</strong>（命题变元）：可表示任意命题的变元 （相当于变量）——命题符号，无具体指向</p>
<p>命题变项不是命题。</p>
<p>常项与变项均用$ p, q, r, …,$ $p_i$ ,$q_i$ , $r_i$ $, …,$ 等表示。</p>
<p>将命题变项用联结词和圆括弧按一定的逻辑关系联结起来的符号串称为<strong>合式公式</strong>。</p>
</li>
</ul>
<ul>
<li><p>当使用联结词集{$\neg$, $\land$, $\vee$, →, $\leftrightarrow$}时，合式公式定义如下：</p>
<p><strong>定义6</strong>（<strong>合式公式</strong>的递归定义）（也称命题公式，简称公式）：</p>
<p>​    （1）单个命题变项和命题常项是合式公式, 称作<strong>原子命题公式</strong></p>
<p>​    （2）若A是合式公式，则 ($\neg$​A)也是合式公式</p>
<p>​    （3）若A, B是合式公式，则(A$\land$B), (A$\vee$B), (A→B),  (A$\leftrightarrow$B)也是合式公式</p>
<p>​    （4）只有有限次地应用(1)~(3) 形成的符号串是合式公式</p>
<p>设A是合式公式，B为A的一部分，若B也是合式公式，则称B为A的<strong>子公式</strong>。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225090704496.png" alt="image-20220225090704496" style="zoom:67%;" /></p>
</li>
</ul>
<h2 id="合式公式的层次"><a href="#合式公式的层次" class="headerlink" title="合式公式的层次"></a>合式公式的层次</h2><ul>
<li><p><strong>定义7</strong>：</p>
<p>(1) 若公式A是单个命题变项，则称A为<strong>0层公式</strong>。 </p>
<blockquote>
<p>如：p, q, r</p>
</blockquote>
<p>(2) 称 $A$ 是$n+1 \ (n \geq 0)$ 层公式是指下面情况之一： </p>
<p>​    (a) $A=\neg B$，$B$ 是 $n$ 层公式； </p>
<p>​    (b)$ A=B \land C$，其中$B,C $分别为$ i $层和 $j$ 层公式，且 $n=max(i,j)$​；</p>
<p>​    (c)$A=B \vee C $, 其中 $B,C $的层次及 $n$ 同(b)； </p>
<p>​    (d) $A=B \to C$​, 其中$B,C$ 的层次及 $n$ 同(b)； </p>
<p>​    (e) $A=B \leftrightarrow C$, 其中$B,C$ 的层次及 $n$ 同(b)。 </p>
<p>(3) 若公式$A$的层次为$k$, 则称$A$为<strong>k层公式</strong>。</p>
<blockquote>
<p>例如：</p>
<p>公式 A = p，B =$\neg$​p，C=$\neg$​p→q，D=$\neg$​(p→q)$\leftrightarrow$​r,  E=(($\neg$​p$\land$​q) →r) $\leftrightarrow$​($\neg$r$\vee$s) </p>
<p>分别为0层，1层，2层，3层，4层公式。</p>
</blockquote>
</li>
</ul>
<h2 id="公式赋值"><a href="#公式赋值" class="headerlink" title="公式赋值"></a>公式赋值</h2><ul>
<li><p><strong>定义8</strong>：设$p_1 , p_2 , … , p_n$是出现在公式$A$中的全部命题变项, 给$p_1 , p_2 , … , p_n$各指定一个真值, 称为对$A$的一个赋值或解释。</p>
<p>若使$A$为$1$, 则称这组值为$A$的成真赋值;  </p>
<p>若使$A$为$0$, 则称这组值为$A$的成假赋值。</p>
</li>
<li><p>几点说明：<strong>（重要）</strong></p>
<ul>
<li><p>$A$中仅出现 $p_1 , p_2 , … , p_n，$给$A$赋值$\alpha = \alpha_1\alpha_2…\alpha_n$是指$p_1 =\alpha_1 , p_2 = \alpha_2 , …, p_n = \alpha_n , \alpha_i = 0$或$1$, $\alpha_i$之间不加标点符号。</p>
<p>按照命题符号的顺序赋值</p>
</li>
<li><p>$A$中仅出现$ p, q, r, …, $给$A$赋值$\alpha_1$$\alpha_2\alpha_3…$是指$ p=\alpha_1 , q=\alpha_2 , r=\alpha_3 …$</p>
</li>
<li><p>含$n$个命题变项的公式有$2^n$个赋值。</p>
<blockquote>
<p>如：</p>
<p>000, 010, 101, 110是  $\neg (p→q)\leftrightarrow r$的成真赋值 </p>
<p>001, 011, 100, 111是成假赋值。</p>
<p>——以上赋值的顺序按照$p, q, r$的顺序给出</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h2><ul>
<li><p><strong>定义9</strong>：将命题公式$A$在所有赋值下取值的情况列成表，称作$A$的真值表。</p>
</li>
<li><p>构造真值表的步骤</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225091751888.png" alt="image-20220225091751888" style="zoom:67%;" /></p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301200319538.png" alt="image-20220301200319538" style="zoom: 67%;" /></p>
<blockquote>
<p><strong>从表中可以看出哪些为成真赋值，那些为成假赋值</strong></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301200342849.png" alt="image-20220301200342849" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301200358601.png" alt="image-20220301200358601" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301200413257.png" alt="image-20220301200413257" style="zoom:50%;" /></p>
<h2 id="公式的类型"><a href="#公式的类型" class="headerlink" title="公式的类型"></a>公式的类型</h2><ul>
<li><p><strong>定义10</strong>：</p>
<p>(1) 若$A$在它的任何赋值下均为真，则称$A$为<strong>重言式</strong>或<strong>永真式</strong>；</p>
<p>(2) 若$A$在它的任何赋值下均为假，则称$A$为<strong>矛盾式</strong>或<strong>永假式</strong>； </p>
<p>(3) 若$A$不是矛盾式，则称$A$是<strong>可满足式</strong></p>
<blockquote>
<p>可满足式包含两种情况</p>
<p>1.公式的值有时为真，又是为假（非重言式的可满足式）</p>
<p>2.全部赋值都为真（重言式）</p>
</blockquote>
<p>注：重言式是可满足式，但反之不真。</p>
</li>
<li><p>真值表的用途：</p>
<p>（1）求出公式的全部成真赋值与成假赋值；</p>
<p>（2）判断公式的类型</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>主要内容</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225093212858.png" alt="image-20220225093212858" style="zoom:67%;" /></p>
</li>
<li><p>基本要求</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220225143205004.png" alt="image-20220225143205004" style="zoom:67%;" /></p>
</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第2节 命题逻辑等值计算</title>
    <url>/mathematical-logic/mathematical-logic-ch2/</url>
    <content><![CDATA[<h1 id="2-1-等值式"><a href="#2-1-等值式" class="headerlink" title="2.1 等值式"></a>2.1 等值式</h1><ul>
<li><p><strong>定义1</strong>：若<strong>等价式</strong>A $\leftrightarrow$ B是<strong>重言式</strong>，则称A与B等值，记作A $\Leftrightarrow$ B，并称A $\leftrightarrow$ B是等值式</p>
<p>此时A和B真值相同（全0 or 全1）</p>
</li>
<li><p>几点说明： </p>
<ul>
<li>定义中的符号$\Leftrightarrow$不是联结符（词） </li>
<li>用<strong>真值表</strong>可检查两个公式是否等值</li>
</ul>
</li>
</ul>
<blockquote>
<p>问题：判别下面命题公式是否为重言式(永真式)？ </p>
<p>(( p∧ $\neg$ q) → r )∧ p ∧ (q → s) ∧ $\neg$ s → r<br>转化为: (( p∧ $\neg$ q) → r )∧ p ∧ (q → s) ∧ $\neg$ s → r $\Leftrightarrow$ 1</p>
</blockquote>
<span id="more"></span>
<p>【例1】判断下列各组公式是否等值</p>
<p>（1）p→(q→r) 与 (p $\land$ q) →r</p>
<blockquote>
<p>形式不同，表达含义相同。p，q都是r的前提</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301083009100.png" alt="image-20220301083009100" style="zoom:67%;" /></p>
<p>（2）p→(q→r) 与 (p→q) →r</p>
<blockquote>
<p>含义不同，不等值</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301083123270.png" alt="image-20220301083123270" style="zoom:67%;" /></p>
<h2 id="基本等值式"><a href="#基本等值式" class="headerlink" title="基本等值式"></a>基本等值式</h2><ul>
<li><p><strong>双重否定律</strong>：  $\neg$ $\neg$ A $\Leftrightarrow$ A</p>
</li>
<li><p><strong>幂等律</strong>： A $\vee$ A $\Leftrightarrow$ A, $\qquad$ A $\land$ A $\Leftrightarrow$ A​ </p>
<blockquote>
<p>理解为两个集合的交/并</p>
</blockquote>
</li>
<li><p><strong>交换律</strong>： A $\vee$ B $\Leftrightarrow$ B $\vee$ A,$\qquad$  A $\land$ B $\Leftrightarrow$ B $\land$ A​ </p>
</li>
<li><p><strong>结合律</strong> ： (A $\vee$ B) $\vee$ C $\Leftrightarrow$ A $\vee$ (B $\vee$ C), $\qquad$ (A $\land$ B) $\land$ C $\Leftrightarrow$ A $\land$ (B $\land$ C)​ </p>
</li>
<li><p><strong>分配律</strong> ：A $\vee$ (B $\land$ C) $\Leftrightarrow$ (A $\vee$ B) $\land$ (A $\vee$ C),$\qquad$ A $\land$ (B $\vee$ C) $\Leftrightarrow$ (A $\land$ B) $\vee$ (A $\land$ C)  </p>
</li>
<li><p><strong>德摩根律</strong>： $\neg$ (A $\vee$ B) $\Leftrightarrow$  $\neg$ A $\land$  $\neg$ B, $\qquad$<br>$\neg$ (A $\land$ B) $\Leftrightarrow$  $\neg$ A $\vee$ $\neg$ B​​</p>
</li>
<li><p><strong>吸收律</strong>： A $\vee$ (A $\land$ B) $\Leftrightarrow$ A, $\qquad$ A $\land$ (A $\vee$ B) $\Leftrightarrow$ A</p>
<blockquote>
<p>A把比它大的部分吸收</p>
</blockquote>
</li>
<li><p><strong>零律</strong>： A $\vee$ 1 $\Leftrightarrow$ 1, $\qquad$  A $\land$ 0 $\Leftrightarrow$ 0</p>
</li>
<li><p><strong>同一律</strong>： A $\vee$ 0 $\Leftrightarrow$ A, $\qquad$ A $\land$ 1 $\Leftrightarrow$ A</p>
</li>
<li><p><strong>排中律</strong>： A $\vee$ $\neg$ A  $\Leftrightarrow$ 1</p>
</li>
<li><p><strong>矛盾律</strong>： A $\land$  $\neg$ A $\Leftrightarrow$ 0</p>
<blockquote>
<p>不可能既真又假</p>
</blockquote>
</li>
<li><p><strong>蕴涵等值式</strong>： A→B $\Leftrightarrow$ $\neg$ A $\vee$ B</p>
</li>
<li><p><strong>等价等值式</strong>：A $\leftrightarrow$ B $\Leftrightarrow$ (A→B) $\land$ (B→A)</p>
<blockquote>
<p>非A或B 与 非B或A</p>
</blockquote>
</li>
<li><p><strong>假言易位</strong>： $\color{red}$ A→B $\Leftrightarrow$ $\neg$ B→$\neg$ A</p>
<blockquote>
<p>B是A的必要条件，A是B的充分条件</p>
<p><strong>有A则有B</strong> 与 <strong>没有B则没有A</strong> 是同一件事</p>
</blockquote>
</li>
<li><p><strong>等价否定等值式</strong>：A $\leftrightarrow$ B $\Leftrightarrow$ $\neg$ A $\leftrightarrow$ $\neg$ B </p>
</li>
<li><p><strong>归谬论</strong>： (A→B) $\land$ (A→$\neg$ B) $\Leftrightarrow$ $\neg$ A</p>
<blockquote>
<p>在A为真的前提下，能推出矛盾（B既真又假），则前提A为假——反证法</p>
</blockquote>
</li>
</ul>
<p>特别提示：必须牢记这16组等值式(24式)，这是继续学习的基础。</p>
<h2 id="等值演算与置换规则"><a href="#等值演算与置换规则" class="headerlink" title="等值演算与置换规则"></a>等值演算与置换规则</h2><h3 id="1-等值演算"><a href="#1-等值演算" class="headerlink" title="1.等值演算"></a>1.等值演算</h3><p>由已知的等值式推演出新的等值式的过程</p>
<blockquote>
<p>每一步都是等值变换（每一步都使用等值式）</p>
</blockquote>
<h3 id="2-等值演算的基础"><a href="#2-等值演算的基础" class="headerlink" title="2.等值演算的基础"></a>2.等值演算的基础</h3><ul>
<li><p>等值关系的性质：<strong>自反性、对称性、传递性</strong></p>
<blockquote>
<p>A与A是等值的</p>
<p>如果A和B等值，则B和A等值</p>
<p>如果A和B等值，B和C等值，则A和C等值</p>
</blockquote>
</li>
<li><p>基本的等值式</p>
</li>
<li><p><strong>置换规则</strong></p>
</li>
</ul>
<h3 id="3-置换规则"><a href="#3-置换规则" class="headerlink" title="3.置换规则"></a>3.置换规则</h3><p>设 $\Phi$(A)​​​​​ 是含公式 A​​​​ 的命题公式，$\Phi$ (B)​​​ 是用公式B​​置换$\Phi$ (A)​ 中所有的 A 后得到的命题公式。 </p>
<p>若 B $\Leftrightarrow$ A，则 $\Phi$(B) $\Leftrightarrow$ $\Phi$(A)。</p>
<blockquote>
<p>对公式的一部分做等值变换，变换后的结果仍然是等值的</p>
</blockquote>
<h3 id="等值演算的应用举例"><a href="#等值演算的应用举例" class="headerlink" title="等值演算的应用举例"></a>等值演算的应用举例</h3><ul>
<li>证明两个公式等值</li>
</ul>
<p>​        <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301190541286.png" alt="image-20220301190541286" style="zoom: 50%;" /></p>
<p><strong>注：用等值演算不能直接证明两个公式不等值</strong></p>
<ul>
<li>判断公式类型：<script type="math/tex; mode=display">
A 为矛盾式当且仅当 A \Leftrightarrow 0 \\
A 为重言式当且仅当 A \Leftrightarrow 1 \\
A 为非重言式的可满足式 \Leftrightarrow A既有成真赋值又有成假赋值 \\</script></li>
</ul>
<h3 id="证明两个公式不等值"><a href="#证明两个公式不等值" class="headerlink" title="证明两个公式不等值"></a>证明两个公式不等值</h3><ul>
<li><p>真值表法</p>
</li>
<li><p>观察法——举出反例</p>
</li>
<li><p>先等值演算化简公式，再观察</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301190743753.png" alt="image-20220301190743753" style="zoom:50%;" /></p>
</li>
</ul>
<h1 id="2-2-析取范式与合取范式"><a href="#2-2-析取范式与合取范式" class="headerlink" title="2.2 析取范式与合取范式"></a>2.2 析取范式与合取范式</h1><p>范式：比较规范的公式形式</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p><strong>文字</strong>：命题变项及其否定的总称</p>
<blockquote>
<p>p, $\quad$ $\neg$ q</p>
</blockquote>
</li>
<li><p><strong>简单析取式</strong>：仅由有限个文字构成的析取式</p>
<blockquote>
<p>p,$\quad$ $\neg$ q,$\quad$ p$\vee$ $\neg$ q, $\quad$ p$\vee$ q $\vee$ r,…​</p>
</blockquote>
</li>
<li><p><strong>简单合取式</strong>：由有限个文字构成的合取式</p>
<blockquote>
<p>p,$\quad$ $\neg$ q,$\quad$ p$\land$ $\neg$ q, $\quad$ p$\land$ q $\land$ r,…</p>
</blockquote>
</li>
<li><p><strong>析取范式</strong>：由有限个<strong>简单合取式</strong>组成的<strong>析取式</strong></p>
<blockquote>
<p>p,$\quad$ $\neg$ p $\land$ q,（简单合取式）$\quad$ p$\vee$ $\neg$ q, $\quad$ (p $\land$ $\neg$ q) $\vee$ ($\neg$ p $\land$ q $\land$ $\neg$ r) $\vee$ (q $\land$ r),…​</p>
</blockquote>
</li>
<li><p><strong>合取范式</strong>：由有限个<strong>简单析取式</strong>组成的<strong>合取式</strong></p>
<blockquote>
<p>p,$\quad$ $\neg$ p $\vee$ q,（简单析取式）$\quad$ p$\land$ $\neg$ q, $\quad$ (p $\vee$ $\neg$ q) $\land$ ($\neg$ p $\vee$ q $\vee$ r) $\land$ (q $\vee$ r),…</p>
</blockquote>
</li>
<li><p><strong>范式</strong>：析取范式与合取范式的总称</p>
</li>
</ol>
<p>说明</p>
<ul>
<li>单个文字既是简单析取式，又是简单合取式</li>
<li>形如 p $\land$ $\neg$ q $\land$ r, $\neg$ p $\land$ q $\vee$ $\neg$ r 的公式既是析取范式，又是合取范式</li>
</ul>
<p><strong>定理1</strong></p>
<p>（1）一个<strong>简单析取式是重言式</strong>当且仅当<strong>它同时含有某个命题变项和它的否定式</strong></p>
<blockquote>
<p>p $\vee$ $\neg$ p $\vee$ r $\vee$ q</p>
</blockquote>
<p>（2）一个<strong>简单合取式是矛盾式</strong>当且仅当<strong>它同时含有某个命题变项和它的否定式</strong></p>
<blockquote>
<p>p $\land$ $\neg$ p $\land$ q</p>
</blockquote>
<p><strong>定理2</strong></p>
<p>（1）一个<strong>析取范式是矛盾式</strong>当且仅当<strong>它每个简单合取式都是矛盾式</strong></p>
<blockquote>
<p>$\triangle$ $\vee$ $\triangle$ $\vee$ $\triangle$</p>
</blockquote>
<p>（2）一个<strong>合取范式是重言式</strong>当且仅当<strong>它的每个简单析取式都是重言式</strong></p>
<blockquote>
<p>$\triangle$ $\land$ $\triangle$ $\land$ $\triangle$</p>
</blockquote>
<p><strong>定理3</strong>（范式存在定理）</p>
<p>任何命题公式都存在与之等值的析取范式与合取范式</p>
<blockquote>
<p>从任何公式出发，都有和它等值的<strong>析取范式</strong>和<strong>合取范式</strong></p>
</blockquote>
<h2 id="命题公式的范式"><a href="#命题公式的范式" class="headerlink" title="命题公式的范式"></a>命题公式的范式</h2><h3 id="求公式A的范式的步骤"><a href="#求公式A的范式的步骤" class="headerlink" title="求公式A的范式的步骤"></a>求公式A的范式的步骤</h3><ol>
<li><p>消去A中的$\to$, $\leftrightarrow$（若存在）——<strong>（蕴含等价式、等价等值式、假言易位、等价否定等值式、归谬论）</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301091705613.png" alt="image-20220301091705613" style="zoom: 50%;" /></p>
</li>
<li><p>否定连接词的内移或消去<strong>（德摩根律）</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301091721847.png" alt="image-20220301091721847" style="zoom: 50%;" /></p>
</li>
<li><p>使用<strong>分配律</strong></p>
</li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301091734879.png" alt="image-20220301091734879" style="zoom:50%;" /></p>
<p>范式的不足——不唯一</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301192357658.png" alt="image-20220301192357658" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301192420027.png" alt="image-20220301192420027" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301192436741.png" alt="image-20220301192436741" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301192454515.png" alt="image-20220301192454515" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第4节 命题逻辑的推理理论</title>
    <url>/mathematical_logic/mathematical-logic-ch4/</url>
    <content><![CDATA[<h1 id="4-1-推理的形式结构"><a href="#4-1-推理的形式结构" class="headerlink" title="4.1 推理的形式结构"></a>4.1 推理的形式结构</h1><h2 id="定义1："><a href="#定义1：" class="headerlink" title="定义1："></a><strong>定义1：</strong></h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225116596.png" alt="image-20220307225116596" style="zoom:67%;" /></p>
<p><strong>所有的前提都为真且结论为真</strong>或者<strong>有前提为假</strong>——有效结论</p>
<span id="more"></span>
<p>说明：</p>
<p>（2）根据定义1判断——前提的合取为假或者前提的合取为真且结论为真</p>
<p>（3）考虑前提为假的情况</p>
<h2 id="定理1："><a href="#定理1：" class="headerlink" title="定理1："></a><strong>定理1：</strong></h2><p>​    <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225133270.png" alt="image-20220307225133270" style="zoom:67%;" /></p>
<blockquote>
<p>证明：</p>
<p>（$\Rightarrow$）前提为假或者前提的合取为真且结论为真，则该式为重言式</p>
<p>（$\Leftarrow$）同理</p>
</blockquote>
<h2 id="推理的形式结构（小结）"><a href="#推理的形式结构（小结）" class="headerlink" title="推理的形式结构（小结）"></a>推理的形式结构（小结）</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225217321.png" alt="image-20220307225217321" style="zoom:67%;" /></p>
<h2 id="推理实例"><a href="#推理实例" class="headerlink" title="推理实例"></a>推理实例</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308141355061.png" alt="image-20220308141355061" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308141408459.png" alt="image-20220308141408459" style="zoom:50%;" /></p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225300522.png" alt="image-20220307225300522" style="zoom:67%;" /></p>
<p>思考：</p>
<p>（1）数学证明是从前提为真出发，不考虑前提为假的情况</p>
<h2 id="推理定律——重言蕴含式"><a href="#推理定律——重言蕴含式" class="headerlink" title="推理定律——重言蕴含式"></a>推理定律——重言蕴含式</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225338038.png" alt="image-20220307225338038" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225355037.png" alt="image-20220307225355037" style="zoom:67%;" /></p>
<blockquote>
<p>1.A为真，B为真，则A与B为真</p>
<p>2.A与B为真，则A、B均为真</p>
<p>3.双重反</p>
<p>4、5放在一起看——消掉蕴含。蕴含式和前提都为真，则结论真</p>
<p>6.A、B有一个成立，则析取式成立</p>
<p>7.矛盾（倒着的T）可以推出任何公式</p>
<p>8.A和$\neg$A都成立则矛盾</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225409278.png" alt="image-20220307225409278" style="zoom:67%;" /></p>
<blockquote>
<p>9.A析取B为真且B为假，则A为真</p>
<p>10.假定A推出B，B推出C，则A能推出C</p>
<p>11.A等价于B，B等价于C，则A等价于C</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225518107.png" alt="image-20220307225518107" style="zoom:67%;" /></p>
<h1 id="4-2-自然推理系统P"><a href="#4-2-自然推理系统P" class="headerlink" title="4.2 自然推理系统P"></a>4.2 自然推理系统P</h1><h2 id="定义2："><a href="#定义2：" class="headerlink" title="定义2："></a><strong>定义2：</strong></h2><p>​    <img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225534809.png" alt="image-20220307225534809" style="zoom:67%;" /></p>
<blockquote>
<p>（3）做等值演算</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225552982.png" alt="image-20220307225552982" style="zoom:67%;" /></p>
<p>线上为前提，线下为结论（线上成立，则线下的结论成立）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225607270.png" alt="image-20220307225607270" style="zoom:67%;" /></p>
<blockquote>
<p>（10）想证明蕴涵式成立：（假定A成立，如果能证明B，则蕴含式成立）。方框为假设框，上推下</p>
<p>（11）析取引入1，析取引入2</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225620760.png" alt="image-20220307225620760" style="zoom:67%;" /></p>
<blockquote>
<p>（15）要证非A成立，则证A推出矛盾</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220307225634250.png" alt="image-20220307225634250" style="zoom:67%;" /></p>
<h2 id="在自然推理系统P中构造证明"><a href="#在自然推理系统P中构造证明" class="headerlink" title="在自然推理系统P中构造证明"></a>在自然推理系统P中构造证明</h2><p>设前提$A_1, A_2,…, A_k$，结论$B$及公式序列$C_1, C_2 ,…, C_l$。如果每一个$C_i(1 \leq i \le l)$是某个$A_j$, 或者可由序列中前面的公式应用推理规则得到, 并且$C_l =B$, 则称这个公式序列是由$A_1, A_2,…, A_k$推出B的<strong>证明</strong>。</p>
<blockquote>
<p>$C_i$是中间结论，利用中间结论和前提推出最终结论</p>
</blockquote>
<h2 id="直接证明法"><a href="#直接证明法" class="headerlink" title="直接证明法"></a>直接证明法</h2><ul>
<li>命题并符号化</li>
<li>写出证明的形式结构</li>
<li>证明</li>
</ul>
<h3 id="直接证明法举例"><a href="#直接证明法举例" class="headerlink" title="直接证明法举例"></a>直接证明法举例</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308144910269.png" alt="image-20220308144910269" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308144936758.png" alt="image-20220308144936758" style="zoom:50%;" /></p>
<h2 id="附加前提证明法"><a href="#附加前提证明法" class="headerlink" title="附加前提证明法"></a>附加前提证明法</h2><p>适用于结论为蕴含式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308144441591.png" alt="image-20220308144441591" style="zoom:67%;" /></p>
<h3 id="附加前提证明法举例"><a href="#附加前提证明法举例" class="headerlink" title="附加前提证明法举例"></a>附加前提证明法举例</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308145032290.png" alt="image-20220308145032290" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308145051717.png" alt="image-20220308145051717" style="zoom:50%;" /></p>
<h2 id="归谬法（反证法）"><a href="#归谬法（反证法）" class="headerlink" title="归谬法（反证法）"></a>归谬法（反证法）</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308144510314.png" alt="image-20220308144510314" style="zoom:67%;" /></p>
<h3 id="归谬法证明举例"><a href="#归谬法证明举例" class="headerlink" title="归谬法证明举例"></a>归谬法证明举例</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220308145122036.png" alt="image-20220308145122036" style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第3节 主析（合）取范式</title>
    <url>/mathematical_logic/mathematical-logic-ch3/</url>
    <content><![CDATA[<ul>
<li>判断命题公式是否为重言式（永真式）？<ul>
<li>真值表</li>
<li>等值演算</li>
<li>主析取范式和主合取范式</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="3-1主析取范式与主合取范式"><a href="#3-1主析取范式与主合取范式" class="headerlink" title="3.1主析取范式与主合取范式"></a>3.1主析取范式与主合取范式</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p><strong>文字</strong>：命题变项及其否定的总称</p>
<blockquote>
<p>$p, \quad \neg q$</p>
</blockquote>
</li>
<li><p><strong>简单析取式</strong>：仅由有限个文字构成的析取式</p>
<blockquote>
<p>$p,\quad \neg q,\quad p\vee \neg q, \quad p\vee q \vee r,…$​</p>
</blockquote>
</li>
<li><p><strong>简单合取式</strong>：由有限个文字构成的合取式</p>
<blockquote>
<p>$p,\quad \neg q,\quad p\land \neg q, \quad p\land q \land r,…$</p>
</blockquote>
</li>
<li><p><strong>析取范式</strong>：由有限个<strong>简单合取式</strong>组成的<strong>析取式</strong></p>
<blockquote>
<p>$p,\quad \neg p \land q,（简单合取式）\quad p\vee \neg q, \quad (p \land \neg q) \vee (\neg p \land q \land \neg r) \vee (q \land r),…$​</p>
</blockquote>
</li>
<li><p><strong>合取范式</strong>：由有限个<strong>简单析取式</strong>组成的<strong>合取式</strong></p>
<blockquote>
<p>$p,\quad \neg p \vee q,（简单析取式）\quad p\land \neg q, \quad (p \vee \neg q) \land (\neg p \vee q \vee r) \land (q \vee r),…$</p>
</blockquote>
</li>
<li><p><strong>范式</strong>：析取范式与合取范式的总称</p>
</li>
</ol>
<h2 id="求公式-A-的范式的步骤"><a href="#求公式-A-的范式的步骤" class="headerlink" title="求公式$A$的范式的步骤"></a>求公式$A$的范式的步骤</h2><ol>
<li><p>消去$A$中的$\to, \leftrightarrow$（若存在）——<strong>（蕴含等价式、等价等值式、假言易位、等价否定等值式、归谬论）</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301091705613.png" alt="image-20220301091705613" style="zoom: 50%;" /></p>
</li>
<li><p>否定连接词的内移或消去<strong>（德摩根律）</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301091721847.png" alt="image-20220301091721847" style="zoom: 50%;" /></p>
</li>
<li><p>使用<strong>分配律</strong></p>
</li>
</ol>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220301091734879.png" alt="image-20220301091734879" style="zoom:50%;" /></p>
<ul>
<li><p>公式范式的不足——不唯一</p>
</li>
<li><p>得到唯一的范式——主范式</p>
</li>
</ul>
<h2 id="极小项与极大项"><a href="#极小项与极大项" class="headerlink" title="极小项与极大项"></a>极小项与极大项</h2><ul>
<li><p><strong>定义1</strong>：在含有$n$个命题变项的<strong>简单合取式</strong>中，若每个命题变项均以文字的形式在其中出现且仅出现一次， 而且第$i$个文字出现在左起第$i$位上（$1 \leq i \leq n$），称这样的简单合取式为<strong>极小项</strong></p>
<blockquote>
<p>极小项——合取越多范围越小，取决于真值最小的文字</p>
<p>对于$p, q, r$（不缺项，规定了顺序：字母、下标）</p>
<p>$p \land q \land r$</p>
</blockquote>
</li>
<li><p><strong>定义2</strong>：在含有$n$个命题变项的<strong>简单析取式</strong>中，若每个命题变项均以文字的形式在其中出现且仅出现一次， 而且第$i$个文字出现在左起第$i$位上（$1 \leq i \leq n$），称这样的简单析取式为<strong>极大项</strong></p>
<blockquote>
<p>极大项——合取越多范围越大，只要有真值为1的文字，该项的真值为1</p>
<p>对于$p, q, r$（不缺项，规定了顺序：字母、下标）</p>
<p>$p \vee q \vee r$</p>
</blockquote>
</li>
<li><p>几点说明</p>
<ul>
<li><p>$n$个命题变项有$2^n$个极小项和$2^n$个极大项</p>
</li>
<li><p>$2^n$个极小项（极大项）均互不等值</p>
</li>
<li><p>用$m_i$表示第$i$个极小项，其中$i$是该极小项<strong>成真赋值</strong><br>的十进制表示</p>
<blockquote>
<p>$p \land q \land r$的成真赋值为111，$m_7$</p>
<p>$\neg p \land q \land r$成真赋值为011，$m_3$</p>
</blockquote>
</li>
<li><p>用$M_i$表示第$i$个极大项，其中$i$是该极大项<strong>成假赋值</strong><br>的十进制表示</p>
<blockquote>
<p>$p \vee q \vee r$的成假赋值为000，$M_0$</p>
<p>$\neg p \vee q \vee r$的成假赋值为100，$M_4$</p>
</blockquote>
</li>
<li><p>$m_i$（$M_i$）称为极小项（极大项）的名称</p>
</li>
</ul>
</li>
</ul>
<p>【实例】</p>
<ul>
<li>由两个命题变项$p, q$形成的极小项和极大项</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304081627478.png" alt="image-20220304081627478" style="zoom:67%;" /></p>
<ul>
<li>由三个命题变项$p,q,r$形成的极小项和极大项</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304081832381.png" alt="image-20220304081832381" style="zoom:67%;" /></p>
<ul>
<li><strong>$m_i与M_i的关系：\neg m_i \Leftrightarrow M_i, \neg M_i \Leftrightarrow m_i$</strong></li>
</ul>
<h2 id="主析取范式与主合取范式"><a href="#主析取范式与主合取范式" class="headerlink" title="主析取范式与主合取范式"></a>主析取范式与主合取范式</h2><ul>
<li>主析取范式——由极小项构成的析取范式</li>
<li>主合取范式——由极大项构成的合取范式</li>
</ul>
<blockquote>
<p>例如，n=3, 命题变项为 p, q, r 时，</p>
<p>$(\neg p\land \neg q \land r) \vee (\neg p\land q \land r) \Leftrightarrow  m_1 \vee m_3$ ——主析取范式<br>$(p \vee q \vee \neg r) \land (\neg p \vee \neg q \vee \neg r) \Leftrightarrow M_1 \land M_7$——主合取范式</p>
</blockquote>
<ul>
<li><p><strong>定理1</strong>（主范式的存在唯一定理）</p>
<p>任何命题公式都存在与之等值的主析取范式和主合取范式, 并且是惟一的</p>
</li>
</ul>
<h2 id="求命题公式主范式的步骤"><a href="#求命题公式主范式的步骤" class="headerlink" title="求命题公式主范式的步骤"></a>求命题公式主范式的步骤</h2><h3 id="1-求公式主析取范式的步骤"><a href="#1-求公式主析取范式的步骤" class="headerlink" title="1.求公式主析取范式的步骤"></a>1.求公式主析取范式的步骤</h3><p><strong>先求出析取范式，再变换成主析取范式</strong></p>
<p>设公式$A$含命题变项$p_1, p_2,…, p_n$</p>
<ul>
<li><p>(1) 求$A$的析取范式$A’=B_1 \vee B_2 \vee … \vee B_s$ , 其中$B_j$是<strong>简单合取式</strong> ，$j=1,2, … ,s$</p>
</li>
<li><p>(2) <strong>（每一个简单合取式变为极小项——合取1来补项）</strong></p>
<p>若某个$B_j$既不含$p_i$, 又不含$\neg p_i$, 则将$B_j$展开成：$B_j \Leftrightarrow B_j \land 1 \Leftrightarrow B_j \land (p_i \vee \neg p_i) \Leftrightarrow (B_j \land p_i) \vee (B_j \land \neg p_i)$</p>
<p>重复这个过程, 直到<strong>所有简单合取式都是长度为n的极小项</strong>为止</p>
</li>
<li><p>(3) <strong>消去重复出现的极小项</strong>, 即用$m_i$代替$m_i \vee m_i$ </p>
</li>
<li><p>(4) 将极小项按下标从小到大<strong>排列</strong></p>
</li>
</ul>
<h3 id="2-求公式主合取范式的步骤"><a href="#2-求公式主合取范式的步骤" class="headerlink" title="2.求公式主合取范式的步骤"></a>2.求公式主合取范式的步骤</h3><p><strong>先求出合取范式，再变换成主合取范式</strong></p>
<p>设公式$A$含命题变项$p_1, p_2,…, p_n$</p>
<ul>
<li><p>(1) 求$A$的合取范式$A’=B_1 \land  B_2 \land … \land B_s$ , 其中$B_j$是<strong>简单析取式</strong> ，$j=1,2, … ,s$</p>
</li>
<li><p>(2)<strong>（补项——析取0）</strong></p>
<p>若某个$B_j$既不含$p_i$, 又不含$\neg p_i$, 则将$B_j$展开成：$B_j \Leftrightarrow B_j \vee 0 \Leftrightarrow B_j \vee (p_i \land \neg p_i) \Leftrightarrow (B_j \vee p_i) \land (B_j \vee \neg p_i)$</p>
<p>重复这个过程, 直到<strong>所有简单析取式都是长度为n的极大项</strong>为止</p>
</li>
<li><p>(3)<strong>消去重复出现的极大项</strong>， 即用$M_i$代替$M_i \land M_i$ </p>
</li>
<li><p>(4) 将极大项按下标从小到大<strong>排列</strong></p>
</li>
</ul>
<p>【实例】</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304083543458.png" alt="image-20220304083543458" style="zoom: 67%;" /></p>
<p><strong>我觉得可以使用卡诺图</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">p\qr</th>
<th style="text-align:center">00</th>
<th style="text-align:center">01</th>
<th style="text-align:center">11</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><strong>1</strong></td>
<td style="text-align:center"></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>主析取范式：成真赋值为1的项</p>
<p>主合取范式：成假赋值为0的项</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304083604370.png" alt="image-20220304083604370" style="zoom: 67%;" /></p>
<p><strong>关注主析取范式和主合取范式出现项的下标的关系</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304083622774.png" alt="image-20220304083622774" style="zoom: 67%;" /></p>
<h2 id="由主析（合）取范式确定主合（析）取范式"><a href="#由主析（合）取范式确定主合（析）取范式" class="headerlink" title="由主析（合）取范式确定主合（析）取范式"></a>由主析（合）取范式确定主合（析）取范式</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303230604125.png" alt="image-20220303230604125" style="zoom: 67%;" /></p>
<h2 id="用成真和成假赋值确定主范式"><a href="#用成真和成假赋值确定主范式" class="headerlink" title="用成真和成假赋值确定主范式"></a>用成真和成假赋值确定主范式</h2><p>已知成真赋值，则知道有多少个最小项。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303230652029.png" alt="image-20220303230652029" style="zoom: 67%;" /></p>
<h2 id="主范式的应用"><a href="#主范式的应用" class="headerlink" title="主范式的应用"></a>主范式的应用</h2><h3 id="1-求公式的成真成假赋值"><a href="#1-求公式的成真成假赋值" class="headerlink" title="(1)求公式的成真成假赋值"></a>(1)求公式的成真成假赋值</h3><p>设公式$A$含$n$个命题变项, $A$的主析取范式有<strong>$s$个极小项</strong>, 则$A$有<strong>$s$个成真赋值</strong>, 它们是极小项下标的二进制表示, <strong>其余$2^n-s$个赋值都是成假赋值</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303230838562.png" alt="image-20220303230838562" style="zoom:67%;" /></p>
<h3 id="2-判断公式的类型"><a href="#2-判断公式的类型" class="headerlink" title="(2)判断公式的类型"></a>(2)判断公式的类型</h3><p>根据极小项或成真赋值的个数</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303230918268.png" alt="image-20220303230918268" style="zoom:67%;" /></p>
<ul>
<li>重言式：全部赋值为成真赋值</li>
<li>矛盾式：全部赋值为成假赋值</li>
<li>非重言的可满足式：<ul>
<li>至少一个成真赋值</li>
<li>至少一个成假赋值</li>
</ul>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303230949648.png" alt="image-20220303230949648" style="zoom: 50%;" /></p>
<h3 id="3-判断两个公式是否等值"><a href="#3-判断两个公式是否等值" class="headerlink" title="3.判断两个公式是否等值"></a>3.判断两个公式是否等值</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303231031287.png" alt="image-20220303231031287" style="zoom: 50%;" /></p>
<h3 id="4-解实际问题"><a href="#4-解实际问题" class="headerlink" title="4.解实际问题"></a>4.解实际问题</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303231044612.png" alt="image-20220303231044612" style="zoom: 50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303231059094.png" alt="image-20220303231059094" style="zoom: 50%;" /></p>
<h1 id="3-2-n元真值函数"><a href="#3-2-n元真值函数" class="headerlink" title="3.2 n元真值函数"></a>3.2 n元真值函数</h1><ul>
<li><p><strong>定义3</strong>：称$F:${0,1}$^n \to$ {0,1}为<strong>n元真值函数</strong></p>
<blockquote>
<p>例如，3元真值函数$F(x,y,z) = \begin{cases} 0 \\ 1 \\ \end{cases}$</p>
<ul>
<li>有3个变量</li>
<li>每个变量的取值只能是0或1</li>
<li>每一组符号串的函数值为0或1</li>
</ul>
<p>000，001，010，011，100，101，110，111——8个符号串</p>
<p>000的函数值可能为0 or 1</p>
</blockquote>
<p>$F(p_1,p_2,…p_n) = \begin{cases} 0 \\ 1 \end{cases}$</p>
<ul>
<li><p>n个命题变量$p_1,p_2,…,p_n$的取值方式有$2^n$种</p>
</li>
<li><p>每一组取值对应的函数值可能为0或1，有2种</p>
</li>
</ul>
<p><strong>共$2^{2^n}$个n元真值函数</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220303231356068.png" alt="image-20220303231356068" style="zoom:67%;" /></p>
</li>
</ul>
<h2 id="1元真值函数"><a href="#1元真值函数" class="headerlink" title="1元真值函数"></a>1元真值函数</h2><ul>
<li>由1个命题变项p形成的极小项与极大项</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304092048665.png" alt="image-20220304092048665" style="zoom: 67%;" /></p>
<p>1元真值函数一共有$2^{2^1} = 4$种命题公式</p>
<blockquote>
<p>横着看：有4个真值函数——对应$m_0 \vee m_1的四种取值组合——主析取范式$</p>
<ul>
<li>第一列：永假式真值表：$\neg m_0 \vee \neg m_1$</li>
<li>第二列：$p$：$\neg m_0 \vee m_1$</li>
<li>第三列：$\neg p$：$m_0  \vee \neg  m_1$</li>
<li>第四列：永真式：$m_0 \vee m_1$</li>
</ul>
<p>竖着看：真值函数的取值$p$</p>
<ul>
<li>第一行：$p$</li>
<li>第二行：$\neg p$</li>
</ul>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304092346111.png" alt="image-20220304092346111" style="zoom:67%;" /></p>
<h2 id="2元真值函数"><a href="#2元真值函数" class="headerlink" title="2元真值函数"></a>2元真值函数</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304093005762.png" alt="image-20220304093005762" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304093027553.png" alt="image-20220304093027553" style="zoom:67%;" /></p>
<h2 id="公式与真值函数"><a href="#公式与真值函数" class="headerlink" title="公式与真值函数"></a>公式与真值函数</h2><ul>
<li>任何一个含n个命题变项的命题公式$A$都对应惟一的一个n元真值函数$ F $，$ F $恰好为$A$的真值表。</li>
<li><strong>等值的公式</strong>对应的<strong>真值函数</strong>相同。</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220304093448005.png" alt="image-20220304093448005" style="zoom:50%;" /></p>
<h1 id="3-3-联结词的完备集"><a href="#3-3-联结词的完备集" class="headerlink" title="3.3 联结词的完备集"></a>3.3 联结词的完备集</h1><ul>
<li><strong>定义4</strong>：设$S$是一个联结词集合，如果任何$n(n \geq 1)$ 元真值函数都可以由仅含$S$中的联结词构成的公式表示，则称$S$是<strong>联结词完备集</strong><ul>
<li>若$S$是联结词完备集, 则任何命题公式都可由$S$中的联结词表示</li>
</ul>
</li>
</ul>
<blockquote>
<p>与能够用或非表示，则它们是完备的</p>
</blockquote>
<ul>
<li><strong>定理2</strong>：$S = \{ \neg , \land, \vee\}$是联结词完备集。</li>
</ul>
<blockquote>
<p>证明：由范式存在定理可证</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327153620246.png" alt="image-20220327153620246" style="zoom:67%;" /></p>
<ul>
<li><strong>定义5</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327153701571.png" alt="image-20220327153701571" style="zoom:67%;" /></p>
<ul>
<li><strong>定理3</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220327153802714.png" alt="image-20220327153802714" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第6节 一阶逻辑等值演算与推理定律</title>
    <url>/mathematical_logic/mathematical-logic-ch6/</url>
    <content><![CDATA[<h3 id="6-1-一阶逻辑等值式与置换规则"><a href="#6-1-一阶逻辑等值式与置换规则" class="headerlink" title="6.1 一阶逻辑等值式与置换规则"></a>6.1 一阶逻辑等值式与置换规则</h3><h4 id="定义1-（命题逻辑的等价定义-to-一阶逻辑的等价定义）"><a href="#定义1-（命题逻辑的等价定义-to-一阶逻辑的等价定义）" class="headerlink" title="定义1 （命题逻辑的等价定义 $\to$ 一阶逻辑的等价定义）"></a>定义1 （命题逻辑的等价定义 $\to$ 一阶逻辑的等价定义）</h4><p><strong>定义1</strong>：设$A$, $B$是两个谓词公式, 如果$A \leftrightarrow B$是永真式,则称 $A$ 与 $B$ 等值, 记作$A \Leftrightarrow B$, 并称$A \Leftrightarrow B$是等值式。</p>
<ul>
<li>辨别谓词公式$A$与$B$等值的方法——<strong>判别谓词公式$A \leftrightarrow B$是永真式</strong>（等值演算）</li>
<li>判别谓词公式$A$是永真式的方法——<strong>（命题公式）重言式的代换实例</strong>（等值演算）</li>
<li>判别谓词公式$A \leftrightarrow B$是永真式的方法？</li>
</ul>
<h4 id="判别谓词公式A是永真式的方法"><a href="#判别谓词公式A是永真式的方法" class="headerlink" title="判别谓词公式A是永真式的方法"></a>判别谓词公式A是永真式的方法</h4><p>判别谓词公式A是永真式的方法——<strong>（命题公式）重言式的<u>代换实例</u></strong>（等值演算）</p>
<ul>
<li><p>命题公式中的重言式</p>
<ul>
<li><p>命题逻辑基本等值式：16组等值式（24式）——“<strong>等价重言式</strong>”</p>
<blockquote>
<p>$A \Leftrightarrow B$ —— $A \leftrightarrow B$ 是重言式</p>
</blockquote>
</li>
<li><p>命题逻辑推理定律——<strong>重言蕴含式</strong></p>
<blockquote>
<p>$A \to B$ 重言式，ch4</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h4 id="一阶逻辑基本等值式"><a href="#一阶逻辑基本等值式" class="headerlink" title="一阶逻辑基本等值式"></a>一阶逻辑基本等值式</h4><h5 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h5><p>命题逻辑中16组基本等值式的代换实例</p>
<blockquote>
<p>使用谓词公式代换，得到的公式仍然等值</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314203231240.png" alt="image-20220314203231240" style="zoom: 67%;" /></p>
<h5 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h5><h6 id="（1）消去量词等值式"><a href="#（1）消去量词等值式" class="headerlink" title="（1）消去量词等值式"></a>（1）消去量词等值式</h6><blockquote>
<p>个体域D是有限的个体域，包含n个个体。</p>
<p>①所有的个体都有性质A $\Leftrightarrow$ 每个个体都有性质A（合取的扩展）</p>
<p>②存在着个体有性质A $\Leftrightarrow$ 至少有一个个体有性质A（析取的扩展）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314203245571.png" alt="image-20220314203245571" style="zoom:67%;" /></p>
<h6 id="（2）量词否定等值式"><a href="#（2）量词否定等值式" class="headerlink" title="（2）量词否定等值式"></a>（2）量词否定等值式</h6><blockquote>
<p>”不存在有性质A的x“与“所有x都没有性质A”等价</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314203305434.png" alt="image-20220314203305434" style="zoom: 67%;" /></p>
<h6 id="（3）量词辖域收缩与扩张等值式"><a href="#（3）量词辖域收缩与扩张等值式" class="headerlink" title="（3）量词辖域收缩与扩张等值式"></a>（3）量词辖域收缩与扩张等值式</h6><p>$A(x)$是含$x$自由出现的公式，$B$中不含有$x$的出现</p>
<ul>
<li><p>关于全称量词的：</p>
<blockquote>
<p>$\forall x$ 只约束$A(x)$，不影响$B$</p>
</blockquote>
<ul>
<li><p>推导③</p>
<blockquote>
<p>$\Leftrightarrow \ (\neg A(a_1) \vee B) \land … \land (\neg A(a_n) \vee B)$</p>
<p>$\Leftrightarrow \ (\neg A(a_1) \land … \land \neg A(a_n) ) \vee B$</p>
<p>$\Leftrightarrow \ \neg  (A(a_1) \vee … \vee A(a_n) ) \vee B$</p>
<p>$\Leftrightarrow \ ( A(a_1) \vee … \vee \neg A(a_n) ) \to B$</p>
<p>$\Leftrightarrow \ 右$</p>
</blockquote>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314204126681.png" alt="image-20220314204126681" style="zoom:67%;" /></p>
</li>
<li><p>关于存在量词的：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314204142469.png" alt="image-20220314204142469" style="zoom:67%;" /></p>
</li>
</ul>
<h6 id="（4）量词分配等值式"><a href="#（4）量词分配等值式" class="headerlink" title="（4）量词分配等值式"></a>（4）量词分配等值式</h6><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314204236465.png" alt="image-20220314204236465" style="zoom:67%;" /></p>
<blockquote>
<p><strong>注意</strong>：$\forall$ 对 $\vee$，$\exists$ 对 $\land$ 无分配律</p>
</blockquote>
<h4 id="置换规则、换名规则、代替规则"><a href="#置换规则、换名规则、代替规则" class="headerlink" title="置换规则、换名规则、代替规则"></a>置换规则、换名规则、代替规则</h4><h5 id="1-置换规则"><a href="#1-置换规则" class="headerlink" title="1.置换规则"></a>1.置换规则</h5><p>设$\Phi(A)$是含$A$的公式，那么，若$A \Leftrightarrow B$，则$\Phi(A) \Leftrightarrow \Phi(B)$。</p>
<blockquote>
<p>对公式（或其一部分）做等值变换，则得到的公式是等值的</p>
</blockquote>
<h5 id="2-换名规则"><a href="#2-换名规则" class="headerlink" title="2.换名规则"></a>2.换名规则</h5><p>对于公式$A$，将其中某个量词的指导变元$x$，连同该量词辖域中相同变元符号$x$的所有<strong>约束出现</strong>都用<strong>不在公式$A$中出现的个体变元符号</strong>代替，其余部分不变，设所得公式为$A’$，则$A’ \Leftrightarrow A$.</p>
<h5 id="3-代替规则"><a href="#3-代替规则" class="headerlink" title="3.代替规则"></a>3.代替规则</h5><p>对于公式$A$，将其中某个个体变量符号$x$的<strong>所有自由出现的地方</strong>都使用<strong>不在公式$A$中出现的个体变元符号</strong>代替，其余部分不变，设所得公式为$A’$，则$A’ \Leftrightarrow A$.</p>
<p>【说明】</p>
<ul>
<li><p>换名规则和代替规则是为了使：</p>
<ul>
<li>每个变量符号在公式中要么自由出现，要么约束出现，没有既自由出现又约束出现的情况；</li>
<li>所有量词后面采用的指导变元符号互不相同</li>
</ul>
</li>
<li><p>对于自由变元的代替规则：</p>
<p>可使用满足如下条件的变元符号$y$去代替$x$的所有自由出现，得到的公式与原公式等值：</p>
<ul>
<li>$y$不在公式$A$中自由出现</li>
<li>$x$的每一个自由出现的地方都不在量词 $\forall y$ 或 $\exists y$ 的辖域中</li>
</ul>
</li>
</ul>
<h5 id="实例-例1"><a href="#实例-例1" class="headerlink" title="实例-例1"></a>实例-例1</h5><p>例1 将下面命题用两种形式符号化，并证明两者等值</p>
<p>（1）没有不犯错的人</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314205251228.png" alt="image-20220314205251228" style="zoom:50%;" /></p>
<p>（2）不是所有的人都爱看电影</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314205400714.png" alt="image-20220314205400714" style="zoom:50%;" /></p>
<h5 id="实例-例2"><a href="#实例-例2" class="headerlink" title="实例-例2"></a>实例-例2</h5><p>例2 将公式化成等值的不含有既有约束出现、又有自由出现的个体变项：$\forall x(F(x,y,z) \to \exists y G(x,y,z))$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314205532356.png" alt="image-20220314205532356" style="zoom:50%;" /></p>
<h5 id="实例-例3"><a href="#实例-例3" class="headerlink" title="实例-例3"></a>实例-例3</h5><p>例3 设个体域$D = \{ a,b,c\}$，消去下述公式中的量词：</p>
<p>（1）$\forall x \exists y(F(x) \to G(y))$</p>
<ul>
<li>解法一：</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314205659285.png" alt="image-20220314205659285" style="zoom:50%;" /></p>
<ul>
<li>解法二：</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314205759636.png" alt="image-20220314205759636" style="zoom:50%;" /></p>
<p>（2）$\exists x \forall y F(x,y)$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314205826321.png" alt="image-20220314205826321" style="zoom: 67%;" /></p>
<h3 id="6-2-一阶逻辑前束范式"><a href="#6-2-一阶逻辑前束范式" class="headerlink" title="6.2 一阶逻辑前束范式"></a>6.2 一阶逻辑前束范式</h3><h4 id="定义2-前束范式"><a href="#定义2-前束范式" class="headerlink" title="定义2 前束范式"></a>定义2 前束范式</h4><p><strong>定义2</strong>：设$A$为一个一阶逻辑公式，若$A$具有如下形式</p>
<script type="math/tex; mode=display">
Q_1x_1Q_2x_2…Q_kx_kB</script><p>则称$A$为<strong>前束范式</strong>，其中$Q_i (1 \leq i \leq k)$为 $\forall$ 或 $\exists$，$B$为不含量词的公式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314210514684.png" alt="image-20220314210514684" style="zoom: 67%;" /></p>
<blockquote>
<p>下面第一个：量词前含有否定联结词</p>
<p>下面第二个：B中含有量词$\exists$</p>
</blockquote>
<h4 id="定理1（前束范式存在定理）"><a href="#定理1（前束范式存在定理）" class="headerlink" title="定理1（前束范式存在定理）"></a>定理1（前束范式存在定理）</h4><p>一阶逻辑中的任何公式都存在与之等值的前束范式</p>
<h5 id="实例-例4（前束范式）"><a href="#实例-例4（前束范式）" class="headerlink" title="实例-例4（前束范式）"></a>实例-例4（前束范式）</h5><p>例4 求下列公式的前束范式</p>
<p>（1）$\neg \exists x (M(x) \land F(x))$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314210729493.png" alt="image-20220314210729493" style="zoom: 67%;" /></p>
<p>（2）$\forall x F(x) \land \neg \exists G(x)$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314210819626.png" alt="image-20220314210819626" style="zoom: 67%;" /></p>
<p>（3）$\forall x F(x) \to \exists y (G(x,y) \land \neg H(y))$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314210950533.png" alt="image-20220314210950533" style="zoom: 67%;" /></p>
<h3 id="6-3-一阶逻辑的推理理论"><a href="#6-3-一阶逻辑的推理理论" class="headerlink" title="6.3 一阶逻辑的推理理论"></a>6.3 一阶逻辑的推理理论</h3><blockquote>
<p>推理理论的形式结构：</p>
<ol>
<li><p>$A_1 \land A_2 \land … \land A_k \to B$</p>
<p>若此式是永真式，则称推理正确，</p>
<p>记作$A_1 \land A_2 \land … \land A_k \Rightarrow B$</p>
</li>
<li><p>前提：$A_1,A_2,…,A_k$</p>
<p>结论：$B$</p>
</li>
</ol>
<p>判断推理是否正确：判别$A_1 \land A_2 \land … \land A_k \rightarrow B$是否为永真式</p>
<p>推理定律：永真式的蕴含式</p>
</blockquote>
<h4 id="推理定律"><a href="#推理定律" class="headerlink" title="推理定律"></a>推理定律</h4><h5 id="第一组：命题逻辑推理定律的代换实例"><a href="#第一组：命题逻辑推理定律的代换实例" class="headerlink" title="第一组：命题逻辑推理定律的代换实例"></a>第一组：命题逻辑推理定律的代换实例</h5><p>命题逻辑11条推理定律</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314211413476.png" alt="image-20220314211413476" style="zoom: 60%;" /></p>
<h5 id="第二组：基本等值式生成的推理定律"><a href="#第二组：基本等值式生成的推理定律" class="headerlink" title="第二组：基本等值式生成的推理定律"></a>第二组：基本等值式生成的推理定律</h5><p>每个等值式可产生两个推理定律</p>
<h6 id="（1）命题逻辑的等值式（16组24个等值式）"><a href="#（1）命题逻辑的等值式（16组24个等值式）" class="headerlink" title="（1）命题逻辑的等值式（16组24个等值式）"></a>（1）命题逻辑的等值式（16组24个等值式）</h6><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314211514695.png" alt="image-20220314211514695" style="zoom: 57%;" /></p>
<h6 id="（2）一阶逻辑的等值式（4组14个等值式）"><a href="#（2）一阶逻辑的等值式（4组14个等值式）" class="headerlink" title="（2）一阶逻辑的等值式（4组14个等值式）"></a>（2）一阶逻辑的等值式（4组14个等值式）</h6><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314211547583.png" alt="image-20220314211547583" style="zoom: 55%;" /></p>
<h6 id="（3）其他常用推理定律"><a href="#（3）其他常用推理定律" class="headerlink" title="（3）其他常用推理定律"></a>（3）其他常用推理定律</h6><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220314211718384.png" alt="image-20220314211718384" style="zoom: 60%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第7节 一阶逻辑自然推理系统</title>
    <url>/mathematical_logic/mathematical-logic-ch7/</url>
    <content><![CDATA[<p><strong>主要内容</strong></p>
<ul>
<li>自然推理系统$N_L$及其推理规则</li>
<li>一阶逻辑的归结推理法</li>
</ul>
<span id="more"></span>
<h3 id="自然推理系统-N-L"><a href="#自然推理系统-N-L" class="headerlink" title="自然推理系统$N_L$"></a>自然推理系统$N_L$</h3><p><strong>定义1</strong> 自然推理系统$N_L$定义如下：</p>
<ul>
<li>字母表（同一阶语言L的字母表）</li>
<li>合式公式（同L的合式公式的定义）</li>
<li>推理规则<ol>
<li>前提引入规则</li>
<li>结论引入规则</li>
<li>置换规则</li>
<li>合取引入、消去规则</li>
<li>双重否定引入、消去规则</li>
<li>析取引入、消去规则</li>
<li>蕴含引入、消去规则</li>
<li>拒取式规则</li>
<li>矛盾消去、否定消去、否定引入规则</li>
<li>假言三段论规则</li>
<li>析取三段论规则</li>
<li><strong>$\forall e$规则</strong></li>
<li><strong>$\forall i$规则</strong></li>
<li><strong>$\exists e$规则</strong></li>
<li><strong>$\exists i$规则</strong></li>
</ol>
</li>
</ul>
<h4 id="全称量词消去规则"><a href="#全称量词消去规则" class="headerlink" title="全称量词消去规则"></a>全称量词消去规则</h4><h5 id="1-全称量词消去规则-forall-e-规则"><a href="#1-全称量词消去规则-forall-e-规则" class="headerlink" title="1.全称量词消去规则($\forall e$规则)"></a>1.全称量词消去规则($\forall e$规则)</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321233210071.png" alt="image-20220321233210071" style="zoom:67%;" /></p>
<p>$\forall$消去规则必须考虑<strong>t对$A(x)$中的x是自由的</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321233310687.png" alt="image-20220321233310687" style="zoom: 67%;" /></p>
<h5 id="2-全称量词引入规则（-forall-i-规则）"><a href="#2-全称量词引入规则（-forall-i-规则）" class="headerlink" title="2.全称量词引入规则（$\forall i$规则）"></a>2.全称量词引入规则（$\forall i$规则）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321233502262.png" style="zoom:67%;" /></p>
<h5 id="3-存在量词引入规则（-exists-i-规则）"><a href="#3-存在量词引入规则（-exists-i-规则）" class="headerlink" title="3.存在量词引入规则（$\exists i$规则）"></a>3.存在量词引入规则（$\exists i$规则）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321233554926.png" alt="image-20220321233554926" style="zoom:67%;" /></p>
<h5 id="4-存在量词消去规则（-exists-e-规则）"><a href="#4-存在量词消去规则（-exists-e-规则）" class="headerlink" title="4.存在量词消去规则（$\exists e$规则）"></a>4.存在量词消去规则（$\exists e$规则）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321233634370.png" alt="image-20220321233634370" style="zoom:67%;" /></p>
<h3 id="一阶逻辑的归结推理法"><a href="#一阶逻辑的归结推理法" class="headerlink" title="一阶逻辑的归结推理法"></a>一阶逻辑的归结推理法</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321234245916.png" alt="image-20220321234245916" style="zoom:67%;" /></p>
<h4 id="命题逻辑消解证明法（或归结推理法）的做法"><a href="#命题逻辑消解证明法（或归结推理法）的做法" class="headerlink" title="命题逻辑消解证明法（或归结推理法）的做法"></a>命题逻辑消解证明法（或归结推理法）的做法</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321234227003.png" alt="image-20220321234227003" style="zoom: 67%;" /></p>
<h4 id="一阶逻辑归结推理法的做法"><a href="#一阶逻辑归结推理法的做法" class="headerlink" title="一阶逻辑归结推理法的做法"></a>一阶逻辑归结推理法的做法</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220321234322854.png" alt="image-20220321234322854" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第5节 一阶逻辑基本概念</title>
    <url>/mathematical_logic/mathematical-logic-ch5/</url>
    <content><![CDATA[<p><strong>引言</strong>——我们需要更丰富的语言</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310153420277.png" alt="image-20220310153420277" style="zoom: 67%;" /></p>
<blockquote>
<p>极大项$M_6$</p>
<p>无法表示出“所有”，只能归为简单命题</p>
</blockquote>
<span id="more"></span>
<p><strong>主要内容</strong></p>
<blockquote>
<p>一阶逻辑命题符号化：$\begin{cases} 个体词、谓词、量词 \\ 一阶逻辑命题符号化 \\  \end{cases}$</p>
<p>​                $\Downarrow$</p>
<p>一阶逻辑公式及其解释：$\begin{cases} 一阶语言 \\ 合式公式（谓词公式） \\ 合式公式的解释 \\ 永真式、矛盾式、可满足式 \\ \end{cases}$</p>
</blockquote>
<h3 id="5-1-一阶逻辑命题符号化"><a href="#5-1-一阶逻辑命题符号化" class="headerlink" title="5.1 一阶逻辑命题符号化"></a>5.1 一阶逻辑命题符号化</h3><ul>
<li><p><strong>个体词</strong>：可以独立存在的客体，它可以是一个具体的事物，也可以是一个抽象的概念</p>
</li>
<li><p><strong>个体常项</strong>：表示具体或特定的客体的个体词，一般用$a,b,c$表示</p>
</li>
<li><p><strong>个体变项</strong>：表示抽象或泛指的客体的个体词，一般用$x,y,z$表示</p>
</li>
<li><p><strong>个体域（论域）</strong>：个体变项的取值范围</p>
<blockquote>
<ul>
<li>有限个体域 ，如：$\{a,b,c\},\{1,2\}$</li>
<li>无限个体域，如：$N,Z,R,…$</li>
<li>全总个体域——由宇宙间一切事物组成</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>注意：如没有指明个体域，均指全总个体域</strong></p>
<h4 id="个体词和谓词"><a href="#个体词和谓词" class="headerlink" title="个体词和谓词"></a>个体词和谓词</h4><blockquote>
<p>例：数理逻辑是科学。</p>
<p>可以分解为：主语——数理逻辑；谓语——是科学。</p>
<p>$P(x)：x是科学$</p>
<p>表示为$P$（数理逻辑），同理可以表达$P$（高等代数）；$P$（人工智能）……</p>
<p>上述例子称<strong>“主语”为个体词，“谓语”为谓词。</strong></p>
</blockquote>
<ul>
<li><p><strong>谓词</strong>：表示个体词性质或个体词相互之间关系的词</p>
</li>
<li><p><strong>谓词常项</strong>：表示<strong>具体</strong>性质或关系的谓词</p>
<blockquote>
<p>如：$M(a):a是人$</p>
<p>0元谓词，a为谓词常项。</p>
</blockquote>
</li>
<li><p><strong>谓词变项</strong>：表示<strong>抽象或泛指</strong>性质或关系的谓词</p>
<blockquote>
<p>如：$M(x):x具有性质M$</p>
<p>1元谓词，x为谓词变项</p>
</blockquote>
</li>
<li><p><strong>n元谓词</strong>：含$n(n \geq 1)$个个体变项的谓词</p>
<ul>
<li><p><strong>一元谓词</strong>（$n = 1$）——表示个体的<strong>性质</strong></p>
</li>
<li><p><strong>多元谓词</strong>（$n \geq 2$）——表示个体之间的<strong>关系</strong></p>
<blockquote>
<p>如：$H(x,y):x与y有关系H，H(x,y):x \geq y,…$</p>
</blockquote>
</li>
<li><p><strong>0元谓词</strong>——不含个体变项的谓词</p>
</li>
</ul>
</li>
</ul>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>表示数量的词</p>
<ul>
<li><p><strong>全称量词$\forall$</strong>：表示所有的</p>
<ul>
<li>$\forall x：对个体域中的所有x$</li>
</ul>
<blockquote>
<p>$\forall x F(x)$表示：个体域中<strong>所有的</strong>x具有性质F</p>
<p>$\forall x \forall y G(x,y)$表示：个体域中<strong>所有的</strong>x和y有关系G</p>
</blockquote>
</li>
<li><p><strong>存在量词$\exists$</strong>：表示存在，有一个</p>
<ul>
<li>$\exists x：个体域中有一个x$</li>
</ul>
<blockquote>
<p>$\exists xF(x)$表示: 个体域中<strong>有一个</strong>$x$具有性质$F$<br>$\exists x \exists yG(x,y)$表示: 个体域中<strong>存在$x$和$y$</strong>有关系$G$<br>$\forall x \exists yG(x,y)$表示: 对个体域中<strong>每一个</strong>$x$都<strong>存在一个</strong>$y$使得$x$和$y$有关系$G$<br>$\exists x \forall yG(x,y)$表示: 个体域中<strong>存在一个</strong>$x$使得对<strong>每一个</strong>$y$,   $x$和$y$有关系$G$</p>
</blockquote>
</li>
</ul>
<h5 id="实例-例1（命题逻辑和一阶逻辑）"><a href="#实例-例1（命题逻辑和一阶逻辑）" class="headerlink" title="实例-例1（命题逻辑和一阶逻辑）"></a>实例-例1（命题逻辑和一阶逻辑）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310201743629.png" alt="image-20220310201743629" style="zoom:50%;" /></p>
<ul>
<li>在一阶逻辑中</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310201845728.png" alt="image-20220310201845728" style="zoom:50%;" /></p>
<p>注意：</p>
<ul>
<li>(1) 不含<strong>个体变项</strong>的谓词称为<strong>0元谓词</strong>.</li>
<li>(2) 当谓词为<strong>谓词常项</strong>时， 0元谓词为命题.</li>
<li>(3) 任何命题均可以表示成0元谓词，因而可将命题看成特殊的谓词.</li>
</ul>
<h5 id="实例-例2"><a href="#实例-例2" class="headerlink" title="实例-例2"></a>实例-例2</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310202020667.png" alt="image-20220310202020667" style="zoom:50%;" /></p>
<ul>
<li>引入<strong>特性谓词</strong>$F(x)$（表示x是人）;</li>
<li>(1),(2)是一阶逻辑中两个“基本”公式.</li>
</ul>
<blockquote>
<p>全称量词——<strong>蕴含式</strong>；（对于宇宙间一切个体，如果个体是人，则他爱美）</p>
<p>存在量词——<strong>合取</strong>。（在宇宙间存在这样的一个个体，他是人，他用左手写字）</p>
</blockquote>
<h5 id="实例-例3（命题符号化的形式和真值）"><a href="#实例-例3（命题符号化的形式和真值）" class="headerlink" title="实例-例3（命题符号化的形式和真值）"></a>实例-例3（命题符号化的形式和真值）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310202449002.png" alt="image-20220310202449002" style="zoom:50%;" /></p>
<ul>
<li>不同个体域内，命题符号化形式可能不同（也可能相同），真值可能不同（也可能相同）</li>
</ul>
<h5 id="实例-例4（默认全总个体域）"><a href="#实例-例4（默认全总个体域）" class="headerlink" title="实例-例4（默认全总个体域）"></a>实例-例4（默认全总个体域）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310202702776.png" alt="image-20220310202702776" style="zoom:50%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310202825080.png" alt="image-20220310202825080" style="zoom:50%;" /></p>
<ul>
<li>题目中没给个体域，一律用<strong>全总个体域</strong></li>
</ul>
<h5 id="实例-例5"><a href="#实例-例5" class="headerlink" title="实例-例5"></a>实例-例5</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310202937305.png" alt="image-20220310202937305" style="zoom:50%;" /></p>
<h5 id="实例-例6"><a href="#实例-例6" class="headerlink" title="实例-例6"></a>实例-例6</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310202958406.png" alt="image-20220310202958406" style="zoom:50%;" /></p>
<ul>
<li>$\forall$与$\exists$不能随意交换</li>
</ul>
<h3 id="5-2-一阶逻辑公式及解释"><a href="#5-2-一阶逻辑公式及解释" class="headerlink" title="5.2 一阶逻辑公式及解释"></a>5.2 一阶逻辑公式及解释</h3><h4 id="定义1-一阶语言的字母表"><a href="#定义1-一阶语言的字母表" class="headerlink" title="定义1 一阶语言的字母表"></a>定义1 一阶语言的字母表</h4><blockquote>
<p>由<em>L</em>生成一阶语言L的字母表</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310203207884.png" alt="image-20220310203207884" style="zoom: 67%;" /></p>
<h4 id="定义2-一阶语言L的项"><a href="#定义2-一阶语言L的项" class="headerlink" title="定义2 一阶语言L的项"></a>定义2 一阶语言L的项</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310203305119.png" alt="image-20220310203305119" style="zoom: 67%;" /></p>
<blockquote>
<p>项是一个个体（直接生成或函数生成）</p>
<p>如：$a,x,x+y,f(x),g(x,y)$等都是项</p>
</blockquote>
<h4 id="定义3-原子公式"><a href="#定义3-原子公式" class="headerlink" title="定义3 原子公式"></a>定义3 原子公式</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310203349370.png" alt="image-20220310203349370" style="zoom:67%;" /></p>
<blockquote>
<p>谓词作用于个体构成的</p>
<p>$F(x,y),F(f(x_1,x_2),g(x_3,x_4))$等均为原子公式</p>
</blockquote>
<h4 id="定义4-一阶语言的公式（合式公式）"><a href="#定义4-一阶语言的公式（合式公式）" class="headerlink" title="定义4 一阶语言的公式（合式公式）"></a>定义4 一阶语言的公式（合式公式）</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310203522515.png" alt="image-20220310203522515" style="zoom:67%;" /></p>
<blockquote>
<p>如：$F(x),F(x) <span class="md-search-hit md-search-select">\or</span> \neg G(x,y), \forall x(F(x) \to G(x)), \exists x \forall y (F(x) \to G(y) \land L(x,y))$等都是合式公式</p>
</blockquote>
<h4 id="定义5-指导变元、辖域、约束出现、自由出现"><a href="#定义5-指导变元、辖域、约束出现、自由出现" class="headerlink" title="定义5 指导变元、辖域、约束出现、自由出现"></a>定义5 指导变元、辖域、约束出现、自由出现</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310204222248.png" alt="image-20220310204222248" style="zoom:67%;" /></p>
<blockquote>
<p>例如：考虑公式：$\forall x(F(x,y)→G(x,z)) $，</p>
<p>$x$为指导变元，$(F(x,y)→G(x,z))$为$\forall x$的辖域，</p>
<p>$x$的两次出现均为约束出现，$y$与$z$均为自由出现</p>
<p>又如，$\exists x(F(x,y,z) \to \forall y (G(x,y) \land H(x,y,z)))$，</p>
<p>$\exists x$中的$x$是指导变元，辖域为$(F(x,y,z) \to \forall y (G(x,y) \land H(x,y,z))).$</p>
<p>$\forall y$中的$y$是指导变元，辖域为$(G(x,y) \land H(x,y,z)).$</p>
<p>x的3次出现都是约束出现，y的第一次出现时自由出现，后2次是约束出现，z的2次出现都是自由出现</p>
</blockquote>
<h4 id="定义6-封闭的公式"><a href="#定义6-封闭的公式" class="headerlink" title="定义6 封闭的公式"></a>定义6 封闭的公式</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310204959478.png" alt="image-20220310204959478" style="zoom: 67%;" /></p>
<blockquote>
<p>例如：$\forall x \forall y (F(x) \land G(y) \to H(x,y))$为闭式，</p>
<p>而$\exists x (F(x) \land G(x,y))$不是闭式——自由出现的个体变项是y</p>
</blockquote>
<h4 id="定义7-公式的解释"><a href="#定义7-公式的解释" class="headerlink" title="定义7 公式的解释"></a>定义7 公式的解释</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310205302465.png" alt="image-20220310205302465" style="zoom:67%;" /></p>
<h5 id="实例-例7"><a href="#实例-例7" class="headerlink" title="实例-例7"></a>实例-例7</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310205402417.png" alt="image-20220310205402417" style="zoom:50%;" /></p>
<blockquote>
<p>前两个是封闭的公式，是命题</p>
<p>第三个不是封闭的，可能是命题，也可能不是命题</p>
</blockquote>
<h4 id="定理1-闭式命题"><a href="#定理1-闭式命题" class="headerlink" title="定理1 闭式命题"></a>定理1 闭式命题</h4><p><strong>定理</strong>1：闭式在任何解释下都是命题</p>
<p>注意：<strong>不是闭式的公式在解释下可能是命题，也可能不是命题</strong></p>
<h4 id="定义8-公式的类型"><a href="#定义8-公式的类型" class="headerlink" title="定义8 公式的类型"></a>定义8 公式的类型</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310205547999.png" alt="image-20220310205547999" style="zoom:67%;" /></p>
<p>说明：</p>
<ul>
<li><p>（1）永真式为可满足式，但反之不真. </p>
</li>
<li><p>（2）判断公式是否是可满足的(永真式, 矛盾式)是不可判定的，即不存在一个算法能够在有限步内判断。任意给定的公式是可满足的(永真式, 矛盾式)</p>
<blockquote>
<p>公式中的谓词和函数可以有各种不同的解释</p>
</blockquote>
</li>
</ul>
<h4 id="定义9-代换实例"><a href="#定义9-代换实例" class="headerlink" title="定义9 代换实例"></a>定义9 代换实例</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310205730566.png" alt="image-20220310205730566" style="zoom:67%;" /></p>
<blockquote>
<p>例如：$F(x) \to G(x), \forall x F(x) \to \exists y G(y)$等都是$p \to q$的代换实例</p>
</blockquote>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p><strong>定理2</strong>：重言式的代换实例都是永真式，矛盾式的代换实例都是矛盾式</p>
<h5 id="实例-例8"><a href="#实例-例8" class="headerlink" title="实例-例8"></a>实例-例8</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310210449030.png" alt="image-20220310210449030" style="zoom:50%;" /></p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310210521362.png" alt="image-20220310210521362" style="zoom:67%;" /></p>
<p>注意：当公式不引起歧义时，经常省去关于量词的括号（在约束变元前）</p>
<h4 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h4><p>谓词公式的语法分析树：</p>
<ul>
<li>量词$\forall x$和$\exists x$形成节点，而且和否定一样，只有<strong>一棵子树</strong>；</li>
<li>对于一般形式$P(t_1,t_2,…,t_n)$的谓词表达式，以符号P为一个结点，P有<strong>n棵子树</strong>，即项$t_1,t_2,…,t_n$的语法分析树</li>
</ul>
<h5 id="实例-例9（语法分析树）"><a href="#实例-例9（语法分析树）" class="headerlink" title="实例-例9（语法分析树）"></a>实例-例9（语法分析树）</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220310210833091.png" alt="image-20220310210833091" style="zoom:50%;" /></p>
<h5 id="实例-例10"><a href="#实例-例10" class="headerlink" title="实例-例10"></a>实例-例10</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311093632739.png" alt="image-20220311093632739" style="zoom:50%;" /></p>
<blockquote>
<p>定义谓词：学生、老师、年轻</p>
<p>对任意x，如果x是学生。则存在老师，学生比老师年轻</p>
</blockquote>
<h5 id="实例-例11"><a href="#实例-例11" class="headerlink" title="实例-例11"></a>实例-例11</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311094113825.png" alt="image-20220311094113825" style="zoom:50%;" /></p>
<blockquote>
<p>没有书是气体——不存在x是书，x是气体</p>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>作用于已有的个体，生成新的个体</p>
<p>函数值是唯一的，表示唯一的关系</p>
<ul>
<li><p><strong>函数</strong>：表示个体之间的运算，可作用于一个或数个个体（用小写字母）</p>
<ul>
<li><p>给定一个或若干个体（对象），<strong>产生一个新的个体</strong>（对象）</p>
<blockquote>
<p>例：x的父亲 $father(张三)$</p>
<p>两数之和仍是一个数 $add(e_1,e_2)$</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h5 id="实例-例12"><a href="#实例-例12" class="headerlink" title="实例-例12"></a>实例-例12</h5><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220311094257484.png" alt="image-20220311094257484" style="zoom:50%;" /></p>
<h5 id="谓词和函数的区别"><a href="#谓词和函数的区别" class="headerlink" title="谓词和函数的区别"></a>谓词和函数的区别</h5><ul>
<li>谓词代表<strong>语句</strong>，<strong>结果是性质或关系</strong>（具有真假值）；</li>
<li>函数代表<strong>关系运算</strong>，结果将返回一个<strong>新个体</strong>。</li>
</ul>
<blockquote>
<p>例：</p>
<p>谓词$SUM(e_1, e_2, e_3)$ 说明$e_1、e_2、e_3$之间的关系是$e_1$与$e_2$的和是$e_3$——返回bool类型</p>
<p>函数$add(e_1, e_2)$说明$e_1$与$e_2$相加的结果仍是一个数——返回个体类型</p>
</blockquote>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第8节 归结演绎推理</title>
    <url>/mathematical_logic/mathematical-logic-ch8/</url>
    <content><![CDATA[<h3 id="1-子句集"><a href="#1-子句集" class="headerlink" title="1.子句集"></a>1.子句集</h3><h4 id="定义1（文字、子句）"><a href="#定义1（文字、子句）" class="headerlink" title="定义1（文字、子句）"></a>定义1（文字、子句）</h4><p><strong>定义1</strong>：原子（谓词）公式及其否定称为<strong>文字</strong>；若干个文字的一个<u>析取式</u>称为一个<strong>子句</strong>；<br>不含任何文字的子句称为<strong>空子句</strong>，记为$\lambda$或NIL。</p>
<blockquote>
<p>例如，</p>
<p>$\neg D(y), \ I(a), \ \ P \vee Q \vee \neg R, \ \ \neg I(z) \vee R(z)$</p>
<p>前两个是文字，后两个是子句</p>
</blockquote>
<h4 id="定义2（子句集）"><a href="#定义2（子句集）" class="headerlink" title="定义2（子句集）"></a>定义2（子句集）</h4><p><strong>定义2</strong>：对一个谓词公式G，通过以下步骤所得的子句集S，称为G的<strong>子句集</strong>（clauses）</p>
<span id="more"></span>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074039804.png" alt="image-20220322074039804" style="zoom:80%;" /></p>
<ol>
<li><p><strong>消蕴含词和等价词</strong></p>
<blockquote>
<p>对于等价词，第一行为等价定义，第二行为等价的左右同值</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074122126.png" alt="image-20220322074122126" style="zoom:80%;" /></p>
</li>
<li><p><strong>移动否定词作用范围，使其仅作用于原子公式</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074302416.png" alt="image-20220322074302416" style="zoom:80%;" /></p>
</li>
<li><p><strong>适当改名，使变量标准</strong></p>
<p>（即：对于不同的约束，对应不同的变量）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074422506.png" alt="image-20220322074422506" style="zoom:80%;" /></p>
</li>
<li><p><strong>消去存在量词（Skolem化），同时进行变元替换</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074515662.png" alt="image-20220322074515662" style="zoom:80%;" /></p>
</li>
<li><p><strong>消去所有全称量词</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074551682.png" alt="image-20220322074551682" style="zoom:80%;" /></p>
</li>
<li><p><strong>化公式为合取范式</strong></p>
<blockquote>
<p>使用摩根律</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074621531.png" alt="image-20220322074621531" style="zoom:80%;" /></p>
</li>
<li><p><strong>适当改名，使子句间无同名变元</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074704508.png" alt="image-20220322074704508" style="zoom:80%;" /></p>
</li>
<li><p><strong>消去合取词，以子句为元素组成一个集合S</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322074734346.png" alt="image-20220322074734346" style="zoom:80%;" /></p>
</li>
</ol>
<h4 id="化子句集的步骤（8步）"><a href="#化子句集的步骤（8步）" class="headerlink" title="化子句集的步骤（8步）"></a>化子句集的步骤（8步）</h4><ol>
<li>消去蕴含词和等价词。</li>
<li>使否定词仅作用于原子公式。</li>
<li>适当改名使量词间不含同名指导变元。</li>
<li>消去存在量词。</li>
<li>消去全称量词。</li>
<li>化公式为合取范式。</li>
<li>适当改名，使子句间无同名变元。</li>
<li>消去合取词，以子句为元素组成一个集合S。</li>
</ol>
<p><strong>子句集</strong>：</p>
<ul>
<li>无量词约束；（3，4，5）</li>
<li>元素只是文字的析取；（1）</li>
<li>否定符只作用于单个文字；（2）</li>
<li>元素间默认为合取。（6，7，8）</li>
</ul>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322082805868.png" alt="image-20220322082805868" style="zoom:67%;" /></p>
<ul>
<li><p>注意：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322082830549.png" alt="image-20220322082830549" style="zoom:67%;" /></p>
</li>
</ul>
<h4 id="定理1（谓词公式和子句集不可满足的关系）"><a href="#定理1（谓词公式和子句集不可满足的关系）" class="headerlink" title="定理1（谓词公式和子句集不可满足的关系）"></a>定理1（谓词公式和子句集不可满足的关系）</h4><p><strong>定理1</strong>：谓词公式G不可满足当且仅当其子句集S不可满足</p>
<blockquote>
<p>G在任何解释下都为假，则子句集不存在解使其为真</p>
</blockquote>
<h4 id="定义3（子句集不可满足）"><a href="#定义3（子句集不可满足）" class="headerlink" title="定义3（子句集不可满足）"></a>定义3（子句集不可满足）</h4><p><strong>定义3</strong>：子句集S是不可满足的，当且仅当其全部子句的合取式是不可满足的。</p>
<h3 id="2-命题逻辑中的归结原理"><a href="#2-命题逻辑中的归结原理" class="headerlink" title="2.命题逻辑中的归结原理"></a>2.命题逻辑中的归结原理</h3><p><strong>归结原理的提出</strong>：归结原理(Principle of resolution)又称消解原理,1965年鲁滨逊（J. A. Robinson）提出，从理论上解决了定理证明问题。归结原理提出的是一种<strong>证明子句集不可满足性</strong>，从而实现定理证明的一种理论及方法。</p>
<blockquote>
<p>证明有效性（蕴含式是重言式）可证明<strong>公式否定的不可满足性</strong>（永假式）</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322083341470.png" alt="image-20220322083341470" style="zoom: 67%;" /></p>
<h4 id="定义4（互补文字）"><a href="#定义4（互补文字）" class="headerlink" title="定义4（互补文字）"></a>定义4（互补文字）</h4><p><strong>定义4</strong>：设$L$为一个文字，则$L$与$\neg L$为<strong>互补文字</strong></p>
<h4 id="定义5（归结式、亲本子句、消解基）"><a href="#定义5（归结式、亲本子句、消解基）" class="headerlink" title="定义5（归结式、亲本子句、消解基）"></a>定义5（归结式、亲本子句、消解基）</h4><blockquote>
<p>把两个子句中，互补的删掉，剩余的析取，构成归结式</p>
</blockquote>
<p><strong>定义5</strong>： 设$C_1$，$C_2$是命题逻辑中的两个子句，$C_1$中有文字$L_1$ ，$C_2$中有文字$L_2$ ，且$L_1$与$L_2$互补，从$C_1$ 、$C_2$中分别删除$L_1$ 、$L_2$ ，再将剩余部分析取起来，记构成的新子句为$C_{1 \ 2}$，则$C_{1 \  2}$为$C_1$ 、$C_2$的<strong>归结式</strong>，$C_1$ 、$C_2$称为其归结式的<strong>亲本子句</strong>，称$L_1$ 、$L_2$ 为<strong>消解基</strong>。</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322083818917.png" alt="image-20220322083818917" style="zoom:80%;" /></p>
<blockquote>
<p>把两个式子中的Q删去</p>
</blockquote>
<p>得到的结果为：$C_{1 \ 2} = \neg P \vee R \vee S$</p>
<h4 id="定理2（归结式和亲本子句的关系）"><a href="#定理2（归结式和亲本子句的关系）" class="headerlink" title="定理2（归结式和亲本子句的关系）"></a>定理2（归结式和亲本子句的关系）</h4><p><strong>定理2</strong>：归结式是其亲本子句的逻辑结果</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322083948079.png" alt="image-20220322083948079" style="zoom:67%;" /></p>
<h4 id="利用归结原理证明命题公式的思路"><a href="#利用归结原理证明命题公式的思路" class="headerlink" title="利用归结原理证明命题公式的思路"></a>利用归结原理证明命题公式的思路</h4><ol>
<li>先<strong>求出</strong>要证明的命题公式的<strong>否定式的子句集S</strong>；</li>
<li>然后对子句集S（一次或者多次）<strong>使用归结原理</strong>；</li>
<li>若<strong>在某一步推出了空子句，即推出了矛盾</strong>，则说明子句集S是不可满足的，从而原否定式也是不可满足的，进而说明原公式是永真的。</li>
</ol>
<p><strong>推出空子句就说明子句集不可满足</strong>，原因是：</p>
<ul>
<li><p>空子句就是F，推出空子句就是推出了F</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322084525323.png" alt="image-20220322084525323" style="zoom: 67%;" /></p>
</li>
<li><p>归结原理是正确的推理形式，由正确的推理形式推出了F，则<strong>说明前提不真</strong>，即归结出空子句的两个亲本子句至少有一个为假</p>
</li>
<li><p>而这两个亲本子句可能都是原子句集S中不可满足的子句。</p>
</li>
<li><p>如果这两个亲本子句不是或不全是S中的子句，那么它们必定是某次归结的结果。</p>
</li>
<li><p>同样的道理向上回溯，一定会推出原子句集中至少有一个子句为假，从而说明S不可满足</p>
</li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322085003781.png" alt="image-20220322085003781" style="zoom:67%;" /></p>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322144651496.png" alt="image-20220322144651496" style="zoom:67%;" /></p>
<p>不断使用归结原理，直到推出矛盾（<strong>NIL</strong>）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322144721069.png" alt="image-20220322144721069" style="zoom:67%;" /></p>
<h3 id="3-替换与合一"><a href="#3-替换与合一" class="headerlink" title="3.替换与合一"></a>3.替换与合一</h3><p><strong>问题</strong>：在一阶谓词中应用消解原理，无法直接找到互否文字的子句对</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322090339597.png" alt="image-20220322090339597" style="zoom:67%;" /></p>
<p><strong>解决方法</strong>：<strong>对个体变元做适当替换</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322090346074.png" alt="image-20220322090346074" style="zoom:67%;" /></p>
<h4 id="定义6（替换的定义）"><a href="#定义6（替换的定义）" class="headerlink" title="定义6（替换的定义）"></a>定义6（替换的定义）</h4><blockquote>
<p>替换是一个有限集合</p>
</blockquote>
<p><strong>定义6</strong>：一个替换是形如$\{t_1/x_1, t_2/x_2, …, t_n/x_n\}$的有限集合，其中$t_1, \ t_2 , …, t_n$是项，$x_1, x_2, …, x_n$是互不相同的个体变元。$t_i /x_i$表示用$t_i$代换$x_i$，$t_i$与$x_i$不同，$x_i$也不能出现在$t_j$ 中（$j=1,2, …, n$）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322090529132.png" alt="image-20220322090529132" style="zoom:67%;" /></p>
<blockquote>
<p>$g(y)$替换x中，y出现了，则$f(g(y)) / y$，没有消去y</p>
</blockquote>
<h4 id="定义7（表达式在替换下的例）"><a href="#定义7（表达式在替换下的例）" class="headerlink" title="定义7（表达式在替换下的例）"></a>定义7（表达式在替换下的例）</h4><p><strong>定义7</strong>：设$θ= \{ t_1/x_1, t_2/x_2, …, t_n/x_n \}$是一个替换，$E$是一个表达式，对公式$E$实施替换$θ$，即把$E$中出现的个体变元$x_j$都用$t_j$替换，记为$E \  θ$ ， 所得的结果称为$E$在$θ$下的例（instance）</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322090923746.png" alt="image-20220322090923746" style="zoom:67%;" /></p>
<h4 id="定义8（替换的复合-乘积）"><a href="#定义8（替换的复合-乘积）" class="headerlink" title="定义8（替换的复合/乘积）"></a>定义8（替换的复合/乘积）</h4><p><strong>定义8</strong>：设$θ＝ \{ t_1/x_1, t_2/x_2, …, t_n/x_n \}$，$λ＝ \{ u_1/y_1, u_2/y_2, …, u_n/y_n \}$是两个替换，则将$\{ t_1 \ λ /x_1, t_2 \ λ/x_2, …, t_n \ λ /x_n , u_1/y_1, u_2/y_2, …, u_n/y_n \}$中符合下列条件的元素删除<br>（1）$ t_i \ λ /x_i$ 当$t_i \ λ ＝ x_i$<br>（2）$ u_i/y_i $当$y_i \in \{x_1,…, x_n \}$<br>这样得到的集合为$ θ $与$λ $的复合或乘积，记为$θ · λ $</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322091538439.png" alt="image-20220322091538439" style="zoom: 67%;" /></p>
<h4 id="定义9（公式的合一）"><a href="#定义9（公式的合一）" class="headerlink" title="定义9（公式的合一）"></a>定义9（公式的合一）</h4><blockquote>
<p>合一是一种替换</p>
</blockquote>
<p><strong>定义9</strong>：设$S＝ \{ F_1,F_2,…,F_n \}$ 是一个原子谓词公式集，若存在一个替换$θ$，可使$ F_1 \ θ =F_2 \ θ =…=F_n \ θ $，则称$θ$为$S$的一个合一，称$S$为可合一的。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322092034615.png" alt="image-20220322092034615" style="zoom:67%;" /></p>
<h4 id="定义10（公式的最一般合一）"><a href="#定义10（公式的最一般合一）" class="headerlink" title="定义10（公式的最一般合一）"></a>定义10（公式的最一般合一）</h4><p><strong>定义10</strong>：设$σ$是原子公式集$S$的一个合一，如果对$S$的任何一个合一$θ$都存在一个替换$λ$，使得</p>
<script type="math/tex; mode=display">
θ ＝ σ · λ</script><p>则称$σ$为$S$的<strong>最一般合一(Most General Unifier)</strong>，简称<strong>MGU</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322092212294.png" alt="image-20220322092212294" style="zoom:67%;" /></p>
<h4 id="定义11（寻找最一般合一）"><a href="#定义11（寻找最一般合一）" class="headerlink" title="定义11（寻找最一般合一）"></a>定义11（寻找最一般合一）</h4><p><strong>定义11</strong>：设$S$是一个非空的具有相同谓词名的原子公式集，从$S$中各公式左边的第一项开始，同时向右比较，<u>直到发现第一个不都相同的项为止</u>，用<strong>这些项的差异部分组成的集合就是S的一个差异集</strong>。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322092557126.png" alt="image-20220322092557126" style="zoom:67%;" /></p>
<h4 id="合一算法（Unification-Algorithm）"><a href="#合一算法（Unification-Algorithm）" class="headerlink" title="合一算法（Unification Algorithm）"></a>合一算法（Unification Algorithm）</h4><blockquote>
<p>$S_k$是原子公式集。$\sigma_k$是替换。$D_k$是差异集</p>
</blockquote>
<ul>
<li>SteP1：置$k＝0，S_k＝S， σ_k ＝ \epsilon$；</li>
<li>SteP2：<strong>若$S_k$只含有一个谓词公式，则算法停止，$σ_k$就是最一般合一</strong>；</li>
<li>SteP3：求$S_k$的差异集$D_k$；</li>
<li>SteP4：若中存在元素$x_k$和$t_k$ ，其中$x_k$是变元， $t_k$是项。且$x_k$不在$t_k$中出现，则置$S_{k ＋1}$＝$S_k\{t_k/x_k\}$  ，$σ_{k+1}= σ_k \{t_k / x_k\}$ ，  $k＝k+1$然后转SteP2；</li>
<li>SteP5：算法停止，S的最一般合一不存在。</li>
</ul>
<blockquote>
<p>变元在项中出现，则不存在最一般合一</p>
<p>例如，$\{ x, f(x) \}$出现在差异集中，则算法停止，最一般合一（MGU）不存在</p>
</blockquote>
<h4 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322093155338.png" alt="image-20220322093155338" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322093629391.png" alt="image-20220322093629391" style="zoom:67%;" /></p>
<h4 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322093640601.png" alt="image-20220322093640601" style="zoom:67%;" /></p>
<h3 id="4-谓词逻辑中的归结原理"><a href="#4-谓词逻辑中的归结原理" class="headerlink" title="4.谓词逻辑中的归结原理"></a>4.谓词逻辑中的归结原理</h3><h4 id="定义12"><a href="#定义12" class="headerlink" title="定义12"></a>定义12</h4><p><strong>定义12</strong>：C1，C2为<strong>无相同变元</strong>的子句；L1，L2为其中的两个文字，L1和¬L2有最一般合一σ；C1，C2的二元归结式（二元消解式）为：<strong>（C1 σ －{L1 σ}） ∪ （ C2 σ－ {L2 σ}）</strong>其中C1，C2称作归结式的<strong>亲本子句</strong>；L1，L2称作消解文字。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322094241849.png" alt="image-20220322094241849" style="zoom: 80%;" /></p>
<h4 id="例7"><a href="#例7" class="headerlink" title="例7"></a>例7</h4><blockquote>
<p>使用a来代换所有的x——a/x</p>
<p>消去$P(a)$和$\neg P(a)$</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322094402280.png" alt="image-20220322094402280" style="zoom:67%;" /></p>
<h4 id="例8"><a href="#例8" class="headerlink" title="例8"></a>例8</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220322094459522.png" alt="image-20220322094459522" style="zoom:67%;" /></p>
<blockquote>
<p>还需说明的是，如果在参加归结的子句内部含有可合一的文字，则在进行归结之前，也应对这些文字进行合一，从而使子句达到最简。</p>
</blockquote>
<h4 id="例9"><a href="#例9" class="headerlink" title="例9"></a>例9</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411235556655.png" alt="image-20220411235556655" style="zoom:80%;" /></p>
<h4 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411235541896.png" alt="image-20220411235541896" style="zoom:80%;" /></p>
<h4 id="例10"><a href="#例10" class="headerlink" title="例10"></a>例10</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220325082447874.png" alt="image-20220325082447874" style="zoom: 80%;" /></p>
<blockquote>
<p>使用归结反演法，结论的否定作为前提条件析取，推出空字句</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220325082602180.png" alt="image-20220325082602180" style="zoom: 67%;" /></p>
<h4 id="例11"><a href="#例11" class="headerlink" title="例11"></a>例11</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220325083341917.png" alt="image-20220325083341917" style="zoom:80%;" /></p>
<blockquote>
<p>使用归结反演法来证明</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/xcUMIjilCQbK1Vw.png" alt="image-20220325084008192" style="zoom: 67%;" /></p>
<h3 id="5-应用归结原理求取问题答案"><a href="#5-应用归结原理求取问题答案" class="headerlink" title="5.应用归结原理求取问题答案"></a>5.应用归结原理求取问题答案</h3><h4 id="例12"><a href="#例12" class="headerlink" title="例12"></a>例12</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411235636057.png" alt="image-20220411235636057" style="zoom:80%;" /></p>
<blockquote>
<p>解题步骤：</p>
<p>①定义谓词</p>
<p>②化成谓词公式</p>
<p>③应用消解法</p>
<p>首先证明小张老师的存在性</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/2SZWohym83dOBaQ.png" alt="image-20220325084714127" style="zoom:67%;" /></p>
<blockquote>
<p>求取答案时，添加辅助谓词</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/9gIuYxOVAXCb1sy.png" alt="image-20220325085105190" style="zoom: 67%;" /></p>
<h4 id="应用归结原理求取问题答案的方法思路"><a href="#应用归结原理求取问题答案的方法思路" class="headerlink" title="应用归结原理求取问题答案的方法思路"></a>应用归结原理求取问题答案的方法思路</h4><ol>
<li>为待求解的问题找一个合适的求证目标谓词</li>
<li>增配（以析取形式）一个辅助谓词，该谓词的变元必须与对应目标谓词中的变元完全一致</li>
<li>进行归结（把前提的合取和目标的否定化为子句集）</li>
<li>当归结到刚好只剩下辅助谓词时，辅助谓词中原变元位置上的项就是所求的结果。</li>
</ol>
<p><strong>说明</strong>：辅助谓词是一个形式谓词，其作用仅是提取问题的答案</p>
<h4 id="例13"><a href="#例13" class="headerlink" title="例13"></a>例13</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220325090548246.png" alt="image-20220325090548246" style="zoom:67%;" /></p>
<blockquote>
<p>定义谓词，运用归结反演法求解，设置辅助谓词变量</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220325090743794.png" alt="image-20220325090743794" style="zoom:67%;" /></p>
<blockquote>
<p>归结，求解</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220325090932934.png" alt="image-20220325090932934" style="zoom:67%;" /></p>
<p><strong>总结</strong>：</p>
<ul>
<li>注意子句间无同名变元</li>
</ul>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑：第3章 数理逻辑应用在计算机软、硬件设计中</title>
    <url>/mathematical_logic/mathematical-logic-chapter3/</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>线性时态逻辑的定义、公式、检测</li>
<li>计算树逻辑公式构成、语义，判定状态是否满足公式</li>
</ul>
<blockquote>
<p>背景：软硬件系统错误给人类带来巨大损失：Intel1994、阿丽亚娜火箭1996、诺顿杀毒2007</p>
</blockquote>
<p>四种方法来保证软硬件系统的正确性和可靠性</p>
<ul>
<li><p>利用输入输出进行黑盒测试$\begin{cases} 模拟 \\ 测试 \\ \end{cases}$</p>
</li>
<li><p><strong>定理证明</strong>：应用公理和证明规则来证明系统的正确性，可用于推理无穷状态系统。耗时，只能由专家完成。不能完全自动化</p>
</li>
<li><p><strong>模型检测</strong>：有限状态并发的自动化验证系统</p>
</li>
</ul>
<blockquote>
<p>关键词：验证的动机、线性时态逻辑、模型检测：系统、工具和性质、分支时间逻辑、CTL*与LTL和CTL的表达能力、模型检测算法</p>
</blockquote>
<span id="more"></span>
<h2 id="3-1-验证的动机（目的）"><a href="#3-1-验证的动机（目的）" class="headerlink" title="3.1 验证的动机（目的）"></a>3.1 验证的动机（目的）</h2><ul>
<li><p>能够验证计算机系统的正确性</p>
<blockquote>
<p>如，系统必须经过验证过程才能应用</p>
</blockquote>
</li>
<li><p>验证系统安全性能</p>
<blockquote>
<p>如，银行系统，各种桥梁的设计等都有一个保密问题的验证</p>
</blockquote>
</li>
</ul>
<p>数理逻辑形式化验证计算机系统和程序正确性</p>
<h3 id="3-1-1-系统验证的分类"><a href="#3-1-1-系统验证的分类" class="headerlink" title="3.1.1 系统验证的分类"></a>3.1.1 系统验证的分类</h3><ol>
<li><p><strong>基于证明与基于模型</strong></p>
<ul>
<li><p><strong>基于证明</strong>：系统描述为一组逻辑公式$r$，而规范是另一个公式$\phi$，通过找到$r \vdash \phi$（可证明性）的证明来验证系统</p>
</li>
<li><p><strong>基于模型</strong>：系统描述为模型$M$，规范是公式$\phi$，通过计算模型M是否满足$\phi$（$M \vDash \phi$）来验证系统</p>
<blockquote>
<p>在模型为真的情况下，如果公式也为真，那么模型是满足公式的</p>
</blockquote>
</li>
</ul>
<p>基于模型的方法更简单（基于单一模型，而不是基于一个可能的无限类）</p>
<blockquote>
<p>合理性和完备性的问题</p>
<p>合理性：从前提$\gamma \Phi$，那么对于每一种解释，$\gamma$的为真，那么$\Phi$也为真</p>
<p>完备性：如果语义上是完备的，那么从前提推出结论是成立的</p>
</blockquote>
</li>
<li><p><strong>自动化的程度</strong></p>
<ul>
<li><p>自动化程度对不同的处理有差异</p>
<blockquote>
<p>全自动、全手动和处于二者之间的方法——CAD、CAM</p>
</blockquote>
</li>
<li><p>基于模型的方法高于基于逻辑的方法</p>
</li>
</ul>
</li>
<li><p><strong>完全验证与性质验证</strong></p>
<p>规范描述单一性质，和规范描述全部性质</p>
<p>完全验证的代价要高昂得多</p>
</li>
<li><p><strong>预期应用领域</strong></p>
<p>可应用于硬件或软件系统、顺序的或并发的系统、反应的或终止的系统。</p>
<ul>
<li><p>反应系统：对环境做出反应的系统</p>
<blockquote>
<p>OS、嵌入式系统，和硬件系统的验证等</p>
</blockquote>
</li>
<li><p>终止系统：类似于我们写的程序</p>
</li>
</ul>
</li>
<li><p><strong>开发前和开发后</strong></p>
<p>即：<em>开发过程早期进行验证是必须的</em></p>
</li>
</ol>
<h3 id="3-1-2-模型检测的验证方法"><a href="#3-1-2-模型检测的验证方法" class="headerlink" title="3.1.2 模型检测的验证方法"></a>3.1.2 模型检测的验证方法</h3><blockquote>
<p>模型检测是<strong>自动的</strong>、<strong>基于模型的</strong>、<strong>性质验证</strong>的处理方法。</p>
<p>对有限状态的并发的、反应式系统，利用穷举搜索方法判断系统是否满足给定的规范。</p>
</blockquote>
<p><strong>大体步骤</strong>：</p>
<ul>
<li>由用户定义一个模型开始</li>
<li>判断用户所断言的假设（规范/性质, property）在模型中是否有效</li>
<li>若无效，则产生由执行轨迹构成的<strong>反例</strong>（好处：可以对模型修改，使其满足验证的规范）</li>
</ul>
<p><strong>形式验证技术</strong>（由三部分构成）</p>
<ul>
<li>用于<strong>系统建模的框架</strong>——通常是某种描述语言</li>
<li>用于描述待验证性质的<strong>规范</strong>语言</li>
<li>用来确立系统描述<strong>是否满足规范的验证方法</strong></li>
</ul>
<p>基于模型检测方法验证系统，要做3件事：</p>
<ul>
<li>使用模型检测器的描述性语言对系统进行建模，得到一个模型$M$；</li>
<li>待证性质的规范利用一个<strong>时态逻辑公式</strong>$\phi$来表示</li>
<li>以$M$和$\phi$做输入进行模型检测——如果$M \vDash  \phi$（$M$满足$\phi$），输出yes，否则输出no</li>
</ul>
<h2 id="3-2-线性时态逻辑-LTL"><a href="#3-2-线性时态逻辑-LTL" class="headerlink" title="3.2 线性时态逻辑(LTL)"></a>3.2 线性时态逻辑(LTL)</h2><blockquote>
<p>模型检测基于时态逻辑（temporal logic）</p>
</blockquote>
<p><strong>思想</strong>：模型$M$是一个状态迁移系统，性质$\phi$是时态逻辑的公式。公式的真和假不是静态的，而是包含若干个状态，在一些状态下为真，在其他状态下为假。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330102847511.png" alt="image-20220330102847511" style="zoom:67%;" /></p>
<p>时态逻辑是一类逻辑，属于模态逻辑，依赖于对“时间”的特别观点</p>
<ul>
<li><strong>线性时间逻辑LTL</strong>：时间是线性的逻辑</li>
<li><strong>计算树逻辑CTL</strong>：时间形成分支的逻辑</li>
</ul>
<blockquote>
<p>常用于硬件和通信协议的验证中，现在开始用于软件的验证。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329081328823.png" alt="image-20220329081328823" style="zoom: 67%;" /></p>
<blockquote>
<p>在状态$s_1$下，p为真</p>
<p>一共有4个迁移关系——箭头表示迁移方向</p>
<p>标记函数是状态到标记集合<strong>幂集</strong>的映射</p>
</blockquote>
<p><strong>线性时态逻辑LTL的特点</strong>：</p>
<ul>
<li>将时间建模成<strong>状态</strong>的序列，无限延申至未来 。该状态序列称为<strong>计算路径</strong>或路径。</li>
<li>使用指示<strong>未来</strong>的联结词</li>
<li>未来一般不确定，出现若干可能路径</li>
</ul>
<h3 id="3-2-1-LTL的语法"><a href="#3-2-1-LTL的语法" class="headerlink" title="3.2.1 LTL的语法"></a>3.2.1 LTL的语法</h3><blockquote>
<p>::=表示定义为</p>
<p>永真式：$\top$，向下；永假式：$\bot$，向上</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329082329423.png" alt="image-20220329082329423" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329082352044.png" alt="image-20220329082352044" style="zoom: 67%;" /></p>
<h4 id="LTL公式举例"><a href="#LTL公式举例" class="headerlink" title="LTL公式举例"></a>LTL公式举例</h4><blockquote>
<p>叶子节点是原子符号，非叶子节点是联结词</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329082816542.png" alt="image-20220329082816542" style="zoom: 67%;" /></p>
<p>又例，合法的LTL公式和不合法的LTL公式</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329083021756.png" alt="image-20220329083021756" style="zoom: 67%;" /></p>
<h4 id="时态连接词的优先级"><a href="#时态连接词的优先级" class="headerlink" title="时态连接词的优先级"></a>时态连接词的优先级</h4><ul>
<li>约定<strong>最高级</strong>：小括号</li>
<li><p><strong>1级</strong>：一元连接词$\neg, X, F, G(包括时态)$</p>
</li>
<li><p><strong>2级</strong>：二元连接词$U, R, W(时态)$</p>
</li>
<li><strong>3级</strong>：二元连接词$\vee, \land$</li>
<li><strong>4级</strong>：二元连接词$\to$</li>
</ul>
<blockquote>
<p>避免出现（歧义）二义性</p>
</blockquote>
<h4 id="LTL公式的子公式"><a href="#LTL公式的子公式" class="headerlink" title="LTL公式的子公式"></a>LTL公式的子公式</h4><p><strong>定义</strong>：LTL公式Ф的子公式是任意公式ψ，子公式的语法分析树是Ф的子树</p>
<blockquote>
<p>注意：子树可以包括自身</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329083459604.png" alt="image-20220329083459604" style="zoom: 67%;" /></p>
<h3 id="3-2-2-LTL的语义"><a href="#3-2-2-LTL的语义" class="headerlink" title="3.2.2 LTL的语义"></a>3.2.2 LTL的语义</h3><blockquote>
<p>Semantics of LTL</p>
</blockquote>
<h4 id="模型的概念"><a href="#模型的概念" class="headerlink" title="模型的概念"></a>模型的概念</h4><blockquote>
<p>可以用迁移系统来建模系统，迁移系统通过<strong>状态</strong>(static structure)和<strong>迁移</strong>(dynamic structure)来建模。</p>
</blockquote>
<p><strong>定义</strong>：一个迁移系统$M=(S,\to,L)$：</p>
<blockquote>
<p>注：M的意思是：给状态集S赋予一个S上的二元关系迁移$\to$，得到一个标记函数(label function)L。这个迁移系统就叫做模型</p>
</blockquote>
<p>（1）是一个状态集合S，</p>
<p>（2）带有迁移关系$\to$（S上的二元关系），使得每个$s \in S$，有某个$s’ \in S$，且<strong>满足</strong>$s \to s’$</p>
<p>（3）<strong>L</strong>为：一个标记函数$L:S \to P(Atoms)$</p>
<p><strong>根据定义</strong>：<br>（1）一个模型有状态的集合S</p>
<p>（2）每个状态S伴随有原子命题的集合，即：$L(s)$：在特定的状态S下为真的原子集合</p>
<blockquote>
<p>我们用：P(Atoms)表示Atoms的幂集（Atoms就是原子公式）</p>
<p><strong>幂集的概念</strong>（集合论中提到过）</p>
<p>举例：$\{ p, q \}的幂集是\{ \varnothing, \{ p \}, \{q\},\{p,q \} \}$</p>
</blockquote>
<h4 id="状态迁移系统举例"><a href="#状态迁移系统举例" class="headerlink" title="状态迁移系统举例"></a>状态迁移系统举例</h4><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329084127968.png" alt="image-20220329084127968" style="zoom: 67%;" /></p>
<blockquote>
<p>①迁移系统M作为有向图表示；</p>
<p>②用$l$标记状态S当且仅当$l \in L(s)$</p>
</blockquote>
<p>添加死锁状态</p>
<blockquote>
<p>由迁移系统的定义，每一个状态都要迁移到其他状态。</p>
<p>但是下图中的左图，$s_4$没有迁移，处于死锁状态，因此添加死锁扩展系统</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329084546637.png" alt="image-20220329084546637" style="zoom: 67%;" /></p>
<h4 id="路径的概念"><a href="#路径的概念" class="headerlink" title="路径的概念"></a>路径的概念</h4><p><strong>定义</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329085758649.png" alt="image-20220329085758649" style="zoom: 67%;" /></p>
<blockquote>
<p>例如，$\pi^3$是$s_3 \to s_4$</p>
</blockquote>
<p><strong>迁移系统展开成无限计算树</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329085916297.png" alt="image-20220329085916297" style="zoom: 67%;" /></p>
<blockquote>
<p>向左迁移放到左支，向右迁移放在右支</p>
<p>无限计算树没有环，而有向图中可以有环</p>
</blockquote>
<p>将模型M（系统）展开成一个从特定状态开始的所有计算路径的无限树。</p>
<p>得到的无限计算树中，模型M的执行路径被明确的表示出来。</p>
<p><strong>关于路径上满足关系的定义</strong>：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329090337424.png" alt="image-20220329090337424" style="zoom: 67%;" /></p>
<blockquote>
<p>永真式永远可以被满足，永假式总是不可满足的</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329090433297.png" alt="image-20220329090433297" style="zoom: 67%;" /></p>
<blockquote>
<p>对于3)$s_1$满足p为真，则路径满足p</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329090909667.png" alt="image-20220329090909667" style="zoom: 67%;" /></p>
<blockquote>
<p>对于8)满足$X\phi$，则$s_2$满足$\phi$——$s_1$的next</p>
<p>9)满足$G\phi$，则所有状态满足$\phi$</p>
<p>10)满足$F\phi$，则未来某个状态满足$\phi$，存在性命题</p>
<p>11)满足$\phi U \psi$，则前面有限个都满足$\psi$，之后的第一个满足$\phi$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329091605442.png" alt="image-20220329091605442" style="zoom: 67%;" /></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329091934336.png" alt="image-20220329091934336" style="zoom: 67%;" /></p>
<blockquote>
<p>对于12)<strong>弱直到</strong>包含直到，也可以是（$\psi$一直不出现）从第一个开始都满足$\phi$</p>
<p>对于13)使用$\phi$<strong>释放</strong>$\psi$：某一个满足$\phi$，在之前（包括释放的点）都满足$\psi$。或者$\phi$始终不出现，$\psi$一直成立。——出现的$\phi$释放了$\psi$</p>
</blockquote>
<p><strong>释放R是直到U的对偶</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329092922234.png" alt="image-20220329092922234" style="zoom: 67%;" /></p>
<blockquote>
<p>无论是until（直到）还是W（弱-直到）都<strong>未说明until之后所发生的任何事情</strong></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329093230097.png" alt="image-20220329093230097" style="zoom: 67%;" /></p>
<blockquote>
<p>在定义中，未来状态包括当前状态</p>
<p><strong>在LTL中，U表示之前的状态</strong></p>
</blockquote>
<p>如果模型M<strong>每一条可能</strong>的执行路径<strong>都满足某公式</strong>。</p>
<p>我们可将模型作为整体看待：</p>
<blockquote>
<p>前面都是公式满足性质，本条定义是对于所有公式满足性质的条件下，模型中的公式满足性质</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329093555609.png" alt="image-20220329093555609" style="zoom: 67%;" /></p>
<p>例题：检测模型</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220329094225852.png" alt="image-20220329094225852" style="zoom: 67%;" /></p>
<blockquote>
<p>对于4)$s_0$的下一个状态都满足r</p>
<p>对于6)从无限计算树来看容易得到。$s_2$满足前件和后件</p>
</blockquote>
<h3 id="3-2-3-规范的实际模式"><a href="#3-2-3-规范的实际模式" class="headerlink" title="3.2.3 规范的实际模式"></a>3.2.3 规范的实际模式</h3><p>在计算机系统中我们经常应用，准备、就绪、运行、请求、等待一些状态。</p>
<blockquote>
<p>例如：操作系统中的进程</p>
<p>GFp：沿着问题中的路径，p无限多次地发生</p>
</blockquote>
<p><strong>LTL可以描述实际系统中的以下一些性质</strong>：</p>
<ol>
<li><p>永远不可能没有准备好就启动</p>
<blockquote>
<p>$G \neg (started \land \neg ready)$</p>
<p>对每个状态而言</p>
</blockquote>
</li>
<li><p>对任何状态，如果一个请求发生（对某些资源，如打印机），那么将最终被确认</p>
<blockquote>
<p>$G(requested \to F \ acknowledge)$</p>
</blockquote>
</li>
<li><p>在每条计算路径上，某特定进程可以无限地处于使能状态</p>
<blockquote>
<p>$G F(enabled)$</p>
<p>对于每个（路径）状态的未来都有使能</p>
</blockquote>
</li>
<li><p>一个特定过程最终被永久死锁</p>
<blockquote>
<p>$F G (deadlock)$</p>
<p>从未来的某一点开始，所有状态都被死锁</p>
</blockquote>
</li>
<li><p>如果该过程使能（被激活）无限多次，则它运行无限多次</p>
<blockquote>
<p>$GF(enabled) \to GF(running)$</p>
<p>对于所有的未来</p>
</blockquote>
</li>
</ol>
<p>【举例】如果乘客想去5楼，一个上行电梯在2楼不改变方向。</p>
<blockquote>
<p>$G(2楼 \land 方向向上 \land 按下5楼按钮 \to (方向向上 \cup 5楼))$</p>
</blockquote>
<p><strong>LTL描述不了的事情</strong></p>
<ol>
<li>从任何状态出发，都能（即<strong>存在</strong>一条路径）达到重启状态。</li>
<li>电梯可以在第3层保持关门闲置（即存在一条从该层到该层的路径，沿该路径电梯停留在原地）</li>
</ol>
<blockquote>
<p>无法直接断定这些路径的存在性</p>
</blockquote>
<p>表达这些事情需要对路径使用存在量词，<strong>计算树逻辑（CTL）</strong>中可以解决这些问题。</p>
<h3 id="3-2-4-LTL公式之间的重要等价"><a href="#3-2-4-LTL公式之间的重要等价" class="headerlink" title="3.2.4 LTL公式之间的重要等价"></a>3.2.4 LTL公式之间的重要等价</h3><blockquote>
<p>线性逻辑也有等价公式</p>
</blockquote>
<p><strong>定义</strong>：两个LTL公式$\Phi$和$\Psi$是语义等价的（等价）写为$\Phi \equiv \Psi$，如果对所有模型M以及M中的所有路径。$\pi:\pi \vDash \Phi$ iff $\pi \vDash \Psi$</p>
<p>（两个公式在任何赋值/解释下，两个公式的含义相同）</p>
<blockquote>
<p>我们知道命题等价公式为：</p>
<p>$\neg (\Phi \land \Psi) \equiv \neg \Phi \vee \neg \Psi$</p>
<p>$\neg (\Phi \vee \Psi) \equiv \neg \Phi \land \neg \Psi$</p>
</blockquote>
<p>类似的，我们给出LTL公式的等价</p>
<blockquote>
<p>G和F对偶，X自偶</p>
<p>U和R对偶</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330195059716.png" alt="image-20220330195059716" style="zoom:67%;" /></p>
<blockquote>
<p>A1和A2可以根据对偶公式。不满足所有未来状态满足性质等价于某未来状态不满足性质</p>
<p>B是关于分配律的等值式</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330195201692.png" alt="image-20220330195201692" style="zoom:67%;" /></p>
<blockquote>
<p>C8：某未来状态满足性质，等价于不加约束直到性质</p>
<p>C10：直到是弱直到和某未来状态$\psi$出现的合取</p>
<p>C11：弱直到包含直到和全部未来状态满足$\phi$两种情况</p>
<p>C12：注意到释放点处也满足性质$\psi$，因此需要考虑最后临界点的情况——释放自身点</p>
<p>即，释放分为了两部分：前面的和它本身</p>
<p><strong>2022.4.2更新</strong>：新的理解。对于$\pi^i \vDash (\phi \vee \psi)$，标记函数可以取值为$\phi$或者$\psi$（取值范围，从这两个中选）。</p>
<p>这样，通过$\phi \vee \psi$，对于定义中取$i$的情况，由于取值范围是$\{\phi, \psi\}$。就会出现一个状态有$\pi^i \vDash \psi$，且$\pi^i \nvDash \phi$，得到$j = 1,2,…,i-1$时都满足直到的定义了</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220401083711461.png" alt="image-20220401083711461" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220401084117612.png" alt="image-20220401084117612" style="zoom:67%;" /></p>
<blockquote>
<p>X连接词出现在每一个联结词集合</p>
</blockquote>
<h2 id="3-3-模型检测：系统、工具和性质"><a href="#3-3-模型检测：系统、工具和性质" class="headerlink" title="3.3 模型检测：系统、工具和性质"></a>3.3 模型检测：系统、工具和性质</h2><p>讨论线性时态逻辑能表达的性质，以互斥为例。</p>
<h3 id="3-3-1-互斥"><a href="#3-3-1-互斥" class="headerlink" title="3.3.1 互斥"></a>3.3.1 互斥</h3><p>互斥最常见的问题，如：在同一时刻不能有两个用户使用一个资源。也就是说<strong>不能在同一时刻访问一个临界资源</strong>，否则产生互斥，而互斥的结果是死锁。</p>
<h4 id="检验互斥系统"><a href="#检验互斥系统" class="headerlink" title="检验互斥系统"></a>检验互斥系统</h4><ol>
<li><p>找到一个协议：给定时刻t，允许某个进程可访问共享资源；</p>
</li>
<li><p>检测该协议是否具有某些性质：</p>
<ul>
<li><p><strong>安全性</strong>：在任何时候只有一个进程处于临界区；</p>
<blockquote>
<p>只有safety是不够的，如果一个协议把所有进程都排除在关键段以外，虽然安全，但没有用处。</p>
</blockquote>
</li>
<li><p><strong>活性</strong>：只要有进程请求进入临界区，则最终会被允许进入（但不知何时发生）</p>
</li>
<li><p><strong>无阻性</strong>：进程总可以请求进入临界区</p>
<blockquote>
<p>至此一些简单粗暴的协议可以工作。</p>
<p>但考虑这些协议在进程循环中，而显然一些进程请求访问共享资源更加频繁。</p>
</blockquote>
</li>
<li><p><strong>非严格顺序性</strong>：各进程无需按严格顺序进入临界区</p>
</li>
</ul>
</li>
</ol>
<h4 id="第一次建模"><a href="#第一次建模" class="headerlink" title="第一次建模"></a>第一次建模</h4><p>对两个进程建模，设：</p>
<ul>
<li>排队：非关键状态<code>n</code></li>
<li>就绪：申请（试图）进入关键状态<code>t</code></li>
<li>运行：处于关键状态<code>c</code></li>
</ul>
<p>每个单独的进程按照循环$n \to t \to c \to n \to … $进行迁移，两个进程交错执行（异步交错，一次只允许一个进程发生迁移）</p>
<blockquote>
<p>状态迁移图：</p>
<ul>
<li>无$c_1c_2$状态</li>
<li>每次迁移改一个进程的状态</li>
</ul>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330202432242.png" alt="image-20220330202432242" style="zoom: 67%;" /></p>
<p>$s_0$为开始状态，两个进程都处于n状态。下一个状态可能是进程1状态变成t或者进程2状态变成t。</p>
<p>注意到：对于进程2，$s_4$状态中不能迁移，即不能两个进程都处于临界区关键状态</p>
<blockquote>
<p>性质1 安全性：任何时刻，只有一个进程处于关键段</p>
</blockquote>
<p>$\Phi = G \neg (c_1 \land c_2)$——任何时刻用G表示，不出现两个进程同时处于关键段</p>
<p>结论：该协议满足性质1</p>
<blockquote>
<p>性质2 活性：任何请求进入关键段的进程，最终必将进入</p>
</blockquote>
<p>$\Phi = G(t_1 \to Fc_1)$——以进程1为例，任何（G），请求进入则未来某状态为处于关键段状态</p>
<p>可找到反例，$s_0 \to s_1 \to s_3 \to s_7 \to s_1 \to s_3 \to s_7 ……$（该路径中进程1始终处于请求状态$t_1$）。同理，$s_0 \to s_5 \to s_3 \to s_4 \to s_5 \to s_3 ……$</p>
<p>结论：不满足性质2</p>
<blockquote>
<p>性质3 无阻性：一个进程总可以请求进入关键段</p>
</blockquote>
<p>$\Phi$：对每个满足$n_1$的状态，存在满足$t_1$的后继状态（可以找到这样的路径，但是无法用LTL表示）</p>
<p>结论：关于路径的存在量词，无法用LTL表达</p>
<blockquote>
<p>性质4 非严格顺序性：不需要轮流进入关键段</p>
</blockquote>
<p>补公式$\Phi:G(c_1 \to c_1W(\neg c_1 \land \neg c_1Wc_2))$</p>
<p>（解释：对于所有未来状态，如果处于$c_1$状态，则$c_1$保持运行，直到$c_1$不再运行且$c_1$不运行保持一段时间，直到$c_2$运行）——即$c_1$和$c_2$轮流进入关键段</p>
<p>补公式可找到一个反例，$s_0 \to s_5 \to s_3 \to s_4 \to s_5 \to s_3 \to s_4……$进程1运行结束后，进程2没有进入关键段。意味着不满足严格顺序性，即满足非严格顺序性。</p>
<p>结论：满足性质4</p>
<h4 id="第二次建模"><a href="#第二次建模" class="headerlink" title="第二次建模"></a>第二次建模</h4><blockquote>
<p>性质2不满足的原因：进程1和进程2存在交叉状态$s_3$，此时进程1和进程2都处于请求进入临界区状态。</p>
<p>使得进程1请求进入临界区后结果进程2进入了临界区或者2请求，1进入。</p>
</blockquote>
<p>将状态$s_3$分成两个状态$s_3$和$s_9$，来解决活性不满足问题</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220330203448706.png" alt="image-20220330203448706" style="zoom: 67%;" /></p>
<h3 id="3-3-2-NuSMV模型检测器"><a href="#3-3-2-NuSMV模型检测器" class="headerlink" title="3.3.2 NuSMV模型检测器"></a>3.3.2 NuSMV模型检测器</h3><blockquote>
<p>New Symbolic Model verifier, SMV</p>
</blockquote>
<p>以新符号模型检测器为例讨论时态逻辑的应用。</p>
<p><strong>SMV功能</strong></p>
<ol>
<li><p>SMV是画成图形的模型语言，提供一种描述模型的语言，用它描述的模型被称为程序</p>
</li>
<li><p>SMV可以检测LTL和CTL公式的有效性</p>
</li>
<li><p>SMV描述模型的程序和用时态逻辑公式描述的规范作为输入</p>
<blockquote>
<p>若，规范成立，则：输出真；否则输出假</p>
</blockquote>
</li>
</ol>
<p><strong>SMV程序</strong>：由一个或多个模块构成，其中必须有一个main模块。</p>
<p><strong>模块</strong>：</p>
<ol>
<li>变量声明</li>
<li>赋值（初值）</li>
<li>程序体</li>
</ol>
<p><strong>检测器</strong>：</p>
<p>输出：真或假</p>
<p>【例】将一个程序和规范构成的代码输入给SMV</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MODULE main</span><br><span class="line">VAR</span><br><span class="line">    request : boolean;</span><br><span class="line">    status : &#123;ready, busy&#125;;</span><br><span class="line">ASSIGN</span><br><span class="line">	-- 初始状态为ready</span><br><span class="line">    init(status) := ready;  </span><br><span class="line">    next(status) := case</span><br><span class="line">        -- 有请求置为busy</span><br><span class="line">        request : busy; </span><br><span class="line">        -- 没有请求，下一个状态不确定，1为缺省情况</span><br><span class="line">        TRUE : &#123;ready, busy&#125;; </span><br><span class="line">    esac;</span><br><span class="line">LTLSPEC</span><br><span class="line">    G(request -&gt; F status = busy)</span><br></pre></td></tr></table></figure>
<p><strong>运行截图</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220405082440715.png" alt="image-20220405082440715" style="zoom:67%;" /></p>
<p>为了可读性和反应验证的性质和结论，可将程序划分成若干个模块，（类同主程序与子程序）</p>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h3 id="3-3-4-重温互斥"><a href="#3-3-4-重温互斥" class="headerlink" title="3.3.4 重温互斥"></a>3.3.4 重温互斥</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MODULE prc(other_st, turn, myturn)</span><br><span class="line">-- 其他进程状态 other_st</span><br><span class="line">-- 决定哪个进程进入关键段的标志变量 turn</span><br><span class="line">-- 我的进程标志变量 myturn</span><br><span class="line">VAR</span><br><span class="line">    st : &#123;n, t, c&#125;;</span><br><span class="line">ASSIGN</span><br><span class="line">    init(st) := n;</span><br><span class="line">    </span><br><span class="line">    next(st) := case</span><br><span class="line">        -- 当前状态为非关键状态，可能保持n或者请求进入（t）</span><br><span class="line">        (st = n) : &#123;t, n&#125;;</span><br><span class="line">        -- 当前状态为请求进入，如果另一个进程是n，则直接进入临界状态（c）</span><br><span class="line">        (st = t) &amp; (other_st = n) : c;</span><br><span class="line">        -- 状态（就绪）t且其他进程状态（排队）n</span><br><span class="line">        -- 当前状态请求进入，且另一个也是t，在进入c之前，检查轮次turn = myturn</span><br><span class="line">        -- 当它为c，移回n</span><br><span class="line">        (st = t) &amp; (other_st = t) &amp; (turn = myturn) : c;</span><br><span class="line">        -- 当前处于临界/关键状态，可以保持或者变成非关键状态（n）</span><br><span class="line">        (st = c) : &#123;c, n&#125;;</span><br><span class="line">        -- 缺省状态</span><br><span class="line">        TRUE : st;</span><br><span class="line">    esac;</span><br><span class="line">    </span><br><span class="line">    next(turn) := case</span><br><span class="line">        -- 当前状态处于关键状态，则进程交替</span><br><span class="line">        (turn = myturn) &amp; (st = c) : !turn;</span><br><span class="line">        TRUE : turn;</span><br><span class="line">    esac;</span><br><span class="line"></span><br><span class="line">-- 公平性约束条件</span><br><span class="line">-- 限制执行的路径</span><br><span class="line">FAIRNESS running</span><br><span class="line">-- 规范psi，限制进程会无限多次运行某公式的路径和无限多次不运行的情况</span><br><span class="line">-- 前者不满足公平性，后者不满足活性</span><br><span class="line">FAIRNESS !(st = c)</span><br><span class="line"></span><br><span class="line">MODULE main</span><br><span class="line">VAR</span><br><span class="line">	-- process 采用异步方式</span><br><span class="line">    pr1 : process prc(pr2.st, turn, FALSE);</span><br><span class="line">    pr2 : process prc(pr1.st, turn, TRUE);</span><br><span class="line">    turn : boolean;</span><br><span class="line">ASSIGN</span><br><span class="line">    init(turn) := FALSE;</span><br><span class="line"></span><br><span class="line">-- safety 安全性</span><br><span class="line">LTLSPEC </span><br><span class="line">    G ! ((pr1.st = c) &amp; (pr2.st = c))</span><br><span class="line">-- liveness 活性</span><br><span class="line">LTLSPEC</span><br><span class="line">    G((pr1.st = t) -&gt; F (pr1.st = c))</span><br><span class="line">LTLSPEC</span><br><span class="line">    G((pr2.st = t) -&gt; F(pr2.st = c))</span><br><span class="line">-- &#x27;negation&#x27; of strict sequencing (desired to be false)</span><br><span class="line">-- 非严格顺序性，验证补公式</span><br><span class="line">LTLSPEC</span><br><span class="line">    G (pr1.st = c -&gt; (G pr1.st = c | (pr1.st = c U </span><br><span class="line">        (!(pr1.st = c) &amp; G !(pr1.st = c) | (!(pr1.st = c) U pr2.st = c)))))</span><br></pre></td></tr></table></figure>
<p><strong>运行截图</strong></p>
<blockquote>
<p>非严格顺序性不满足</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220405092210497.png" alt="image-20220405092210497" style="zoom:80%;" /></p>
<h3 id="3-3-5-摆渡者难题"><a href="#3-3-5-摆渡者难题" class="headerlink" title="3.3.5 摆渡者难题"></a>3.3.5 摆渡者难题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MODULE main</span><br><span class="line"></span><br><span class="line">VAR </span><br><span class="line">	ferryman : boolean ; goat : boolean ;</span><br><span class="line">	cabbage  : boolean ; wolf : boolean ;</span><br><span class="line">	carry : &#123; g , c , w , none &#125;;</span><br><span class="line"></span><br><span class="line">ASSIGN</span><br><span class="line">	-- 初始状态均为FALSE，表示都在起始河岸</span><br><span class="line">	-- 若都到达河岸，则均为TRUE</span><br><span class="line">	init ( ferryman ) := FALSE ; init ( goat ) := FALSE ;</span><br><span class="line">	init ( cabbage )  := FALSE ; init ( wolf ) := FALSE ;</span><br><span class="line">	init ( carry ) := none;</span><br><span class="line"></span><br><span class="line">	next ( ferryman ) := !ferryman;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	next ( goat ) := case</span><br><span class="line">		ferryman = goat &amp; next ( carry ) = g : next ( ferryman );</span><br><span class="line">		TRUE 	: goat ; </span><br><span class="line">	esac ;</span><br><span class="line"></span><br><span class="line">	next ( cabbage ) := case</span><br><span class="line">		ferryman = cabbage &amp; next ( carry ) = c : next ( ferryman );</span><br><span class="line">		TRUE 	: cabbage ; </span><br><span class="line">	esac ;</span><br><span class="line"></span><br><span class="line">	next ( wolf ) := case</span><br><span class="line">		ferryman = wolf &amp; next ( carry ) = w : next ( ferryman );</span><br><span class="line">		TRUE : wolf ; </span><br><span class="line">	esac ;</span><br><span class="line"></span><br><span class="line">-- 待检测的公式：由初始状态经过多次运转达到目标河岸</span><br><span class="line">-- 安全性 U 到达对岸</span><br><span class="line">-- 山羊和白菜或者山羊和狼在同一侧的话，山羊需要和农夫在同一侧。此时为安全的</span><br><span class="line">-- 由于找的是是否有解（存在一条路径），因此采用补公式。如果补公式不满足，系统会给出反例</span><br><span class="line">LTLSPEC !(( ( goat = cabbage | goat = wolf ) -&gt; goat = ferryman )</span><br><span class="line">U ( cabbage &amp; goat &amp; wolf &amp; ferryman ))</span><br></pre></td></tr></table></figure>
<p><strong>运行截图</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220405094031202.png" alt="image-20220405094031202" style="zoom:80%;" /></p>
<p><strong>解路径</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220405093958091.png" alt="image-20220405093958091" style="zoom:80%;" /></p>
<h2 id="3-4-分支时间逻辑"><a href="#3-4-分支时间逻辑" class="headerlink" title="3.4 分支时间逻辑"></a>3.4 分支时间逻辑</h2><p>计算树逻辑Computation Tree Logic, CTL</p>
<p>线性时态逻辑（LTL）是在路径上赋值，它定义了一个系统满足一个LTL公式，这里就有一个问题:</p>
<p>即：LTL隐含着对所有路径做全称量词的限制，因此，断言一条路径存在的性质不能用LTL表达，而分支时间逻辑就解决了这个问题。</p>
<p>分支时间逻辑通过允许使用<strong>路径量词（全称量词与存在量词）</strong>来解决。<br>分支时间逻辑是在线性逻辑的基础上加上了量词A和E，其中： <strong>A表示对所有路径</strong>；<strong>E表示存在一条路径</strong></p>
<blockquote>
<p>例如，我们给出写法：<br>1）存在一个可达状态满足q：</p>
<p>写为：$EFq$。</p>
<p>2）对所有满足p的可达状态，可以连续地保持p直到到达一个满足q的状态，</p>
<p>写为：$AG(p →E[p U q])$</p>
<p>3）只要满足p的状态是可达的，系统可以永远连续不断呈现q，</p>
<p>写为：$AG（ p →E Gq）$</p>
<p>4）存在一个可达状态，由其出发的所有可达状态都满足p，</p>
<p>写为：$EFAGp$</p>
</blockquote>
<h3 id="3-4-1-CTL的语法"><a href="#3-4-1-CTL的语法" class="headerlink" title="3.4.1 CTL的语法"></a>3.4.1 CTL的语法</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407211909317.png" alt="image-20220407211909317" style="zoom:67%;" /></p>
<p><strong>Note</strong>: CTL时态联结词都是<strong>成对</strong>出现（一对符号），对中第一个是A或E。</p>
<p><strong>Note</strong>: A是<strong>“沿着所有路径”</strong>无一例外（全部）。实际用处最多的是检查软件的可靠性。</p>
<blockquote>
<p>例如：检查某系统的编译程序，必须将所有可能的路径都检查到，看看是否通。</p>
</blockquote>
<p><strong>Note</strong>: E的含义是<strong>“沿至少（存在）一条路径”</strong>（可能）。该联结词用于对系统的“溢出”，“死锁”等方面的检查。</p>
<blockquote>
<p>例如：某控制系统的上，下限，及死角等。</p>
</blockquote>
<p><strong>Note</strong>: 符号对的<strong>第二个符号</strong>是，X，F，G，U，即：X：下一状态，F：某个未来状态，G：所有未来状态（全局），U：直到。而成对的符号是<strong>不能分开</strong>的（在CTL中）。</p>
<blockquote>
<p>例如：$E[Ф_1UФ_2]$中的符号对是EU</p>
</blockquote>
<p>AU和EU是混和使用中缀和前缀CTL的二元联结词</p>
<blockquote>
<p>严格讲<strong>中缀</strong>形式为：$Ф_1 EU Ф_2$；<strong>前缀</strong>形式为：$EU[Ф_1 ，Ф_2]$</p>
</blockquote>
<p><strong>Note</strong>: 符号（联结词）X，F，G和U若前面没有<strong>A或E</strong>的情况下不能单独出现（CTL中规定）。</p>
<p><strong>Note</strong>: CTL中不包含LTL中的W（弱-直到）和R（释放）</p>
<p>同LTL一样CTL也有优先级。</p>
<blockquote>
<p>约定：</p>
<p>1）一元联结词┐和时态联结词AG，EG，AF，EF，AX，EX</p>
<p>2）∧，∨</p>
<p>3）→，AU，EU</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407212749016.png" alt="image-20220407212749016" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407212902428.png" alt="image-20220407212902428" style="zoom:67%;" /></p>
<p><strong>Note</strong>: $A[(rU q) \land (PUr)]$不是CTL合式公式</p>
<p>原因：语法定义中不允许布尔联结词，如：（┬，∨，∧，┐）直接放在A和E，如A[…]，E[…]中。</p>
<p><strong>Note</strong>: <strong>A和E后面必须紧跟着G，F，X，或U之一</strong>出现。例如：$A[ФUФ]$等形式</p>
<p>CTL同其他语言类同，也有<strong>语法分析树</strong></p>
<p><strong>定义</strong>：一个CTL公式Ф的子公式是这样的公式ψ，其语法分析树是Ф的语法分析树的子树。</p>
<blockquote>
<p>如：下图语法分析树中的EU，AX，EX，均是AU的子树。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213237670.png" alt="image-20220407213237670" style="zoom:67%;" /></p>
</blockquote>
<h3 id="3-4-2-计算树逻辑的语义"><a href="#3-4-2-计算树逻辑的语义" class="headerlink" title="3.4.2 计算树逻辑的语义"></a>3.4.2 计算树逻辑的语义</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213505591.png" alt="image-20220407213505591" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213522987.png" alt="image-20220407213522987" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213540267.png" alt="image-20220407213540267" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213618961.png" alt="image-20220407213618961" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213632094.png" alt="image-20220407213632094" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213643278.png" alt="image-20220407213643278" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213656773.png" alt="image-20220407213656773" style="zoom:67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220407213712573.png" alt="image-20220407213712573" style="zoom:67%;" /></p>
<h3 id="3-4-3-规范的实际模式"><a href="#3-4-3-规范的实际模式" class="headerlink" title="3.4.3 规范的实际模式"></a>3.4.3 规范的实际模式</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220047491.png" alt="image-20220411220047491" style="zoom: 67%;" /></p>
<p> 常用的原子的规范的实际描述</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220131095.png" alt="image-20220411220131095" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220144209.png" alt="image-20220411220144209" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220158270.png" alt="image-20220411220158270" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220211259.png" alt="image-20220411220211259" style="zoom: 67%;" /></p>
<ul>
<li><strong>LTL能表达，但是CTL不能</strong></li>
</ul>
<blockquote>
<p>沿着路径满足性质的公式</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220237865.png" alt="image-20220411220237865" style="zoom: 67%;" /></p>
<blockquote>
<p>LTL表示“对路径，无限次使能则无限次运行”——沿着特殊路径的状态</p>
<p>CTL——路径的性质</p>
<p>如果使用计算树逻辑，则表达的enabled和running状态可以没有关系。即不是由使能得到执行，而是”从任何状态出发，都一定能到达使能，则从一切状态出发，都能执行“</p>
<p>“沿所有路径无限多次使能，那么沿所有路径无限多次运行”（性质更强）</p>
</blockquote>
<ul>
<li><strong>CTL能表达，但是LTL不能</strong></li>
</ul>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220326785.png" alt="image-20220411220326785" style="zoom: 67%;" /></p>
<h3 id="3-4-4-CTL公式间的重要等价"><a href="#3-4-4-CTL公式间的重要等价" class="headerlink" title="3.4.4 CTL公式间的重要等价"></a>3.4.4 CTL公式间的重要等价</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220423973.png" alt="image-20220411220423973" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220435260.png" alt="image-20220411220435260" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220452509.png" alt="image-20220411220452509" style="zoom: 67%;" /></p>
<h3 id="3-4-5-CTL联结词的适当集"><a href="#3-4-5-CTL联结词的适当集" class="headerlink" title="3.4.5 CTL联结词的适当集"></a>3.4.5 CTL联结词的适当集</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220507868.png" alt="image-20220411220507868" style="zoom: 67%;" /></p>
<blockquote>
<p>AR, ER, AW, EW不是基本的CTL公式，但是可以用EU, AU来表达相同的含义</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220522428.png" alt="image-20220411220522428" style="zoom: 67%;" /></p>
<blockquote>
<p>这6组很重要，采用递归定义</p>
<p>共同点：考虑当前状态和未来状态（对当前状态没有要求）的性质</p>
<p>对于5) 和6) ，由直到U的定义，对于第一个状态只能$\pi^1 \vDash \psi$</p>
</blockquote>
<h2 id="3-5-CTL-与LTL和CTL的表达能力"><a href="#3-5-CTL-与LTL和CTL的表达能力" class="headerlink" title="3.5 CTL*与LTL和CTL的表达能力"></a>3.5 CTL*与LTL和CTL的表达能力</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220815465.png" alt="image-20220411220815465" style="zoom: 67%;" /></p>
<blockquote>
<p>LTL隐含的条件是对所有路径成立，但是LTL描述的是每一条路径（特定路径）上的性质，因此可以在路径上选择范围。</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220828081.png" alt="image-20220411220828081" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220845848.png" alt="image-20220411220845848" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220904910.png" alt="image-20220411220904910" style="zoom: 67%;" /></p>
<blockquote>
<p>$\vee$可以使用联结词的适当集来表示</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411220923237.png" alt="image-20220411220923237" style="zoom: 67%;" /></p>
<p>CTL*的常用表示方法在计算机科学中的应用</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221004332.png" alt="image-20220411221004332" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221057677.png" alt="image-20220411221057677" style="zoom: 67%;" /></p>
<h2 id="3-6-模型检测算法"><a href="#3-6-模型检测算法" class="headerlink" title="3.6 模型检测算法"></a>3.6 模型检测算法</h2><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221124229.png" alt="image-20220411221124229" style="zoom: 67%;" /></p>
<h3 id="3-6-1-CTL模型检测算法"><a href="#3-6-1-CTL模型检测算法" class="headerlink" title="3.6.1 CTL模型检测算法"></a>3.6.1 CTL模型检测算法</h3><p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221203324.png" alt="image-20220411221203324" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221218412.png" alt="image-20220411221218412" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221233645.png" alt="image-20220411221233645" style="zoom: 67%;" /></p>
<blockquote>
<p>输入的公式 $\phi$ 变换成只用适当集表示的公式</p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221248981.png" alt="image-20220411221248981" style="zoom: 67%;" /></p>
<blockquote>
<p>标记$AF\psi_1$是一个逆推的过程，如下图所示。</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412092138941.png" alt="image-20220412092138941" style="zoom: 67%;" /></p>
</blockquote>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221308293.png" alt="image-20220411221308293" style="zoom: 67%;" /></p>
<blockquote>
<p>具体过程如下图：</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220412092211402.png" alt="image-20220412092211402" style="zoom:67%;" /></p>
</blockquote>
<p>算法应用例子：互斥模型，公式$E(\neg c_2 \cup c_1)$</p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221331213.png" alt="image-20220411221331213" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221354702.png" alt="image-20220411221354702" style="zoom: 67%;" /></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221412534.png" alt="image-20220411221412534" style="zoom: 67%;" /></p>
<p><strong>算法的问题——状态爆炸</strong></p>
<p><img src="https://gingkopic.oss-cn-beijing.aliyuncs.com/img/image-20220411221441983.png" alt="image-20220411221441983" style="zoom: 67%;" /></p>
]]></content>
      <categories>
        <category>2022 Spring</category>
        <category>数理逻辑</category>
      </categories>
      <tags>
        <tag>mathematical logic</tag>
      </tags>
  </entry>
</search>
